<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" data-scrapbook-source="https://wiki.haskell.jp/Old/sampou.org/Programming_WayToHaskeller"><head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <title>Haskell-jp wiki - Old/sampou.org/Programming_WayToHaskeller</title>
    <link href="jquery-ui.min.css" rel="stylesheet" media="print" type="text/css">
        <link href="custom.css" rel="stylesheet" media="screen, projection" type="text/css">
    <link href="print.css" rel="stylesheet" media="print" type="text/css">
    
    <!--[if IE]><link href="/css/ie.css" rel="stylesheet" media="screen, projection" type="text/css" /><![endif]-->
  </head>
  <body>
    <div id="doc3" class="yui-t1">
        <div id="yui-main">
          <div id="maincol" class="yui-b">
            <div id="userbox">
  <noscript>
    <a href="https://wiki.haskell.jp/_login">Login</a>
    <a href="index.html">Logout</a>
  </noscript>
  &nbsp;
  <a id="loginlink" class="login" href="https://wiki.haskell.jp/_login">Login / Get an account</a>
  <a id="logoutlink" class="login" href="index.html">Logout <span id="logged_in_user"></span></a>
</div>
            <ul class="tabs"><li class="selected"><a href="">view</a></li><li><a href="https://wiki.haskell.jp/_edit/Old/sampou.org/Programming_WayToHaskeller">edit</a></li><li><a href="https://wiki.haskell.jp/_history/Old/sampou.org/Programming_WayToHaskeller">history</a></li><li><a href="https://wiki.haskell.jp/_discuss/Old/sampou.org/Programming_WayToHaskeller">discuss</a></li></ul> 
            <div id="content">
  
  <h1 class="pageTitle"><a href="">Old/sampou.org/Programming_WayToHaskeller</a></h1>
  
  <div id="wikipage"><div id="TOC">
<ul>
<li><a href="#programming_waytohaskeller"><span>Programming_WayToHaskeller</span></a><ul>
<li><a href="#haskeller-%E3%81%B8%E3%81%AE%E9%81%93">Haskeller への道</a></li>
<li><a href="#%E5%AF%9D%E3%81%8C%E3%81%88%E3%82%8A">寝がえり</a><ul>
<li><a href="#%E5%8B%89%E5%BC%B7%E3%82%88%E3%82%8A%E3%81%BE%E3%81%9A%E5%87%A6%E7%90%86%E7%B3%BB%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB">勉強よりまず処理系のインストール</a></li>
<li><a href="#%E3%81%A9%E3%82%8C%E3%81%AB%E3%81%97%E3%82%88%E3%81%86%E3%81%8B%E3%81%AA">ど・れ・に・し・よ・う・か・な</a></li>
<li><a href="#prelude%E3%81%A3%E3%81%A6%E3%81%AA%E3%82%93%E3%81%9E%E3%82%84">Preludeってなんぞや?</a></li>
<li><a href="#%E3%83%98%E3%83%AB%E3%83%97">ヘルプ</a></li>
<li><a href="#emacs-%E3%82%92%E4%BD%BF%E3%81%84%E3%81%9F%E3%81%84">Emacs を使いたい</a></li>
<li><a href="#%E3%81%A1%E3%82%87%E3%81%A3%E3%81%A8%E3%81%B2%E3%81%A8%E3%82%84%E3%81%99%E3%81%BF%E9%9D%9E%E6%AD%A3%E6%A0%BC%E3%81%A3%E3%81%A6">【ちょっとひとやすみ】「非正格」って？</a></li>
</ul></li>
<li><a href="#%E3%81%AF%E3%81%84%E3%81%AF%E3%81%84">はいはい</a><ul>
<li><a href="#hello-world-%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0">Hello, World! プログラム</a></li>
<li><a href="#%E5%AE%9F%E8%A1%8C%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AB%E3%81%97%E3%81%A6%E3%81%BF%E3%82%88%E3%81%86">実行ファイルにしてみよう</a></li>
<li><a href="#runhugs">runhugs</a></li>
<li><a href="#%E3%82%84%E3%81%AF%E3%82%8A%E3%83%96%E3%83%A9%E3%83%83%E3%82%AF%E3%83%9C%E3%83%83%E3%82%AF%E3%82%B9%E3%81%AA%E3%81%AE%E3%81%8B">やはりブラックボックスなのか？</a></li>
<li><a href="#%E3%81%95%E3%82%89%E3%81%AB-echo.lhs-%E3%81%A8%E3%81%8B%E3%81%AD">さらに echo.lhs とかね</a></li>
<li><a href="#do-%E3%81%97%E3%81%BE%E3%81%97%E3%82%87">do しましょ</a></li>
<li><a href="#%E3%81%82%E3%81%A3%E3%81%A1%E3%82%83%E3%81%AE%E4%B8%96%E7%95%8C%E3%81%AE%E5%BC%95%E6%95%B0%E3%81%A8%E3%81%93%E3%81%A3%E3%81%A1%E3%82%83%E3%81%AE%E4%B8%96%E7%95%8C%E3%81%AE%E5%BC%95%E6%95%B0">あっちゃの世界の引数とこっちゃの世界の引数</a></li>
<li><a href="#%E3%83%A2%E3%83%8A%E3%83%89%E3%82%92%E9%81%A0%E7%9B%AE%E3%81%AB%E8%A6%8B%E3%82%8B">モナドを遠目に見る</a></li>
<li><a href="#cat.lhs-%E3%81%A8%E3%81%8B%E3%82%82%E3%81%BF%E3%81%A8%E3%81%8F">cat.lhs とかもみとく</a></li>
<li><a href="#%E3%81%A1%E3%82%87%E3%81%A3%E3%81%A8%E3%81%B2%E3%81%A8%E3%82%84%E3%81%99%E3%81%BF%E3%83%94%E3%83%A5%E3%82%A2%E3%81%AA%E6%80%A0%E3%81%91%E8%80%85">【ちょっとひとやすみ】ピュアな怠け者</a></li>
</ul></li>
<li><a href="#%E3%81%A4%E3%81%8B%E3%81%BE%E3%82%8A%E7%AB%8B%E3%81%A1">つかまり立ち</a><ul>
<li><a href="#%E3%83%AA%E3%82%B9%E3%83%88%E3%82%82%E3%83%A2%E3%83%8A%E3%83%89">リストもモナド？</a></li>
<li><a href="#main-%E3%81%AF%E9%96%A2%E6%95%B0%E3%81%98%E3%82%83%E3%81%AD%E3%83%BC%E3%81%AE%E3%81%8B">main は関数じゃねーのか？</a></li>
<li><a href="#io-a-%E3%81%AE-a-%E3%81%A8-a-%E3%81%AE-a">IO a の a と [a] の a</a></li>
<li><a href="#thunk-%E3%81%AF%E3%81%A9%E3%81%86%E6%9B%B8%E3%81%8F%E3%81%AE%E3%81%8B">thunk はどう書くのか？</a></li>
</ul></li>
<li><a href="#%E3%82%88%E3%81%A1%E3%82%88%E3%81%A1%E6%AD%A9%E3%81%8D">よちよち歩き</a><ul>
<li><a href="#%E8%87%AA%E5%88%86%E3%81%A7%E5%9E%8B%E3%82%92">自分で型を</a></li>
<li><a href="#%E3%82%8B%E3%82%8B%E3%82%8B%E9%A1%9Ekind%E3%81%A3%E3%81%A6">る、るる、類(kind)って？</a></li>
<li><a href="#myeq%E3%82%AF%E3%83%A9%E3%82%B9%E3%81%A3%E3%81%A6%E3%83%A4%E3%83%84">MyEqクラスってヤツ</a></li>
<li><a href="#%E5%90%8C%E3%81%98%E3%81%A8%E3%81%AF">同じとは？</a></li>
<li><a href="#%E3%81%BE%E3%81%A0%E4%B8%8D%E5%8B%95%E7%82%B9%E3%81%AF%E3%83%A0%E3%83%AA">まだ不動点はムリ</a></li>
<li><a href="#%E3%81%82%E3%82%84%E3%81%97%E3%81%84%E9%9B%86%E4%BC%9A">あやしい集会</a></li>
</ul></li>
<li><a href="#%E3%81%A6%E3%81%8F%E3%81%A6%E3%81%8F">てくてく</a><ul>
<li><a href="#%E3%81%A8---%E3%81%A8">= と &lt;- と</a></li>
<li><a href="#%E3%81%95%E3%82%89%E3%81%AB-%E3%81%A8%E3%81%AE%E9%96%A2%E4%BF%82%E3%81%8C%E5%88%86%E3%81%A3%E3%81%A6%E3%81%97%E3%81%BE%E3%81%88%E3%81%B0%E5%A4%A9%E4%B8%8B%E3%81%8B">さらに&lt;-と&gt;&gt;=の関係が分ってしまえば天下か?</a></li>
<li><a href="#getcontents%E3%81%AE%E3%83%90%E3%83%A4%E3%82%A4">getContentsのバヤイ</a></li>
<li><a href="#%E3%81%95%E3%82%89%E3%81%AB%E3%81%95%E3%82%89%E3%81%AB-%E3%81%A3%E3%81%A6%E3%81%AE%E3%81%AF%E3%81%93%E3%81%93%E3%81%AB%E3%82%82%E7%99%BB%E5%A0%B4">さらにさらに&lt;-ってのはここにも登場?</a></li>
</ul></li>
<li><a href="#%E3%81%99%E3%81%8D%E3%81%A3%E3%81%B7">すきっぷ</a></li>
<li><a href="#%E3%83%80%E3%83%B3%E3%82%B9%E3%83%80%E3%83%B3%E3%82%B9%E3%83%80%E3%83%B3%E3%82%B9">ダンスダンスダンス</a></li>
</ul></li>
</ul>
</div>

<h1 id="programming_waytohaskeller"><a href="" class="uri" title="Go to wiki page">Programming_WayToHaskeller</a></h1>
<p><a href="https://wiki.haskell.jp/Old/sampou.org/Programming" class="uri" title="Go to wiki page">Programming</a>:WayToHaskeller</p>
<hr>
<h2 id="haskeller-への道">Haskeller への道</h2>
<hr>
<p><a href="https://wiki.haskell.jp/Old/sampou.org/%e5%af%9d%e3%81%8c%e3%81%88%e3%82%8a" class="uri" title="Go to wiki page">寝がえり</a></p>
<ul>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/%e5%8b%89%e5%bc%b7%e3%82%88%e3%82%8a%e3%81%be%e3%81%9a%e5%87%a6%e7%90%86%e7%b3%bb%e3%81%ae%e3%82%a4%e3%83%b3%e3%82%b9%e3%83%88%e3%83%bc%e3%83%ab" class="uri" title="Go to wiki page">勉強よりまず処理系のインストール</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/%e3%81%a9%e3%83%bb%e3%82%8c%e3%83%bb%e3%81%ab%e3%83%bb%e3%81%97%e3%83%bb%e3%82%88%e3%83%bb%e3%81%86%e3%83%bb%e3%81%8b%e3%83%bb%e3%81%aa" class="uri" title="Go to wiki page">ど・れ・に・し・よ・う・か・な</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/Prelude%e3%81%a3%e3%81%a6%e3%81%aa%e3%82%93%e3%81%9e%e3%82%84?" class="uri" title="Go to wiki page">Preludeってなんぞや?</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/%e3%83%98%e3%83%ab%e3%83%97" class="uri" title="Go to wiki page">ヘルプ</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/Emacs%20%e3%82%92%e4%bd%bf%e3%81%84%e3%81%9f%e3%81%84" title="Go to wiki page">Emacs を使いたい</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/%e3%80%90%e3%81%a1%e3%82%87%e3%81%a3%e3%81%a8%e3%81%b2%e3%81%a8%e3%82%84%e3%81%99%e3%81%bf%e3%80%91%e3%80%8c%e9%9d%9e%e6%ad%a3%e6%a0%bc%e3%80%8d%e3%81%a3%e3%81%a6%ef%bc%9f" class="uri" title="Go to wiki page">【ちょっとひとやすみ】「非正格」って？</a></li>
</ul>
<p><a href="https://wiki.haskell.jp/Old/sampou.org/%e3%81%af%e3%81%84%e3%81%af%e3%81%84" class="uri" title="Go to wiki page">はいはい</a></p>
<ul>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/Hello,%20World!%20%e3%83%97%e3%83%ad%e3%82%b0%e3%83%a9%e3%83%a0" title="Go to wiki page">Hello, World! プログラム</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/%e5%ae%9f%e8%a1%8c%e3%83%95%e3%82%a1%e3%82%a4%e3%83%ab%e3%81%ab%e3%81%97%e3%81%a6%e3%81%bf%e3%82%88%e3%81%86" class="uri" title="Go to wiki page">実行ファイルにしてみよう</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/runhugs" class="uri" title="Go to wiki page">runhugs</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/%e3%82%84%e3%81%af%e3%82%8a%e3%83%96%e3%83%a9%e3%83%83%e3%82%af%e3%83%9c%e3%83%83%e3%82%af%e3%82%b9%e3%81%aa%e3%81%ae%e3%81%8b%ef%bc%9f" class="uri" title="Go to wiki page">やはりブラックボックスなのか？</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/%e3%81%95%e3%82%89%e3%81%ab%20echo.lhs%20%e3%81%a8%e3%81%8b%e3%81%ad" title="Go to wiki page">さらに echo.lhs とかね</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/do%20%e3%81%97%e3%81%be%e3%81%97%e3%82%87" title="Go to wiki page">do しましょ</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/%e3%81%82%e3%81%a3%e3%81%a1%e3%82%83%e3%81%ae%e4%b8%96%e7%95%8c%e3%81%ae%e5%bc%95%e6%95%b0%e3%81%a8%e3%81%93%e3%81%a3%e3%81%a1%e3%82%83%e3%81%ae%e4%b8%96%e7%95%8c%e3%81%ae%e5%bc%95%e6%95%b0" class="uri" title="Go to wiki page">あっちゃの世界の引数とこっちゃの世界の引数</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/%e3%83%a2%e3%83%8a%e3%83%89%e3%82%92%e9%81%a0%e7%9b%ae%e3%81%ab%e8%a6%8b%e3%82%8b" class="uri" title="Go to wiki page">モナドを遠目に見る</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/cat.lhs%20%e3%81%a8%e3%81%8b%e3%82%82%e3%81%bf%e3%81%a8%e3%81%8f" title="Go to wiki page">cat.lhs とかもみとく</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/%e3%80%90%e3%81%a1%e3%82%87%e3%81%a3%e3%81%a8%e3%81%b2%e3%81%a8%e3%82%84%e3%81%99%e3%81%bf%e3%80%91%e3%83%94%e3%83%a5%e3%82%a2%e3%81%aa%e6%80%a0%e3%81%91%e8%80%85" class="uri" title="Go to wiki page">【ちょっとひとやすみ】ピュアな怠け者</a></li>
</ul>
<p><a href="https://wiki.haskell.jp/Old/sampou.org/%e3%81%a4%e3%81%8b%e3%81%be%e3%82%8a%e7%ab%8b%e3%81%a1" class="uri" title="Go to wiki page">つかまり立ち</a></p>
<ul>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/%e3%83%aa%e3%82%b9%e3%83%88%e3%82%82%e3%83%a2%e3%83%8a%e3%83%89%ef%bc%9f" class="uri" title="Go to wiki page">リストもモナド？</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/main%20%e3%81%af%e9%96%a2%e6%95%b0%e3%81%98%e3%82%83%e3%81%ad%e3%83%bc%e3%81%ae%e3%81%8b%ef%bc%9f" title="Go to wiki page">main は関数じゃねーのか？</a></li>
<li><a title="Go to wiki page">IO a の a と [a] の a</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/thunk%20%e3%81%af%e3%81%a9%e3%81%86%e6%9b%b8%e3%81%8f%e3%81%ae%e3%81%8b%ef%bc%9f" title="Go to wiki page">thunk はどう書くのか？</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/%e5%9e%8b%e5%ae%a3%e8%a8%80%e3%82%92%e3%81%bf%e3%81%a6%e3%81%bf%e3%82%88%e3%83%bc%ef%bc%81" class="uri" title="Go to wiki page">型宣言をみてみよー！</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/%e5%9e%8b%e6%8e%a8%e8%ab%96%e3%82%88%e3%82%8a%e5%8e%b3%e3%81%97%e3%81%84%e5%9e%8b%e5%ae%a3%e8%a8%80%e3%81%ae%e5%bf%85%e8%a6%81%e6%80%a7" class="uri" title="Go to wiki page">型推論より厳しい型宣言の必要性</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/%e3%81%9f%e3%82%89%e3%81%84%e3%81%be%e3%82%8f%e3%81%97%e9%96%a2%e6%95%b0" class="uri" title="Go to wiki page">たらいまわし関数</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/%e7%b6%9a%e3%81%9f%e3%82%89%e3%81%84%e3%81%be%e3%82%8f%e3%81%97" class="uri" title="Go to wiki page">続たらいまわし</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/%e3%83%87%e3%83%90%e3%83%83%e3%82%b0%e3%81%ae%e6%89%8b%e6%ae%b5%e3%82%92%e7%9f%a5%e3%82%8d%e3%81%86" class="uri" title="Go to wiki page">デバッグの手段を知ろう</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/%e3%80%90%e3%81%a1%e3%82%87%e3%81%a3%e3%81%a8%e3%81%b2%e3%81%a8%e3%82%84%e3%81%99%e3%81%bf%e3%80%91%e3%83%a1%e3%82%a4%e3%83%93%e3%83%bc%ef%bc%9f" class="uri" title="Go to wiki page">【ちょっとひとやすみ】メイビー？</a></li>
</ul>
<p><a href="https://wiki.haskell.jp/Old/sampou.org/%e3%82%88%e3%81%a1%e3%82%88%e3%81%a1%e6%ad%a9%e3%81%8d" class="uri" title="Go to wiki page">よちよち歩き</a></p>
<ul>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/%e8%87%aa%e5%88%86%e3%81%a7%e5%9e%8b%e3%82%92" class="uri" title="Go to wiki page">自分で型を</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/%e3%82%8b%e3%80%81%e3%82%8b%e3%82%8b%e3%80%81%e9%a1%9e(kind)%e3%81%a3%e3%81%a6%ef%bc%9f" class="uri" title="Go to wiki page">る、るる、類(kind)って？</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/MyEq%e3%82%af%e3%83%a9%e3%82%b9%e3%81%a3%e3%81%a6%e3%83%a4%e3%83%84" class="uri" title="Go to wiki page">MyEqクラスってヤツ</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/%e5%90%8c%e3%81%98%e3%81%a8%e3%81%af%ef%bc%9f" class="uri" title="Go to wiki page">同じとは？</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/%e3%81%be%e3%81%a0%e4%b8%8d%e5%8b%95%e7%82%b9%e3%81%af%e3%83%a0%e3%83%aa" class="uri" title="Go to wiki page">まだ不動点はムリ</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/%e3%81%82%e3%82%84%e3%81%97%e3%81%84%e9%9b%86%e4%bc%9a" class="uri" title="Go to wiki page">あやしい集会</a></li>
</ul>
<p><a href="https://wiki.haskell.jp/Old/sampou.org/%e3%81%a6%e3%81%8f%e3%81%a6%e3%81%8f" class="uri" title="Go to wiki page">てくてく</a></p>
<ul>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/=%20%e3%81%a8%20%3c-%20%e3%81%a8" title="Go to wiki page">= と &lt;- と</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/%e3%81%95%e3%82%89%e3%81%ab%3c-%e3%81%a8%3e%3e=%e3%81%ae%e9%96%a2%e4%bf%82%e3%81%8c%e5%88%86%e3%81%a3%e3%81%a6%e3%81%97%e3%81%be%e3%81%88%e3%81%b0%e5%a4%a9%e4%b8%8b%e3%81%8b?" class="uri" title="Go to wiki page">さらに&lt;-と&gt;&gt;=の関係が分ってしまえば天下か?</a></li>
<li><a href="https://wiki.haskell.jp/Old/sampou.org/getContents%e3%81%ae%e3%83%90%e3%83%a4%e3%82%a4" class="uri" title="Go to wiki page">getContentsのバヤイ</a></li>
<li><p><a href="https://wiki.haskell.jp/Old/sampou.org/%e3%81%95%e3%82%89%e3%81%ab%e3%81%95%e3%82%89%e3%81%ab%3c-%e3%81%a3%e3%81%a6%e3%81%ae%e3%81%af%e3%81%93%e3%81%93%e3%81%ab%e3%82%82%e7%99%bb%e5%a0%b4?" class="uri" title="Go to wiki page">さらにさらに&lt;-ってのはここにも登場?</a></p></li>
<li><p><a href="https://wiki.haskell.jp/Old/sampou.org/%e3%81%99%e3%81%8d%e3%81%a3%e3%81%b7" class="uri" title="Go to wiki page">すきっぷ</a></p></li>
<li><p><a href="https://wiki.haskell.jp/Old/sampou.org/%e3%83%80%e3%83%b3%e3%82%b9%e3%83%80%e3%83%b3%e3%82%b9%e3%83%80%e3%83%b3%e3%82%b9" class="uri" title="Go to wiki page">ダンスダンスダンス</a></p></li>
</ul>
<hr>
<h2 id="寝がえり">寝がえり</h2>
<p>(<a href="http://www.sampou.org/cgi-bin/haskell.cgi?p=Programming:WayToHaskeller:%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD&amp;c=e&amp;l=jp">「ねがえり」を編集する</a>)|(<a href="http://www.sampou.org/cgi-bin/haskell.cgi?Programming:WayToHaskeller&amp;l=jp">Haskellerへの道</a>)</p>
<h3 id="勉強よりまず処理系のインストール">勉強よりまず処理系のインストール</h3>
<p>まずはHaskellをインストールしてみる訳だけど、面倒なのはいきなりくじけ る。私のモットーはまずは動かしてみる。だ。(今決めた) もう何年も前から PC-UNIXの世界ではサードパーティー製のソフトをワンタッチでインストール できる仕組みがあったりする。 Linux だと rpm か? FreeBSD なら ports collection、 NetBSD だと package など。まぁ、NetBSDなんかだとバージョ ンが古かったりする可能性もあるが、気にしない。（そりゃ単に私がちゃんと 最新化管理してないからか?）</p>
<p>私の生活環境は NetBSD1.6.2 なので package から make してインストールしてみる。</p>
<p>インストール作業そのものが好きな人には何の刺激もないが、まずバカチョン でインストールできるHaskell処理系にはどんなんがあるんかいな?</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="563523227b253337163c3f383f">[email&nbsp;protected]</a>&gt; pwd
/usr/pkgsrc
<a href="email-protection.html" class="__cf_email__" data-cfemail="b2d1c7c69fc1d7d3f2d8dbdcdb">[email&nbsp;protected]</a>&gt; ./pkglocate Haskell
(snip)
lang/ghc/DESCR:GHC: The Glasgow Haskell Compiler.
lang/ghc/DESCR:The Glasgow Haskell Compiler is a robust, fully-featured, optimising
lang/ghc/DESCR:compiler for the functional programming language Haskell 98

(snip)

lang/hugs/DESCR:The Nottingham and Yale Haskell interpreter and programming environment.
lang/hugs/DESCR:   a Haskell interpreter and programming environment for developing
lang/hugs/DESCR:   cool Haskell programs.  Sources and binaries are freely available

(snip)

lang/nhc98/DESCR:nhc98 is a fully-fledged compiler for Haskell 98, the standard lazy
lang/nhc98/DESCR:compiler for an earlier version of the language. Written in Haskell,
lang/nhc98/DESCR:With hmake, a replacement for the other makes used in Haskell</code></pre>
<p>どうやら <a href="https://www.haskell.org/hugs">Hugs</a>、 <a href="https://www.haskell.org/ghc/">GHC</a>、<a href="https://www.haskell.org/nhc98/">nhc98</a> ってのがそうらしいので、全部入れちゃう。ここはHaskellの話題じゃないの でインストールの詳細は書かない。とにかくすでにインストールしてくれた先 人のおかげで失敗することなんてないでしょ。</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="224157560f51474362484b4c4b">[email&nbsp;protected]</a>&gt; which nhc98
/usr/pkg/bin/nhc98
<a href="email-protection.html" class="__cf_email__" data-cfemail="e88b9d9cc59b8d89a882818681">[email&nbsp;protected]</a>&gt; which ghc
/usr/pkg/bin/ghc
<a href="email-protection.html" class="__cf_email__" data-cfemail="016274752c726460416b686f68">[email&nbsp;protected]</a>&gt; which ghci
/usr/pkg/bin/ghci
<a href="email-protection.html" class="__cf_email__" data-cfemail="b8dbcdcc95cbddd9f8d2d1d6d1">[email&nbsp;protected]</a>&gt; which hugs
/usr/pkg/bin/hugs</code></pre>
<p>はい。処理系が手に入りましたね。</p>
<h3 id="どれにしようかな">ど・れ・に・し・よ・う・か・な</h3>
<p>とりあえず、石橋を叩かず渡る派の私はこれらのコマンドをまんま呼び出して みる。まぁいざとなれば外から kill すりゃいいじゃないの。</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="214254550c524440614b484f48">[email&nbsp;protected]</a>&gt; ghc
ghc-5.04.3: no input files
Usage: For basic information, try the `--help' option.</code></pre>
<p>ありゃ、だめだ。</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="c2a1b7b6efb1a7a382a8abacab">[email&nbsp;protected]</a>&gt; nhc98
nhc98: error: no source, object or archive file specified</code></pre>
<p>お前もかブルータス。</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="fe9d8b8ad38d9b9fbe94979097">[email&nbsp;protected]</a>&gt; ghci
   ___         ___ _
  / _ ? /?  /?/ __(_)
 / /_?// /_/ / /  | |      GHC Interactive, version 5.04.3, for Haskell 98.
/ /_??/ __  / /___| |      http://www.haskell.org/ghc/
?____/?/ /_/?____/|_|      Type :? for help.

Loading package base ... linking ... done.
Loading package haskell98 ... linking ... done.
Prelude&gt; ^D Leaving GHCi.</code></pre>
<p>お、いけそう。</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="b5d6c0c198c6d0d4f5dfdcdbdc">[email&nbsp;protected]</a>&gt; hugs
__   __ __  __  ____   ___      _________________________________________
||   || ||  || ||  || ||__      Hugs 98: Based on the Haskell 98 standard
||___|| ||__|| ||__||  __||     Copyright (c) 1994-2001
||---||         ___||           World Wide Web: http://haskell.org/hugs
||   ||                         Report bugs to: <a href="email-protection.html" class="__cf_email__" data-cfemail="99f1ecfeeab4fbecfeead9f1f8eaf2fcf5f5b7f6ebfe">[email&nbsp;protected]</a>
||   || Version: December 2001  _________________________________________

Haskell 98 mode: Restart with command line option -98 to enable extensions

Reading file "/usr/pkg/share/hugs/lib/Prelude.hs":
                   
Hugs session for:
/usr/pkg/share/hugs/lib/Prelude.hs
Type :? for help
Prelude&gt; ^D [Leaving Hugs]</code></pre>
<p>ほほー、こいつが hugs ね。</p>
<p>実は ghc と nhc98 てのはコンパイラらしい。オンラインマニュアルの最初に compilerって出てたりもするんで多分そうだろう。今のところ、あまり細かい ことは気にしない。 一方 ghci と hugs ってのが何やらプロンプトが現れたので interactive に遊べそう。</p>
<p>最初はプロンプトからちまちま入力してみるのがいい。すぐに反応も見れて楽 しめた方が勉強する気にもなるってもんだ。とりあえずプロンプトが出て来た 奴で進めることにしましょう。</p>
<p>hugs ってのが軽くてよさそうってのをどっかで読んだような気がするんで hugs で GO!</p>
<h3 id="preludeってなんぞや">Preludeってなんぞや?</h3>
<p>インタプリタのプロンプトって</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="7f1c0a0b520c1a1e3f15161116">[email&nbsp;protected]</a>&gt; gosh
gosh&gt; ^D
<a href="email-protection.html" class="__cf_email__" data-cfemail="0e6d7b7a237d6b6f4e64676067">[email&nbsp;protected]</a>&gt; stk
Welcome to the STk interpreter version 4.0.1 [NetBSD-1.6.2-i386]
Copyright 1993-1999 Erick Gallesio - I3S - CNRS / ESSI &lt;<a href="email-protection.html" class="__cf_email__" data-cfemail="83e6e4c3f6edeae0e6ade5f1">[email&nbsp;protected]</a>&gt;
STk&gt; ^D Bye.</code></pre>
<p>みたいに「俺は gosh だぜ！」とか「我輩は STk なり！」って主張するか、 もしくは全く主張なく“&gt;”みたいに印字するものと思ってた。なぜか Haskell は “ghci&gt;” とか “hugs&gt;” とかってんじゃなく、“Prelude&gt;” ってのがプロン プトになってる。Prelude とは何ぞや? と気になるもの。辞書引くと前奏曲と か序幕とかなんだけど、芝居がかった名前ですぞ。</p>
<h3 id="ヘルプ">ヘルプ</h3>
<p>この WiKi の HowTo:List<a href="Programming_WayToHaskeller.html" class="uri" title="Go to wiki page">?</a> とか HowTo:Maybe<a href="Programming_WayToHaskeller.html" class="uri" title="Go to wiki page">?</a> とか見ると入力事例が あるんで、真似してみましょう。ただ、ところどころプロンプトがなぜか List&gt; とかって変わってるのが気になる。</p>
<p>どうも事例の雰囲気をじーーーーっっと見ているとプロンプトのところに出て いるのはモジュールの様なものかな〜そんな感触である。 (念のため断ってお くが現時点で本当に私は入門者なので正しいかどうか不明だから信用しないよ うに)</p>
<p>まずは起動メッセージのところに :? ってしたらヘルプが見れる様なことが書 いてあったので、メッセージを確認して、色々試してみよう。</p>
<pre><code>Prelude&gt; :?
LIST OF COMMANDS:  Any command may be abbreviated to :c where
c is the first character in the full name.

:load &lt;filenames&gt;   load modules from specified files
:load               clear all files except prelude
:also &lt;filenames&gt;   read additional modules
:reload             repeat last load command
:project &lt;filename&gt; use project file
:edit &lt;filename&gt;    edit file
:edit               edit last module
:module &lt;module&gt;    set module for evaluating expressions
&lt;expr&gt;              evaluate expression
:type &lt;expr&gt;        print type of expression

:?                  display this list of commands
:set &lt;options&gt;      set command line options
:set                help on command line options
:names [pat]        list names currently in scope
:info &lt;names&gt;       describe named objects
:browse &lt;modules&gt;   browse names defined in &lt;modules&gt;
:find &lt;name&gt;        edit module containing definition of name
:!command           shell escape

:cd dir             change directory
:gc                 force garbage collection
:version            print Hugs version
:quit               exit Hugs interpreter
Prelude&gt; [Leaving Hugs]</code></pre>
<p>おお？なんか scheme48 を思い出してしまった。えっと、勘が正しければこう かな？えいっ！</p>
<pre><code>Prelude&gt; :module List
ERROR - Cannot find module "List"</code></pre>
<p>あらハズレだ。エラーが出るところを見ると Prelude ってのがモジュール名かと思ってたのはハズレかもしれん。ならば！！と言うことで</p>
<pre><code>Prelude&gt; :load List
Reading file "/usr/pkg/share/hugs/lib/List.hs":
Reading file "/usr/pkg/share/hugs/lib/Maybe.hs":
Reading file "/usr/pkg/share/hugs/lib/List.hs":
                   
Hugs session for:
/usr/pkg/share/hugs/lib/Prelude.hs
/usr/pkg/share/hugs/lib/Maybe.hs
/usr/pkg/share/hugs/lib/List.hs
List&gt;          &lt;= コレ！！</code></pre>
<p>おおっ、なんかイけたみたいだよ。じゃあ、調子に乗って Maybe にも。</p>
<pre><code>List&gt; :load Maybe
Reading file "/usr/pkg/share/hugs/lib/Maybe.hs":
                   
Hugs session for:

/usr/pkg/share/hugs/lib/Prelude.hs
/usr/pkg/share/hugs/lib/Maybe.hs
Maybe&gt; [Leaving Hugs]</code></pre>
<p>ぱちぱちぱち。って、まだ何の式も打ち込んでないぞ。いいのか?</p>
<p>で、これって分かると思うけどファイルの path ですよね。じゃぁ現物見ましょ う。なんせインストールをバカチョンでやったんで、どこに何のファイルが入っ たかなんて押えてないしね。</p>
<pre><code>-----------------------------------------------------------------------------
-- Standard Library: List operations
--
-- Suitable for use with Hugs 98
-----------------------------------------------------------------------------

module List (
    elemIndex, elemIndices,
    find, findIndex, findIndices,
    nub, nubBy, delete, deleteBy, (??), deleteFirstsBy,
    union, unionBy, intersect, intersectBy,
    intersperse, transpose, partition, group, groupBy,
    inits, tails, isPrefixOf, isSuffixOf,</code></pre>
<p>List.hs の中身です。しっかと module List の文字が光って見えますね。光っ て見えませんか？てなわけで、やーっぱモジュールじゃん。しかもいっぱい haskell のコードがあるんで、いずれ勉強に役立つやもしれず。</p>
<p>それで、もう一度ようく、 :load の結果を見てみると、 :load List の結果 として、どうやら Prelude.hs/Maybe.hs/List.hs の三つが出現している。</p>
<p>そこでロードした後に、もしかしたらモジュールを飛び回れるかも？とか思い 試してみる。</p>
<pre><code>Prelude&gt; :load List
Reading file "/usr/pkg/share/hugs/lib/List.hs":
Reading file "/usr/pkg/share/hugs/lib/Maybe.hs":
Reading file "/usr/pkg/share/hugs/lib/List.hs":
                   
Hugs session for:
/usr/pkg/share/hugs/lib/Prelude.hs

/usr/pkg/share/hugs/lib/Maybe.hs
/usr/pkg/share/hugs/lib/List.hs
List&gt; :module List
List&gt; :module Maybe
Maybe&gt; :module Prelude
Prelude&gt; :module List
List&gt; :module Maybe
Maybe&gt; :module Prelude
Prelude&gt; [Leaving Hugs]</code></pre>
<p>ぱちぱちぱちぱち。でも原理はよく分からないね。ただ、List ってモジュー ルが Maybe ってモジュールを必要とするらしく、芋づる的にロードされるら しいってのは分かる。 :module ってのは Gauche とかで言うところの select-module みたいなもんかなぁ。</p>
<p>ちなみに ghci だと、</p>
<p>Prelude&gt; :module List Prelude List&gt; :module Maybe Prelude Maybe&gt; :module List Maybe Prelude Maybe List&gt; Leaving GHCi.</p>
<p>こんな風にプロンプトに複数の module をロードしてやることでプロンプトに も複数のものが表示されますね。意味は知らんが、直観的にはなんとなく分か るような気がしますよね？この辺もその内分かるようになるでしょう。多分。</p>
<h3 id="emacs-を使いたい">Emacs を使いたい</h3>
<p>さらに調子に乗って関数なんぞを定義してみよう。 まずはなんてったって、クイックソートでしょう。 Haskell の入門だと大抵 出ているので、試してみましょう。</p>
<pre><code>quicksort  []           =  []
quicksort (x:xs)        =  quicksort [y | y &lt;- xs, y&lt;x ]
                        ++ [x]
                        ++ quicksort [y | y &lt;- xs, y&gt;=x]</code></pre>
<p>こんなコードだね。んじゃレッツトライ！</p>
<pre><code>Prelude&gt; quicksort [] = []
ERROR - Syntax error in input (unexpected `=')</code></pre>
<p>ありゃりゃ？もしかしてデータ型の定義が先にいるのかしらん。</p>
<pre><code>Prelude&gt; quicksort :: [a]-&gt;[a]
ERROR - Undefined variable "quicksort"
Prelude&gt; </code></pre>
<p>むむむ、だめだぞコレ。なんだろう？？？</p>
<p>というちょっとわざとらしいフリをしてしまったけど、実際最初は結構迷った りします。私の場合にも結局教えてもらったんですよね。 実はプロンプトから直接定義したりできないんだってさ。これってちょっと、 いや、かなり不便かも。対話的にイロイロできないってのはコーディングから デバッグまでのサイクルがひょいひょい回らないんで、個人的にはひどく嫌な わけだ。</p>
<p>実は hugs から :e を使うと環境変数 EDITOR で設定されたエディタが立ち上 がる。こいつを使ってみよう。使えればまぁなんとかなるかも知れない。</p>
<p>その前に、 lhs っていう拡張子のファイルについて簡単に説明しちゃいます。 hugs のオンラインマニュアルを見ると literate scripts と紹介してある。 これは基本的に haskell 処理系に対しては、全部コメント扱いになるファイ ルなのだが、行頭から &gt; という風に</p>
<p>リダイレクト記号と空白から始まる行だけはコードと認識されるんだって。 例えば、こんな感じに書くんだとさ。</p>
<pre><code>begin tag ...

&gt; quicksort  []           =  []
&gt; quicksort (x:xs)        =  quicksort [y | y &lt;- xs, y&lt;x ]
&gt;                         ++ [x]
&gt;                         ++ quicksort [y | y &lt;- xs, y&gt;=x]

end tag ...</code></pre>
<p>使い道としては コメント扱いにするエリアに HTML のタグや WiKi のタグ、 TeX のタグなんぞを書いておけば、そのまま test.lhs を文書などに貼り付け ることが出来ちゃうのだ。(わー便利ー) もちろん普通に test.hs なプログラムを書いておいてもいいんだけどさ。</p>
<p>じゃぁ早速、少しプログラムにバグを仕込んでおいて、試してみましょう。</p>
<pre><code>Prelude&gt; :load test.lhs
Reading file "test.lhs":
Parsing
ERROR "test.lhs":3 - Program line next to comment</code></pre>
<p>うむ、では正しいコードに修正してみる。</p>
<pre><code>Prelude&gt; :e test.lhs
Reading file "test.lhs":
                   
Hugs session for:
/usr/pkg/share/hugs/lib/Prelude.hs
test.lhs</code></pre>
<p>エディタで修正後、保存して抜けるとこんな感じになるので、ちょいと quicksort を実行してみましょう。</p>
<pre><code>Main&gt; quicksort [2,9,1,0,3,6,2,7,6,4,8,9]
[0,1,2,2,3,4,6,6,7,8,9,9]
Main&gt; </code></pre>
<p>わーい。ぱちぱちぱち。素晴らしい！</p>
<p>ちなみによーく見るとプロンプトが Main になっておりますね。これがどうも user のためのモジュールっつうか評価環境なんだろうか。そんな雰囲気。</p>
<p>さてと。。。</p>
<p>それでも scheme + emacs でコードを書いていた私としては、どうもイマイチ 感は拭えない。 なんせエディタとプロンプトを行ったり来たりしないといけないしさ。</p>
<p>もちろん、NetBSD の package から make した hugs だと readline が生きて いるらしく、hugs のプロンプトからちゃんと行編集も可能だったりするんだ けど、やっぱりねぇ。。。 というわけで emacs で画面を分割して使えないんかな？というと、実は使え ます。ハイ。</p>
<p>まずは準備としてここに emacs のための haskell modeってのがあるんで、 emacs 使いの方は引っ張って来るよろし。でもってインストールしましょう。 これも別に難しくないので installation-guide を見て使えるようにしてくだ さい。</p>
<p>そしたら配布物に入っている .emacs を自分の .emacs にコピぺしましょう。 もしあなたが、hugs じゃなくて ghci を使っているなら</p>
<pre><code>;(add-hook 'haskell-mode-hook 'turn-on-haskell-simple-indent)
;(add-hook 'haskell-mode-hook 'turn-on-haskell-hugs)
(add-hook 'haskell-mode-hook 'turn-on-haskell-ghci)</code></pre>
<p>こんな風に最後の方を修正してください。 hugs を ghci に変えた行を追加し て haskell-mode-hook ってのに add-hook します。 hugs の方はコメントア ウトしちゃっていいです。 もち、 hugs を使っている人はそのまま使えちゃいます。</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="2447515009574145644e4d4a4d">[email&nbsp;protected]</a>&gt; emacs test.lhs &amp;</code></pre>
<p>って emacs を立ち上げたらコードを開いているバッファ上で C-c C-l って打 ち込んでみればいいんだって、ワクワク。 (コントロールキーを押しながら c(シー)とl(エル)です)</p>
<pre><code>Hugs session for:
/usr/pkg/share/hugs/lib/Prelude.hs
Type :? for help
Prelude&gt; :load /home/cut-sea/script/haskell/test.lhs

Reading file "/home/cut-sea/script/haskell/test.lhs":
Parsing........................................................................
Dependency analysis............................................................
Type checking..................................................................
Compiling......................................................................

Hugs session for:
/usr/pkg/share/hugs/lib/Prelude.hs
/home/cut-sea/script/haskell/test.lhs
Main&gt; </code></pre>
<p>どうでしょうか？画面分割されて、こんな風に Main プロンプトが出なかった でしょうか？ここまでくればかなり便利になりますね？ emacs の編集機能を 駆使しつつ、適当に C-c C-l ってやれば良いんです。だいぶ便利じゃぁあり ませんか？</p>
<p>ちなみにghciの方を有効にして同様に試すと、</p>
<pre><code>Prelude&gt; :load /home/cut-sea/script/haskell/test.lhs
Compiling Main             ( /home/cut-sea/script/haskell/test.lhs, interpreted )


/home/cut-sea/script/haskell/test.lhs:2:
    Warning: No 'main' defined in module Main
Ok, modules loaded: Main.
*Main&gt;</code></pre>
<p>あり？ main が無いって叱られます。 でも、 quicksort を実行するとちゃんと評価可能ですんで、あまり気にしな いで良いのかも知れません。まぁ warning だしね。メッセージからする とHaskellってCみたく main がいるのやも知れんな。 ともあれ便利な開発環境が手に入ったところで、そろそろ腰を据えて取り掛か ろうかしらん。</p>
<h3 id="ちょっとひとやすみ非正格って">【ちょっとひとやすみ】「非正格」って？</h3>
<blockquote>
<p>Haskell は非正格純粋関数型言語っていう冠がついてたりする。いーじゃない ですか。なんかこう難しそうで。会社で「非正格純粋関数型言語Haskellって のがあってさ〜」なんて話そうもんならなんか恰好よさげじゃないですか。え え。もしかしたら女の子の瞳がハートマークになるかも知れませんよ。</p>
<p>ところが、「非正格」って何さ？って聞かれて「いや、まあそのなんだ」とか なんとかしどろもどろになると途端に株が下がるかもしれない。</p>
<p>どうも正格関数ってのは</p>
<pre><code>f _|_  = _|_</code></pre>
<p>ってなる様なfって関数で、そうじゃないものを非正格って言うんだとさ。ちなみに _|_ は本当は一文字の記号でボトムとか読むらしい。</p>
<p>上司：「おいおい、良くわかんねぇよ。 いきなり_|_とかワケわかんない記号出して誤魔化そうとするな。 おまえは大体そういう・・・」</p>
<p>はい、そうですね。ごもっともでございます。</p>
<pre><code>_|_ は未定義値</code></pre>
<p>です。つまりこんな感じですね。</p>
<pre><code>妻：「ねぇ、あなた！いつもいつも仕事仕事って、私と仕事とどっちが大切なの！？」
夫：「そんなん決められっかよ！比較できるもんじゃねーだろ！！」</code></pre>
<p>コレですコレ！ドラマにありがちなシチュエーションだけどさ。妻は " 私 &gt; 仕事 " っていう式を夫に評価させようとするわけだけど、夫はそんな式は評価できねぇよ！って評価できません値を返すよね？ あと、水割りならぬトリカブト割り “1/0” なんてのを飲ませると 死んじゃったり。これも無限大の値を返せないんで _|_ になる。いや、無限大を意味するものを返してもいいけどさ。話が続かないから返せないことにしてよ。</p>
<pre><code>上司：「おい、田中君いつもの仕事、あれやっといてよ。
　　　　必要な資料はコレとコイツでいいんだよな。」
田中：「はい、分かりました」</code></pre>
<p>ってな会話の後、田中君はいつもの仕事って関数に渡されたデータを適用する んですね。</p>
<pre><code>itumono_sigoto kore koitu
       =&gt; kekka</code></pre>
<p>翌日も同じ様なやり取りが繰り返されます。</p>
<pre><code>上司：「おい、田中君いつもの仕事、あれやっといてよ。
　　　　必要な書類はコレとコイツでいいんだよな。
　　　　あっ、あとん〜とコレコレ！
　　　　必要になるかどうかわかんねぇけど一応渡しとくわ、
　　　　あとよろしく。」
田中：「はい、分かりました（おいおい必要かどうかわかんねぇものってなんだよ）」</code></pre>
<p>そう、実は今田中君が渡されたコレコレってのは「会社と家庭どっち取るんだ よ！？」とか、“トリカブト割り”みたいに田中君がもし扱ってしまったら大変 なことになっちゃうアレです。</p>
<p>まさに</p>
<pre><code>itumono_sigoto kore koitu korekore</code></pre>
<p>ってのは</p>
<pre><code>itumono_sigoto kore koitu _|_</code></pre>
<p>な訳ですね。</p>
<p>これに対して正格な田中くんは仕事するまえに、渡されたデータを必要かどう か判断するべく最初に評価するんだけど、コレコレを見た瞬間に「そんなん決 められっかよ！」とか死んじゃったりとかしちゃいます。</p>
<pre><code>itumono_sigoto kore koitu _|_
       =&gt; _|_　（これがそういう状態なわけです）</code></pre>
<p>それに対して非正格な田中君であれば、必ずしもそうなるとは限りません。も ちろん「必要になるかどうか分からないけど」って渡されたコレコレってやつ が本当に必要になってしまって、田中君が見てしまうと結果は同じなんだけど、 もし結果的に必要なければ、田中君はちゃんと_|_以外の値を返せるんですよ ね。</p>
<p>それがつまり、</p>
<pre><code>正格関数ってのは
f _|_  = _|_
ってなる様なfって関数で、そうじゃないものを非正格関数という。</code></pre>
<p>これなんですね。ちなみに正格ってのは strict つまり厳格なとかって意味だ けど、まぁ真面目なやつが変に不必要な情報に頭悩ませてしまって、それが元 で仕事を放り出す結果になってしまい、そうじゃないnon-strict（非正格）な やつはなぜか問題なく仕事をしちゃうことがままあるのは因果なもんですね。</p>
<p>さらには文脈によっては“非正格な”評価ってのを “怠惰な”評価とかって言わ れることがあるんですが、怠惰なヤツの方が仕事をしちゃう可能性があるって のも・・・。（冗談ですってば）</p>
<p>(<a href="http://www.sampou.org/cgi-bin/haskell.cgi?p=Programming:WayToHaskeller:%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD&amp;c=e&amp;l=jp">「ねがえり」を編集する</a>)|(<a href="http://www.sampou.org/cgi-bin/haskell.cgi?Programming:WayToHaskeller&amp;l=jp">Haskellerへの道</a>)</p>
</blockquote>
<hr>
<h2 id="はいはい">はいはい</h2>
<p>(<a href="http://www.sampou.org/cgi-bin/haskell.cgi?p=Programming:WayToHaskeller:%EF%BF%BD%CF%A4%EF%BF%BD%EF%BF%BD%CF%A4%EF%BF%BD&amp;c=e&amp;l=jp">「はいはい」を編集する</a>)|(<a href="http://www.sampou.org/cgi-bin/haskell.cgi?Programming:WayToHaskeller&amp;l=jp">Haskellerへの道</a>)</p>
<h3 id="hello-world-プログラム">Hello, World! プログラム</h3>
<p>さぁ寝返りもうてるようになった（どういう基準だよ？）ところで、地べたは いずっちゃいましょう！ やっぱりプログラミングを始める場合には、どんな言語でも Hello, World で しょう。 LL Weekend 2004 では<a href="http://www014.upp.so-net.ne.jp/tetryl/llw2004/ll-samurai.txt">LL侍にブラックボックスと称された</a> Haskell の Hello, World です。ちょっと緊張しますね。あんな人達の集まる場でブラッ クボックスって言われる様なシロモノを私なんかが書けるわけねーんじゃねー かって？！でも今の世の中便利なもので、google で検索するとありました。 <a href="http://pub.cozmixng.org/~the-rwiki/rw-cgi.rb?cmd=view;name=Haskell">このサイト</a> 面白そうなんで、しばらくは参照させてもらってお勉強を進めましょう。</p>
<pre><code>&gt; main = putStrLn "Hello, World!"</code></pre>
<p>これ結構簡単じゃねぇすか？これを emacs 上で評価してやると、</p>
<pre><code>Main&gt; main
Hello, World!</code></pre>
<p>こんな感じで挨拶してくれましたよ。どもこんちわ。m(__)m</p>
<pre><code>&gt; main = putStrLn "Hello, ほげさん!"</code></pre>
<p>と書き換えて評価してやると、日本語も大丈夫！ すごいすごい。</p>
<p>ふと、これに型を記述しておいてやろうと思ったんだが、よう分からん。こう いう時はわざとエラーを発生させてやるのが正しいやり方です。嘘ですよ、も ちろん。(^^;</p>
<pre><code>Main&gt; main 123
ERROR - Type error in application
*** Expression     : main 123
*** Term           : main
*** Type           : IO ()
*** Does not match : a -&gt; b</code></pre>
<p>あえて不必要な引数 123 を渡してやると Type error ってエラーが出ました。 その下に Type ってとこに IO () って出てますね。 フツーは逆で型の指定っ てチェックのためにするんだろうけど、初心者の内はこういうナサケナイ使い 方もアリでしょ。じゃぁ Haskell の教えてくれた型を書いてみましょう。</p>
<pre><code>&gt; main :: IO ()
&gt; main = putStrLn "Hello, ほげさん!"</code></pre>
<p>んで、C-c C-l してから評価してやると、</p>
<pre><code>Main&gt; main
Hello, ほげさん!</code></pre>
<p>わーい、ぱちぱちぱち！</p>
<h3 id="実行ファイルにしてみよう">実行ファイルにしてみよう</h3>
<p>・・・で？(^^;; ここでさぁ、やっぱり emacs 上だけじゃなくて実行ファイルにしたいじゃん？ やってみましょう。・・・さて、どうやるんだろ？</p>
<pre><code>#! /usr/pkg/bin/hugs

&gt; main :: IO ()
&gt; main = putStrLn "Hello, ほげさん!"</code></pre>
<p>こんな感じに hello.lhs で保存してみて、パーミッションを実行可能にしてみた。</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="bcdfc9c891cfd9ddfcd6d5d2d5">[email&nbsp;protected]</a>&gt; ./hello.lhs 
__   __ __  __  ____   ___      _________________________________________
||   || ||  || ||  || ||__      Hugs 98: Based on the Haskell 98 standard
||___|| ||__|| ||__||  __||     Copyright (c) 1994-2001
||---||         ___||           World Wide Web: http://haskell.org/hugs
||   ||                         Report bugs to: <a href="email-protection.html" class="__cf_email__" data-cfemail="5b332e3c2876392e3c281b333a28303e37377534293c">[email&nbsp;protected]</a>
||   || Version: December 2001  _________________________________________

Haskell 98 mode: Restart with command line option -98 to enable extensions

Reading file "/usr/pkg/share/hugs/lib/Prelude.hs":
Reading file "./hello.lhs":
                   
Hugs session for:
/usr/pkg/share/hugs/lib/Prelude.hs
./hello.lhs
Type :? for help
Main&gt;</code></pre>
<p>あらら・・・。一応 Main&gt; にプロンプトが変わってはいるんだけど、だめか。っつーか、hugs ん中に入っちゃってるじゃん。(T^T) もしかしたら hello.hs ファイルにせにゃならんかな？</p>
<pre><code>#! /usr/pkg/bin/hugs

main :: IO ()
main = putStrLn "Hello, ほげさん!"</code></pre>
<p>今度は lhs じゃないので、各行頭の &gt; を外してます。・・・が、無駄な努力 でした。結果は同じ。</p>
<p>すごすごと man hugs ってしてみたけど、何かそれっぽ いのもないぞ。困ったな。とりあえず、先頭の #! 行を取り除いて ghc でコ ンパイルしてみることにしようか。</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="6b081e1f46180e0a2b01020502">[email&nbsp;protected]</a>&gt; ghc hello.hs
<a href="email-protection.html" class="__cf_email__" data-cfemail="523127267f21373312383b3c3b">[email&nbsp;protected]</a>&gt; ll
total 370
drwxr-xr-x  2 cut-sea  users     512 Sep 18 22:36 .
drwxr-xr-x  4 cut-sea  users     512 Aug  5 21:05 ..
-rw-r--r--  1 cut-sea  users     287 Sep 18 22:36 Main.hi       &lt;= コレ
-rwxr-xr-x  1 cut-sea  users  353908 Sep 18 22:36 a.out         &lt;= コレ
-rwxr-xr-x  1 cut-sea  users      50 Sep 18 22:36 hello.hs
-rwxr-xr-x  1 cut-sea  users      79 Sep 18 22:16 hello.lhs
-rw-r--r--  1 cut-sea  users      31 Sep 18 21:43 hello.lhs~
-rw-r--r--  1 cut-sea  users    1956 Sep 18 22:36 hello.o       &lt;= コレ
-rw-r--r--  1 cut-sea  users     364 Aug 31 21:42 test.lhs
-rw-r--r--  1 cut-sea  users     203 Aug 31 21:08 test.lhs~
<a href="email-protection.html" class="__cf_email__" data-cfemail="204355540d534541604a494e49">[email&nbsp;protected]</a>&gt; file *
Main.hi:    raw G3 data, byte-padded
a.out:      ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), for NetBSD, dynamically linked (uses shared libs), not stripped
hello.hs:   ISO-8859 text
hello.lhs:  a /usr/pkg/bin/hugs script text executable
hello.lhs~: ASCII text, with no line terminators
hello.o:    ELF 32-bit LSB relocatable, Intel 80386, version 1 (SYSV), not stripped
test.lhs:   ASCII text
test.lhs~:  ASCII text</code></pre>
<p>おおっ！出来てる出来てる。 file でチェックすると executable な ELF バイナリが！</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="7a190f0e57091f1b3a10131413">[email&nbsp;protected]</a>&gt; ./a.out 
Hello, ほげさん!</code></pre>
<p>わーい！ちゃんと走りましたよ〜(T^T)感無量。</p>
<p>でもさぁ、やっぱりスクリプトで動かしてみたくないっすか？あと、Main.hi ってのもよー分からんファイルだし。なんだこりゃ？謎がいっぱいあるけど、 あんまり細かいこたぁ気にしなぁい気にしなぁい。</p>
<p>しばらくコンパイルするんじゃなくて、ソースのまんま実行する方法ないか探 してみましょう。 google よ！教えておくれっ！！</p>
<h3 id="runhugs">runhugs</h3>
<p>さんざん色々試して探しまくった挙げ句にようやく出会ったのが、これでした。 この中にちゃんと書いてありまんがな。もう感涙！何十年も会ってなかった肉 親に会ったかのような感動モノの出会いです。</p>
<p>説明するよかコードを書く方がめんどくさくないので書いちゃいます。</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="f4978180d9879195b49e9d9a9d">[email&nbsp;protected]</a>&gt; cat hello.lhs
#! /usr/pkg/bin/runhugs

&gt; main :: IO ()
&gt; main = putStrLn "Hello, ほげさん!"</code></pre>
<p>literate 形式のプログラムにしておいて、hugs じゃなくて runhugsを呼び出 してやるんだってさ。っつーわけで、えいやっ！</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="573422237a243236173d3e393e">[email&nbsp;protected]</a>&gt; ./hello.lhs 
Hello, ほげさん!</code></pre>
<p>動いてくれましたよ〜。あぁむせび泣き。</p>
<h3 id="やはりブラックボックスなのか">やはりブラックボックスなのか？</h3>
<p>ではじっくり hello.lhs を読んでみましょうか？たった２行で何がじっくり じゃぁっっ！！ってツッコまれそうですけど、いいんです。何事も最初が肝心 です。でもヤバそうになったら無理せずに裸足で逃げ出します。コレ肝心！挫 折するより、経験値積み上げてから出直しってやつです。（伏線だったり）</p>
<pre><code>#! /usr/pkg/bin/runhugs

&gt; main :: IO ()
&gt; main = putStrLn "Hello, ほげさん!"</code></pre>
<p>lhs 形式になっていることで、#!行がHaskellには無視されるわけですね。 hs 形式じゃないのは、まさにこのためですね。</p>
<ol type="1">
<li>さぁshellから実行されたぞ〜</li>
<li>最初に#!があるじゃん！</li>
<li>何々？/usr/pkg/bin/runhugsを呼べってか？</li>
<li>/usr/pkg/bin/runhugs召喚！</li>
<li>へいへ〜い！呼ばれて飛び出てじゃじゃじゃじゃーん！（by runhugs）</li>
<li>何々？コメントコメント・・・（最初の２行を読み飛ばし）</li>
<li>おっと、“&gt;”があった！！この行は本体だねぇ</li>
<li>んじゃまぁ、評価すっか</li>
</ol>
<p>とりあえず、こんな具合でしょうか。でもさ、これって不思議じゃないですか？ Schemeで言えば(define main …)があるだけですよ？ (main)とかって関数呼 び出ししないで走りはったがな、このシト(^^;ナシテ？</p>
<p>（注）Schemeでもmain関数を定義してあるだけで、最初にmainがcallされる仕 組みがある。でもこれってやっぱ特例だよね？</p>
<blockquote>
<p>nobsun(2004/09/22 10:38:27 JST): う〜ん。そんなことないと思うけど。コ ンパイラを持つ言語なら普通、エントリポイントになる関数の名前は仕様で決 まっているよね。main とは限らないかもしれないけど。</p>
<p>Haskell では、プログラム(算譜)は、定義が書いてあるだけだよね。で、 Haskell のプログラムの実行は、式を評価することだったよね。インタープリ タ内部に居るときには、評価する式を指定することが普通だけど、インタープ リタ外部に居るときには、評価する式を決めておいた方が便利でしょ。それが main というわけ。</p>
</blockquote>
<p>実は上のコード書いてたときにも</p>
<pre><code>#! /usr/pkg/bin/runhugs

&gt; main :: IO ()
&gt; main = putStrLn "Hello, ほげさん!"
&gt; main              &lt;= コレは間違いっす</code></pre>
<p>なんて書いてて、きっちりエラーを喰らってたんで、気づいちゃいたんだけど 知らんプリして、ここまで延ばしてました。 LL Weekend でも Haskeller な 方が「Haskellの場合はmainから始まります」って何度かコード解説してた様 に思います。しかも先程神の声が main がエントリポイントになるんだよ っ て囁いてたんで間違いありません。</p>
<p>じゃぁ次にHaskellに教えてもらって追加した行です。</p>
<pre><code>&gt; main :: IO ()</code></pre>
<p>・・・すんません。早速わかりません。降参デス。なんで main 関数のデータ 型が IO なの？しかも IO のバックに変なシトが取り憑いてます。ナニこれ？ nil(?.?)</p>
<p>IO () ってどんなデータ型？</p>
<blockquote>
<p>nobsun(2004/09/22 10:24:21 JST): ものすごく、はしょって言うと、main は プログラム外部へ出力するアクションだからです。外部へ出力するアクション は IO () 型です。</p>
</blockquote>
<p>お？神の声が聞こえてきました。そういうことらしいです。 この部分はなんとなくボスキャラが潜んでそうなので、そういうものって事で 素通りすることにして、次いきましょう次。</p>
<pre><code>&gt; main = putStrLn "Hello, ほげさん!"</code></pre>
<p>これはなんとなくわかる気がする。 put string line の略でしょうね。この 部分は調べてる最中に他で出会ったパターンでは</p>
<pre><code>&gt; main = putStr "Hello, ほげさん!\n"</code></pre>
<p>こんなんもアリらしいです。 put string の略と思われます。これも分かりま すよね。動作的には明示的に改行を入れるかどうかの違いでしょうか。最初の 印象としては関数名としては PutStrLn とか PutStr の方が良くないか？と思っ たりしますが、 <a href="http://www.sampou.org/haskell/tutorial-j/goodies.html">やさしいHaskell入門</a> とかを見ると以下の様な文面に出会います。</p>
<blockquote>
<p>[読者のみなさんは気づいたでしょうか、特定の型を表わす識別子は大文字で はじまっています。たとえば、Integer や Char です。また、 inc のような 値を表わす識別子は小文字ではじまっています。これは単なる習慣ではありま せん。Haskell の構文規則でそうすることになっているのです。また、先頭の 文字だけではなく、そのほかの文字も、大文字か小文字かということは重要で、 foo と fOo と fOO はすべて違う識別子として区別されます。]</p>
</blockquote>
<p>だそうです。まぁ関数もファーストクラスデータオブジェクトなわけで、それ を束縛しただけの識別子である putStrLnやputStrも小文字スタートって訳な んでしょうね。</p>
<p>では、ほんのちょびっとだけ遊んでみましょう。</p>
<pre><code>&gt; main = putStr ("Hello," ++ " ほげさん!\n")</code></pre>
<p>結果としてはまるで変わりませんけどね。 ++ ってのはとりあえずは文字列を 連結してくれる中置演算子と思っておきます。はい。そんなことより重要なの はカッコです。これが無いと型が違うって叱られます。</p>
<blockquote>
<p>nobsun(2004/09/23 00:54:22 JST): 括弧なしで、</p>
<p>&gt; main = putStr “Hello,” ++ " ほげさん!\n"</p>
<p>と書くと何故、叱られるかというと。関数適用の結合力は、二項演算子 ++ の 結合力より強いので、上は</p>
<p>&gt; main = (putStr “Hello,”) ++ " ほげさん!\n"</p>
<p>と解釈されてしまいます。(putStr “Hello,”) の型は IO () で、" ほげさん! \n" の型は String です。これは、++ の型 [a] -&gt; [a] -&gt; [a] というのに矛 盾します。で、エラー。</p>
<p>Haskellの型推論のシステムが、上のように型を推論してくれて、プログラマ の意図と実際に書かれたプログラムとの齟齬を教えてくれます。こんなのが実 行時エラーだったらやだよねぇ。型推論マンセー！</p>
<p>WiLiKi:Shiro (2004/09/23 11:24:53 JST): でもでも、最初の関数の型が [Char] -&gt; [Char] だったら、エラーは出ないよね。プログラマの意図を完全 に表現しきるのは無理なんだから、結局程度問題ってことにならない? (いや、 型推論があるのはうらやましいんだけどさ。) 議論になりそうなら別ページに 行きましょう。</p>
<ul>
<li>続きは <a href="Type.html" class="uri" title="Go to wiki page">Type</a> にてやりましょう (2004/09/24 15:53:18 JST)</li>
</ul>
</blockquote>
<pre><code>&gt; main = putStr ((("Hello," ++ " ほげさん!\n")))</code></pre>
<p>無いとまずいんだけど、余分にある分には一向に構わないみたいで、こんな風 にカッコ連発しても大丈夫です。なんかＣの式みたい。</p>
<p>ちょっと興味が出てきたので ++ に寄り道してみましょう。 ++ は中置演算子 なんだけど、敢えて前置演算ぽく使うことも出来ちゃいます。</p>
<pre><code>&gt; main = putStr ((++) "Hello," " ほげさん!")</code></pre>
<p>こんな風に(++)ってカッコで囲ってやるだけですが、やっぱりputStrに対して は引数全体をカッコでくるんでやる必要がある。カッコを外す方法は無いんか いなと思うのだが、こんな風にすると出来るらしい。</p>
<pre><code>&gt; main = putStr $ (++) "Hello," " ほげさん!"</code></pre>
<p>この $ってやつを使うとカッコを省略できるみたいだ。正直に白状すると、コ レも LL Weekend 行った時に仕入れたネタだったりする。いや、セッションじゃ ないんだけどね。(^^)v さらに調子に乗ってこうやってみる。</p>
<pre><code>&gt; main = putStr $ (++) "ども〜, " $ (++) "どもども," " ほげさん!"</code></pre>
<p>これは</p>
<pre><code>&gt; main = putStr ((++) "ども〜, " ((++) "どもども," " ほげさん!"))</code></pre>
<p>これと同じことのようだ。</p>
<blockquote>
<p>nobsun(2004/09/23 01:09:27 JST): $ は ++ より結合力が弱いから</p>
<pre><code>&gt; main = putStr $ "ども〜, " ++ "どもども," ++ " ほげさん!"</code></pre>
<p>でも、おっけぇよん。</p>
</blockquote>
<p>これ見てようやくGauche の部分適用の関数名の末尾に $ がついている意味が 分かったりとかね。</p>
<blockquote>
<p>ソウダッタンダァー</p>
</blockquote>
<h3 id="さらに-echo.lhs-とかね">さらに echo.lhs とかね</h3>
<pre><code>#! /usr/pkg/bin/runhugs

&gt; --
&gt; -- simple echo command in Haskell
&gt; --
&gt;
&gt; module Main where
&gt; import System
&gt; main = do args &lt;- getArgs
&gt;           mapM_ (putStrLn) args</code></pre>
<p>続いて echo.lhs も読んでみましょう。これも このサイト から拝借しちゃい ます。</p>
<p>まず実行してみましょーかね。レッツエバル！ emacs 上で走らせると、いや、 走ってないんだけど・・・</p>
<pre><code>Main&gt; main

Main&gt; main 1 2 3
ERROR - Type error in application
*** Expression     : main 1 2 3
*** Term           : main
*** Type           : IO ()
*** Does not match : a -&gt; b -&gt; c -&gt; d

Main&gt; main "1 2 3"
ERROR - Type error in application
*** Expression     : main "1 2 3"
*** Term           : main
*** Type           : IO ()
*** Does not match : a -&gt; b

Main&gt; </code></pre>
<p>あでででで。ダメですね。最初なんも引数与えてないのですが、そうするとな んも言わないんですよね。 引数を 1 2 3 って与えてやると、エラーが出ましたね。 Does not match : a -&gt; b -&gt; c -&gt; d ってあるのは引数 1 2 3 って適用する形で呼び出したから型 がちゃうよって叱ってるんだよね。 これは 1適用 -&gt; 2適用 -&gt; 3適用 -&gt; mainの返値である何か てな間違った呼 び出しになってるよ〜って主張されておられる。ふむ。</p>
<p>で、浅知恵なんだけど、 main “1 2 3” って引数を一個のものにしてみたんだ けど、 Does not match : a -&gt; b ってやっぱり間違ってるよって叱られます ね。多分やっぱり IO () ってのが分からないとダメなような気がします。い ずれにせよ、mainの引数は無いような気がします。だって -&gt; が型に無いもん ねぇ。</p>
<p>考えててもしょうがないからコマンドラインから実行してみましょう。</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="d7b4a2a3faa4b2b697bdbeb9be">[email&nbsp;protected]</a>&gt; ./echo.lhs
<a href="email-protection.html" class="__cf_email__" data-cfemail="1f7c6a6b326c7a7e5f75767176">[email&nbsp;protected]</a>&gt; ./echo.lhs 1 2 3
1
2
3
<a href="email-protection.html" class="__cf_email__" data-cfemail="5d3e2829702e383c1d37343334">[email&nbsp;protected]</a>&gt; ./echo.lhs はろ〜 もーにんぐ 娘。
はろ〜
もーにんぐ
娘。
<a href="email-protection.html" class="__cf_email__" data-cfemail="aac9dfde87d9cfcbeac0c3c4c3">[email&nbsp;protected]</a>&gt; </code></pre>
<p>こんな風に引数で与えたモノ(文字列臭い気がするけど、まだ不明)が一行ずつ 印字されますね。ふーん。じゃあ、これをふまえて！コードの方を読んでみま しょうか。</p>
<p>まず最初の “&gt;” で始まる行の内先頭三行はコメントだそうです。 Haskellの コメントは – で始まる所から行末尾までがコメントになります。あと、ブロッ ク的にコメントを入れる手段もあるそうです。今まであんまり言語仕様書って 見たくなかったんだけど、この辺りから参照させてもらった方がよさげかな〜。 と。いや、Lisp?を初めて勉強する時に、いきなりCLtL2ってマクラみたいな本 を手に取ったことがあって心的外傷にね、ちょっとね。うん。 <a href="http://www.sampou.org/haskell/report-j/lexemes.html#sect2.3">この辺</a>を参照するとネストしたコメントは {- から -} までよんって書いて ます。「おいおい、literate 形式だったら “&gt;” で始まってない行はどうせ コメント扱いだろうが〜」ってツッコミありそうですが、丁重に無視。</p>
<pre><code>&gt; module Main where</code></pre>
<p>あ、なんかモジュールだ。・・・ぢぐぢょうぅぅ！！(T^T) <a href="http://www.sampou.org/haskell/report-revised-j/modules.html">またこれ</a> かよ。しかも案の定理解できねぇ。なんとなく名前空間を分ける、正確には制 御するか？そういうモンらしいのは分かったけどさ。とりあえず、Gaucheに もあるモジュールと同じようなもんと思ってみるか。・・・ってオレGauche のモジュールシステム使いこなしてねーじゃんっ！切腹！！</p>
<p>しかもこの辺で道草食ってたら</p>
<pre><code>(^^)             :: (Fractional a, Integral b) =&gt; a -&gt; b -&gt; a           negative exponent allowed</code></pre>
<p>なんてのを見つけて「やるじゃんHaskell（なにがやねん）」とかボソッとつ ぶやいてみたり。こんなんが、 $ や ++ や !! なんかに混じってコードに入っ てたら、なぜスマイルマーク？？って幻惑されることうけあい！なかなかイカ ス（死語）じゃん。</p>
<p>おっと、いかんいかん。モジュールだった。こういう時は必殺技</p>
<p>コードにエラー仕込んで処理系を怒らせてヒントをもらおう作戦です。</p>
<p>先の一行を削ってHaskellの怒りっぷリを静かに拝見させていただきましょう。</p>
<pre><code>#! /usr/pkg/bin/runhugs

&gt; --
&gt; -- simple echo command in Haskell
&gt; --
&gt;
 module Main where
&gt; import System
&gt; main = do args &lt;- getArgs
&gt;           mapM_ (putStrLn) args</code></pre>
<p>コメントアウトして（うわ、簡単だわこりゃ）、んで、まずはロード！！</p>
<pre><code>Main&gt; :load /home/cut-sea/script/haskell/echo.lhs
Reading file "/home/cut-sea/script/haskell/echo.lhs":
Parsing.................
ERROR "/home/cut-sea/script/haskell/echo.lhs":7 - Program line next to comment
Prelude&gt;</code></pre>
<p>ありゃ？なんで？ Program line next to comment ってどういう意味だ？コメントの次にプログラム行が来てる？確かにそうなってますよ。 あれ、もしかして7行目ってコメントアウトした行自身か。ってことはもしかして “&gt;” 行って途切れたらダメなの？</p>
<p>じゃあ今度はこうしてみよう。</p>
<pre><code>#! /usr/pkg/bin/runhugs

&gt; --
&gt; -- simple echo command in Haskell
&gt; --
&gt;

&gt; import System
&gt; main = do args &lt;- getArgs
&gt;           mapM_ (putStrLn) args</code></pre>
<p>・・・うーん。予想が外れました。ちゃんとロードできるねぇ。なんでだろ。 で、色々試したんだけどようやく分かりました！はい。さっきの誤訳してま した。すまねぇだ。 Program line next to comment はコメントの隣、つま り隣接する行にプログラム行があるって仰っているんですね。 module Main where の前後に空行を入れたり入れなかったりしてようやく判明しました。</p>
<pre><code>#! /usr/pkg/bin/runhugs

&gt; --
&gt; -- simple echo command in Haskell
&gt; --
&gt;

 module Main where

&gt; import System
&gt; main = do args &lt;- getArgs
&gt;           mapM_ (putStrLn) args</code></pre>
<p>これでおっけーです！ドン！</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="325147461f41575372585b5c5b">[email&nbsp;protected]</a>&gt; ./echo.lhs 1 2 3
1
2
3</code></pre>
<p>わーい！！ぱちぱちぱち・・・・って違うっ。そうじゃなくて、 module Main where が何してるか調べてたんじゃん。無くても良いって事だよ？ いや、実は予想してたんだけどさ、マジ要らないみたいね。多分単に Main モ ジュール内で定義するよって言っているだけなんでしょう。無きゃないでい いんでしょう。したらば！</p>
<blockquote>
<p>モジュールヘッダ部(moduleで始まる行)が無い場合、`module Main(main) &gt; where’があるものとして処理されます (<a href="http://www.sampou.org/haskell/report-revised-j/modules.html#sect5.1">ここ参照</a>)</p>
</blockquote>
<pre><code>#! /usr/pkg/bin/runhugs

&gt; --
&gt; -- simple echo command in Haskell
&gt; --
&gt;
&gt; module Foo where
&gt; import System
&gt; main = do args &lt;- getArgs
&gt;           mapM_ (putStrLn) args</code></pre>
<p>って Main を Foo モジュールにしてみよう。</p>
<pre><code>Foo&gt; main

Foo&gt; </code></pre>
<p>ちゃんと emacs 上ではロードできるし何か走りそう・・・って思ったら。</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="204355540d534541604a494e49">[email&nbsp;protected]</a>&gt; ./echo.lhs 1 2 3
runhugs: compileExpr: invalid module</code></pre>
<p>おーいっっ。無効なモジュールだって叱られちゃいますね。 main ってのがエ ントリポイントとして働くのは Main モジュールだけらしい。ちなみに Main を Prelude にしてやると、</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="1b786e6f36687e7a5b71727572">[email&nbsp;protected]</a>&gt; ./echo.lhs 1 2 3
runhugs: Error occurred
Reading file "./echo.lhs":
Parsing

ERROR "./echo.lhs" - Module "Prelude" already loaded</code></pre>
<p>すでに Prelude モジュールはロードされとるって叱られます。これはなんと なく分かる気がしたんだけどさ〜。さらに Main を List にしても</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="88ebfdfca5fbede9c8e2e1e6e1">[email&nbsp;protected]</a>&gt; ./echo.lhs 1 2 3
runhugs: Error occurred
Reading file "./echo.lhs":
Parsing
ERROR "./echo.lhs" - Module "List" already loaded</code></pre>
<p>ナゼ？？とりあえず Main じゃなきゃマトモに動作してくれないのは分かった けどエラーメッセージに謎が残っちゃいましたね。ボーゼン。</p>
<p>えっと、Main じゃなきゃダメだってことだけ押えといて、次の行にいきましょうか。</p>
<pre><code>&gt; import System</code></pre>
<p>ハイ！これは System モジュールをインポートしてるんだね。多分以降のコー ドで System モジュールで定義された関数を使ってるんでしょう。おおよその アタリをつけて :find で見てみましょう。えーっとー、 :find getArgs か な？・・・ビンゴ！</p>
<p>先生！すんません！割り込みますけど気になったんでちょっと試させてくださ い。 :find getArgs ってしたら getProgName ってのが見えるんですよね。こ れ試させてください。</p>
<pre><code>#! /usr/pkg/bin/runhugs

&gt; module Main where
&gt; import System
&gt; main = do args &lt;- getProgName       &lt;= ここを変えた
&gt;           mapM_ (putStrLn) args</code></pre>
<p>でロードしてみると・・・</p>
<pre><code>Dependency analysis............................................................
Type checking
ERROR "/home/cut-sea/script/haskell/echo.lhs":9 - Type error in application
*** Expression     : mapM_ putStrLn args
*** Term           : putStrLn
*** Type           : String -&gt; IO ()
*** Does not match : Char -&gt; IO ()

System&gt; </code></pre>
<p>んーと、何か型が違うって叱られるな。再度 :find getProgName すると</p>
<pre><code>getArgs                     :: IO [String]
getArgs                      = do argc &lt;- primArgc
                                  mapM primArgv [1..argc-1]

getProgName                 :: IO String
getProgName                  = primArgv 0</code></pre>
<p>仲良く並んでこうなってます。なんとなくだけど getArgs は引数を複数取れ るんで IO [String] になってるんだろう。一方 getProgName は get Program Name の略だろうからプログラム名は一個しかない。だから IO String になっ てます。ってところじゃないかしらん。</p>
<p>類推すると、 IO () は IO を通して何の受渡しもしないってことじゃなかろーか？</p>
<p>とりあえず、 型が違うって言われてるんでさらにイジイジしてみます。</p>
<pre><code>#! /usr/pkg/bin/runhugs

&gt; module Main where
&gt; import System
&gt; main = do args &lt;- getProgName
&gt;           putStrLn args        &lt;= さらにここも変えた。

Main&gt; main
Hugs</code></pre>
<p>よし！さらにコマンドラインから実行！</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="d2b1a7a6ffa1b7b392b8bbbcbb">[email&nbsp;protected]</a>&gt; ./prog.lhs
./prog.lhs</code></pre>
<p>あ！・・・一瞬びっくりしたけど、そっか。そうだね。でも結構嬉しいぞ。初 めて自分で書いた気がするし。何の役にも立たんけどね。(^^;</p>
<p>じゃあちょっとした満足感が得られたところで元の echo.lhs のコード読み込 みを続行しましょう。</p>
<h3 id="do-しましょ">do しましょ</h3>
<pre><code>&gt; main = do args &lt;- getArgs
&gt;           mapM_ (putStrLn) args</code></pre>
<p>はい、この部分ですね。実は emacs でコードをいじっていると気付くんだけ ど、どのシンボルでもって訳ではないんだけど、word の上にカーソルを持っ ていくとミニバッファのところに型を表示してくれます。実に親切ですね。す ばらしい。</p>
<p>じゃあ色々カーソルを移動させて調べてみましょう。すると getArgs が IO [String] であることや putStrLn が String-&gt;IO () であることが判ります。 じゃあ mapM_ にカーソルを持っていくと・・・</p>
<pre><code>Monad m =&gt; (a -&gt; m b) -&gt; [a] -&gt; m ()</code></pre>
<p>って感じにボスキャラが姿を見せますのでこっちは無視しましょう。多分マッ プ関数の一種だと思うんだよね。動作からして。あとは、args が何の型も持っ てない(？)のが気になりますね。なんとなく getArgs の返値と同じ型になる んでねーか？と思うんですけど。さらに難解なのが do だったりします。</p>
<pre><code>do { stmts [;] } stmts -&gt; exp [; stmts] | pat &lt;- exp ; stmts | let decllist ; stmts</code></pre>
<p>って書いてますね。どうも<a href="http://www.sampou.org/haskell/report-revised-j/lexemes.html">このあたり</a>を先に見ておいた方がよさそうな感触 です。あくまでさらっとね、さらっと。あまり真剣になると挫折しちゃいそう なんで。</p>
<p>で、一行だと分かりにくいので結局助けを求めて、<a href="http://www.sampou.org/haskell/report-revised-j/exps.html#sect3.14">ここ</a>を見ると</p>
<pre><code>exp     -&gt;      do { stmts }    (do expression)
stmts   -&gt;      stmt1 ... stmtn exp [;]         (n&gt;=0)
stmt    -&gt;      exp ;
        |       pat &lt;- exp ;
        |       let decls ;
        |       ;       (empty statement)</code></pre>
<p>BNFとかとは違うけど、知ってると勘が働くな。</p>
<p>この場合には stmt(statement)がつらつら書かれてて、その内の最初の stmt が pat &lt;- exp なんだな。もちろん pat が args になってて、 exp 式が getArgs で。その次の stmt が mapM_ (putStrLn) argsになってると。 pat &lt;- exp は exp を評価した返値を pat に束縛してるみたい。しかも stmts の 定義をみると stmt はいくつ書いたって良いということだ。</p>
<pre><code>#! /usr/pkg/bin/runhugs

&gt; --
&gt; -- simple echo command in Haskell
&gt; --
&gt;
&gt; module Main where
&gt; import System
&gt; main = do args &lt;- getArgs
&gt;           mapM_ (putStrLn) args
&gt;           mapM_ (putStr) args</code></pre>
<p>じゃあお言葉に甘えて、早速。</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="3d5e4849104e585c7d57545354">[email&nbsp;protected]</a>&gt; ./echo.lhs 1 2 3
1
2
3
<a href="email-protection.html" class="__cf_email__" data-cfemail="711204055c021410311b181f18">[email&nbsp;protected]</a>&gt; ./echo.lhs はろ〜 もーにんぐ 娘。
はろ〜
もーにんぐ
娘。
はろ〜もーにんぐ娘。<a href="email-protection.html" class="__cf_email__" data-cfemail="d3b0a6a7fea0b6b293b9babdba">[email&nbsp;protected]</a>&gt; </code></pre>
<p>やったね。</p>
<p>余談だけど、新たに行を追加する時に、わざわざ &gt; … って書かなくてもい きなり tab キーを押すと勝手に &gt; を追加してインデントしてくれます。 面白いのは、そのインデントです。今回のケースでは３種類のインデントを順 にやってくれます。おそらく レイアウト ってやつに連動しているんじゃねー かなーと思います。</p>
<p>最初のインデントに任せると、</p>
<pre><code>&gt; module Main where
&gt; import System
&gt; main = do args &lt;- getArgs
&gt;           mapM_ (putStrLn) args
&gt;         mapM_ (putStr) args</code></pre>
<p>こうなってしまい、ロードすると</p>
<pre><code>System&gt; :load /home/cut-sea/script/haskell/echo.lhs
Reading file "/home/cut-sea/script/haskell/echo.lhs":
Parsing........................................................................
Reading file "/usr/pkg/share/hugs/lib/System.hs":
Parsing........................................................................
Dependency analysis............................................................
Type checking..................................................................
Compiling......................................................................
Reading file "/home/cut-sea/script/haskell/echo.lhs":
Parsing..................................................
ERROR "/home/cut-sea/script/haskell/echo.lhs":11 - Syntax error in input (unexpected symbol "mapM_")
System&gt; </code></pre>
<p>コマンドラインから実行すると</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="f6958382db859397b69c9f989f">[email&nbsp;protected]</a>&gt; ./echo.lhs はろ〜 もーにんぐ 娘。
runhugs: Error occurred
Reading file "./echo.lhs":
Reading file "/usr/pkg/share/hugs/lib/System.hs":
Reading file "./echo.lhs":
Parsing
ERROR "./echo.lhs":11 - Syntax error in input (unexpected symbol "mapM_")</code></pre>
<p>って構文エラー発生しちゃいます。二番目のインデントに任せると</p>
<pre><code>&gt; module Main where
&gt; import System
&gt; main = do args &lt;- getArgs
&gt;           mapM_ (putStrLn) args
&gt;    mapM_ (putStr) args</code></pre>
<p>こうなって、ロードもコマンドラインからの実行も同じ結果です。最後のイン デントだと、</p>
<pre><code>&gt; module Main where
&gt; import System
&gt; main = do args &lt;- getArgs
&gt;           mapM_ (putStrLn) args
&gt; mapM_ (putStr) args</code></pre>
<p>こうなって、ロード時とコマンドラインから実行した場合のエラーはってーと、</p>
<pre><code>ERROR "/home/cut-sea/script/haskell/echo.lhs":13 - Syntax error in declaration (unexpected `}', possibly due to bad layout)

<a href="email-protection.html" class="__cf_email__" data-cfemail="92f1e7e6bfe1f7f3d2f8fbfcfb">[email&nbsp;protected]</a>&gt; ./echo.lhs はろ〜 もーにんぐ 娘。
runhugs: Error occurred
Reading file "./echo.lhs":
Reading file "/usr/pkg/share/hugs/lib/System.hs":
Reading file "./echo.lhs":
ERROR "./echo.lhs":13 - Syntax error in declaration (unexpected `}', possibly due to bad layout)</code></pre>
<p>こうなります。ってワケで結局自分でインデントしました(-,-#) エラーメッセージをちゃんと読んで、 <a href="http://www.sampou.org/haskell/report-revised-j/lexemes.html#sect2.7">レイアウト</a>をちょいと眺めれば、そこ はかとなく漂う雰囲気で「はは〜ん」って外人風にうなずいている自分がいる ことでしょう。</p>
<p>じゃあ、ここまで来たら多少工夫した Hello, World! を作ってみましょう。</p>
<pre><code>#! /usr/pkg/bin/runhugs

&gt; module Main where
&gt; import System
&gt; main :: IO ()
&gt; main = do arg &lt;- getArgs
&gt;           putStr (head arg)
&gt;           putStrLn "さん、こんちわ！！"</code></pre>
<p>一応 main のデータ型もつけました。</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="96f5e3e2bbe5f3f7d6fcfff8ff">[email&nbsp;protected]</a>&gt; ./hello2.lhs ほげ 
ほげさん、こんちわ！！
<a href="email-protection.html" class="__cf_email__" data-cfemail="f4978180d9879195b49e9d9a9d">[email&nbsp;protected]</a>&gt; ./hello2.lhs ほげ ふが
ほげさん、こんちわ！！</code></pre>
<p>こんな感じです。ん〜っん、ん、ん(^-^)いいですねぇ。 なんかいっぱしにHaskellでコード書けてる気分になって来ましたぞ。</p>
<p>さらに調子に乗っちゃいましょう。</p>
<pre><code>&gt; module Main where
&gt; import System
&gt; main :: IO ()
&gt; main = do [arg:rest] &lt;- getArgs
&gt;           putStr arg
&gt;           putStrLn "さん、こんちわ！！"</code></pre>
<p>なんとなく、 pat がパターンになるならこういうのも出来るんじゃねーか？ と思ったんです。つまり、 String の配列だから最初の String にマッチすん じゃない？ってゆーわけですね。 getArgs の返値が [“arg1”,“arg2”, …] という風になりますからね。これって結局 [x:xs]ってのでマッチさせたら x に最初の引数が渡されるだろうと。そういうこってす。・・・が、前置きが長 い割に失敗しました、コレ。</p>
<pre><code>Dependency analysis............................................................
Type checking
ERROR "/home/cut-sea/script/haskell/hello2.lhs":7 - Type error in application
*** Expression     : putStr arg
*** Term           : arg
*** Type           : Char
*** Does not match : [Char]</code></pre>
<p>調子に乗りすぎると鼻っパシラをメキっていわされました。はひ。多分なんかを勘違いしてるんでしょう。</p>
<blockquote>
<p>[arg:rest] :: [String] == Char<a href="Programming_WayToHaskeller.html" class="uri" title="Go to wiki page">?</a> arg:rest :: [Char] arg :: Char, rest :: [Char] になってしまいます。 それを putStr に渡すと…</p>
<p>Haskell とよく似た Clean なんかではリストを [1:2:[]] などと書くようですが。– Y. Hanatani</p>
</blockquote>
<p>なるほど、そうか。神のお告げによると、型も単純に置き換えを考えればいい と。ってことは・・・こうか。</p>
<pre><code>#! /usr/pkg/bin/runhugs

&gt; module Main where
&gt; import System
&gt; main :: IO ()
&gt; main = do arg:rest &lt;- getArgs
&gt;           putStr arg
&gt;           putStrLn "さん、こんちわ！！"</code></pre>
<p>これで思惑通り動作！しかし、このパターンが書けるってのは、強力だのう。</p>
<p>てなわけで do を使ったら、なんかブロック構造みたいのが使えるっちゅうこ とで、ちゃんちゃん。</p>
<h3 id="あっちゃの世界の引数とこっちゃの世界の引数">あっちゃの世界の引数とこっちゃの世界の引数</h3>
<p>今まで考えたことなかったんだけど Haskell触っているうちに気になってきた んで、ちょっと実験してみましょう。Ｃ言語で少し書いてみます。</p>
<pre><code>#include &lt;stdio.h&gt;

int main ()
{
  static cycle = 1;
  printf("Hello,world! %d \n", cycle);
  cycle += 1;
  main();
}</code></pre>
<p>そう、実は main を再帰的に呼び出したこと無かったです。まずは第一段階と してコレが出来るか確認してみます。</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="472432336a342226072d2e292e">[email&nbsp;protected]</a>&gt; cc test.c -o test
<a href="email-protection.html" class="__cf_email__" data-cfemail="2f4c5a5b025c4a4e6f45464146">[email&nbsp;protected]</a>&gt; ./test
Hello,world! 1 
Hello,world! 2 
Hello,world! 3 
Hello,world! 4 
Hello,world! 5 
Hello,world! 6 
Hello,world! 7 
Hello,world! 8 
Hello,world! 9 
Hello,world! 10 
^D</code></pre>
<p>おおっ、行けますな。うん。まあアセンブラレベルで考えりゃmainラベルへジャ ンプするだけだから行けるだろ。じゃー本題だ。</p>
<pre><code>#include &lt;stdio.h&gt;

int main (int argc)
{
  printf("Hello,world! %d \n", argc);
  main(argc+1);
}</code></pre>
<p>さあ、これはどうだ？なんせ再帰呼び出しがオモロイことになっとるぞ！？</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="731006075e00161233191a1d1a">[email&nbsp;protected]</a>&gt; cc test2.c -o test2

<a href="email-protection.html" class="__cf_email__" data-cfemail="563523227b253337163c3f383f">[email&nbsp;protected]</a>&gt; ./test2
Hello,world! 1 
Hello,world! 2 
Hello,world! 3 
Hello,world! 4 
Hello,world! 5 
Hello,world! 6 
Hello,world! 7 
Hello,world! 8 
Hello,world! 9 
Hello,world! 10 
^D
<a href="email-protection.html" class="__cf_email__" data-cfemail="b2d1c7c69fc1d7d3f2d8dbdcdb">[email&nbsp;protected]</a>&gt; ./test2 1 2 3 4 5
Hello,world! 6 
Hello,world! 7 
Hello,world! 8 
Hello,world! 9 
Hello,world! 10 
Hello,world! 11 
Hello,world! 12 
Hello,world! 13 
^D
<a href="email-protection.html" class="__cf_email__" data-cfemail="97f4e2e3bae4f2f6d7fdfef9fe">[email&nbsp;protected]</a>&gt; ./test2 foo bar moo dar goo
Hello,world! 6 
Hello,world! 7 
Hello,world! 8 
Hello,world! 9 
Hello,world! 10 
Hello,world! 11 
Hello,world! 12 
Hello,world! 13 
^D</code></pre>
<p>まぁ予想した通りに動いてくれたじゃないの。でも、やっぱし奇妙っちゃ奇妙だよ〜。 そのココロは？って聞いたらＣ言語はなんと答えてくれるじゃろ。</p>
<p>こうなるとＣにおけるmainの引数argcやargv,envpといった引数とそれがスター トアップルーチンで渡されるメカニズムってやつとＣプログラマが引数を渡す メカニズムってやつが混同してません？ そういう気になるってHaskellに洗脳されかかってますか？ワタクシ？</p>
<p>じゃあもう少し愚考してみちゃおうか。</p>
<pre><code>#include &lt;stdio.h&gt;

int main (int argc, char **argv, char **envp, int rest)
{
  printf("Hello,world! %d\n", rest);
  main(0, NULL, NULL, rest+1);
}</code></pre>
<p>これはどうでしょう？これも自分的には初体験。四つ目の引数を渡しちゃいま した。さすがにこれはコンパイルエラーかなぁと思ったら、</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="f2918786df819793b2989b9c9b">[email&nbsp;protected]</a>&gt; cc test3.c -o test3
<a href="email-protection.html" class="__cf_email__" data-cfemail="6f0c1a1b421c0a0e2f05060106">[email&nbsp;protected]</a>&gt; ./test3

Hello,world! 7597888
Hello,world! 7597889
Hello,world! 7597890
Hello,world! 7597891
Hello,world! 7597892
Hello,world! 7597893
Hello,world! 7597894
Hello,world! 7597895
Hello,world! 7597896
Hello,world! 7597897
^D
<a href="email-protection.html" class="__cf_email__" data-cfemail="f3908687de809692b3999a9d9a">[email&nbsp;protected]</a>&gt; ./test3 1 2 3
Hello,world! 7597888
Hello,world! 7597889
Hello,world! 7597890
Hello,world! 7597891
Hello,world! 7597892
Hello,world! 7597893
Hello,world! 7597894
Hello,world! 7597895
Hello,world! 7597896
Hello,world! 7597897
^D</code></pre>
<p>ほう？これまた奇っ怪なっ。(^^; いやいや機っ械なというべきか。まぁこれが main じゃなくて hoge なんて関 数なら単に初期化してないからとかなんとかって考えて初期化しちゃうんだけ ど、今回は初期化なんかしちゃったら、ある意味ここで気になってる肝心の部 分、つまり外部からの引数の受け渡しと内部での引数の受け渡し云々について 思いをめぐらすことができねぇっす。</p>
<p>じーっと考えるとやっぱりＣ言語の方が変に思えます。なんとなく気持ち悪さ の根源らしきところと、 Haskellのプログラムロード時とコマンドラインから の実行時の引数の与え方、渡り方ってのにかすった手応えがあるんだけど。</p>
<p>どうやらHaskellはある意味で main を特別扱いしてないんだね。もちろん、 main に与える引数の扱いについてって意味でだけど。</p>
<p>Haskellでは、あの世（外界）との専用チャネルはイタコ（何者よ？）を使う 様にしてて、決して関数呼び出しにおける引数渡しのチャネルは使わない様に してる、ってゆーか、それはもう別口なんだなぁ、きっと。確かにいっしょく たにすると無理が出る気がする。Ｃ言語でも何かキテレツな扱いになってたし さ。 でも、そうすっと入出力なんかも同じだな。ファイルディスクリプタっちゅー 専用のチャネルを使ってやり取りするんだよねぇ。 DB アクセスだってそーだ な。ソケットだってそーだ。・・・ってことは単にＣ言語の（ってかHaskell 以外の言語の）コマンド引数だけが扱いが違ってたの？そ、そーなんか？ (@<a href="email-protection.html" class="__cf_email__" data-cfemail="5d021d">[email&nbsp;protected]</a>;)</p>
<blockquote>
<p>WiLiKi:Shiro(2004/09/24 18:39:53 JST): C/C++の処理系の場合、_start という隠れたルーチンがあって、それがgetArgs相当の動作を行った上で、「普通の関数」であるmainを呼ぶことになっていますな。(_start は言語規格内には無いですが、その存在は規格でimplyされていると思います。特にC++のstatic変数のconstructor/destructor関連。) この_startが、Haskellではmainになっている、と思えば良いのでは…</p>
<p>こんな感じかしらん。</p>
<pre><code>#!/usr/local/bin/runhugs

\begin{code}

import System
import IO
import List

main :: IO Int
main = _start

_start :: IO Int
_start =   getArgs &gt;&gt;= cmain


cmain :: [String] -&gt; IO Int
cmain args = mapM_ (putStrLn . greeting) args &gt;&gt; return 0

greeting :: String -&gt; String
greeting = concat . flip intersperse ["もうかりまっか、","はん"]

\end{code}</code></pre>
<p>でもって、</p>
<pre><code>% ./greeting.lhs カットシ ノブオ
もうかりまっか、カットシはん
もうかりまっか、ノブオはん</code></pre>
</blockquote>
<h3 id="モナドを遠目に見る">モナドを遠目に見る</h3>
<p>神の啓示された高度なコードが(シャレ？)あるので、そっちを見てみることにする。</p>
<pre><code>#!/usr/local/bin/runhugs

\begin{code}

高度なコード

\end{code}</code></pre>
<p>まず、いちいち “&gt;” な行にしなくても \begin{code} から \end{code} で括っ てやると同じことが実現できるってことらしい。</p>
<pre><code>import System
import IO
import List</code></pre>
<p>うーむ、いきなり三つもモジュールをインポートしましたね。 System はさっ きも出て来てたからいいとして、 IO ってやつは手ごわそうだ。 List はリス ト演算だから concat や intersperse をロードしようとしてるんだろう。 :find concat してやると List モジュールのソースが出て来る。そんなかに intersperse もある。</p>
<p>で、IO については分からない。 return かな？と思ったら、:find return し ても Prelude が引っ張られる。うーっむ。getArgs は System だしなぁ。</p>
<p>じゃあ例のナサケナイ作戦で確認してみましょう。</p>
<pre><code>#! /usr/pkg/bin/runhugs

&gt; import System

 import IO    &lt;= こんな風にはずしてみる

&gt; import List
&gt;      
&gt; main :: IO Int
&gt; main = _start
&gt;
&gt; _start :: IO Int
&gt; _start = getArgs &gt;&gt;= cmain
&gt;  
&gt; cmain :: [String] -&gt; IO Int
&gt; cmain args = mapM_ (putStrLn . greeting) args &gt;&gt; return 0
&gt;      
&gt; greeting :: String -&gt; String
&gt; greeting = concat . flip intersperse ["もうかりまっか","はん"]
&gt;    </code></pre>
<p>んで、ロード！コマンドラインから実行！・・・問題なく動作しますな。って ことは import IO はいらなそうね。じゃぁ、まぁ要らないんだろうってこ とでうっちゃっておいて、以降のコードを読んでみましょう。</p>
<pre><code>&gt; main :: IO Int
&gt; main = _start</code></pre>
<p>C言語をエミュレートしてるんでしょう。 main は Int を返す関数にしてるの かな？で、main はってーと _start だよって丸投げしてます。どこぞの国の 建設業界みたいですね。</p>
<p>んじゃ、仕事をまかされた _start は？</p>
<pre><code>&gt; _start :: IO Int
&gt; _start = getArgs &gt;&gt;= cmain</code></pre>
<p>こんなんです。当然 main と同じなんだから型も同じじゃなきゃ矛盾しますな。 IO Int 型って書かれてます。</p>
<p>んで、注目の本体は？</p>
<pre><code>&gt; _start = getArgs &gt;&gt;= cmain</code></pre>
<p>getArgs はさっきと同じですよね。 :find getArgs で復習することにします。 実は重度に忘れっぽいです、ワタシ。はい。</p>
<pre><code>getArgs                     :: IO [String]
getArgs                      = do argc &lt;- primArgc
                                  mapM primArgv [1..argc-1]</code></pre>
<p>あ、そうそうこんなんだった。primArgc ってのはその直前に書いてあるんだけど</p>
<pre><code>primitive primArgc          :: IO Int
primitive primArgv          :: Int -&gt; IO String</code></pre>
<p>こんなんです。行頭の primitive ってのがなんとなく、その名称といい、型 しかなくて実体が無いところといい、 こっから先は関係者以外立ち入り禁止 みたいな香ばしい雰囲気を醸し出してます。根性無しの私はすごすごと引き下 がることにします。えぇ、根性無しですとも。</p>
<blockquote>
<p><strong>NOTABENE：</strong> primitive とか、primHogeHage は Hugs 特有のものです。 Haskell 98 の仕様にはありません。また、GHCでも見えないはずです。</p>
</blockquote>
<p>でも Argc/Argv と言えばなんとなく分かると思います。 primArgc/primArgv の型がなんでこうなるのかは、まるで分かりません。しょーがないです。今の 私の経験値ではスライムとかゴブリンあたりが相手です。体力の限界！千代の 富士っす。</p>
<p>それでもこのコードからすっと、</p>
<pre><code>getArgs                     :: IO [String]
getArgs                      = do argc &lt;- primArgc
                                  mapM primArgv [1..argc-1]</code></pre>
<ol type="1">
<li>primArgc からの返り値は多分 Int で引数の個数だろ。</li>
<li>それを argc に束縛してるね。(argc &lt;- primArgc)</li>
<li>mapM が微妙に mapM_ と違うけど気にしない</li>
<li>[1..argc-1] は argc が仮に 10 なら [1..9] だから 1 から 9 までのリストになる</li>
<li>primArgv って関数に引数の個数-1までの数値を与えて評価させてる。</li>
<li>primArgv は？</li>
<li>Int -&gt; IO String ってなっとるってことは数値をもらって文字列を返してる。</li>
<li>その返り値が各引数そのものになってんだね。</li>
<li>マップ関数だからそれがさらにリストになるんで、文字列リスト[String]だね。</li>
</ol>
<p>って感じでざっくりと分かる気がします。んじゃ、元のコードに戻りましょう。</p>
<pre><code>&gt; _start = getArgs &gt;&gt;= cmain</code></pre>
<p>これでした。 getArgs は [String] を返すんだけど、その次の &gt;&gt;= ってのが 確かバインドとかって演算だったと思います。まるで分かりません。また降参 です。ただ、周辺のコードとなによりも動作そのものから推測するに getArgs の返した値を cmain に渡しているんじゃないかと思ったりします。</p>
<p>んじゃ、なんで cmain (getArgs)みたいになってねーんだよ？わざわざ &gt;&gt;= なんて記号でごまかすなよ〜っ！って思いませんか？ 思いますよね？じゃぁ試してみましょう。</p>
<pre><code>&gt; _start = cmain (getArgs)</code></pre>
<p>んで、ロードしてくれっ！</p>
<pre><code>ERROR "/home/cut-sea/script/haskell/greeting.lhs":13 - Type error in application
*** Expression     : cmain getArgs
*** Term           : getArgs
*** Type           : IO [String]
*** Does not match : [String]</code></pre>
<p>うーむ、世の中辛口です。型が違うって言われます。確かにちゃんと見ると getArgs は 何か -&gt; [String] じゃなくて IO [String] なんでした。 単なる [String] が渡ってるんじゃないんですねぇ、どうやら。しかも返す返 すって言ってたけど、何か -&gt; [String] じゃなくて IO [String] ってことは getArgs が [String] を返すっていう表現は非常に怪しい感触ですねぇ。つま り関数呼び出しの引数や返り値とは別口くさいです。 広い意味で情報の渡し方には色々あり得て、関数の引数を通じた渡し方とか返 り値を使った渡し方ってのは、その内の一種に過ぎないってことでしょうか。</p>
<p>まぁ今後も色々実験することで、そのうち敵の姿が捕らえられる様になるでしょ う。楽観主義の O 型です。 IO 型じゃないです。・・・ハァ。</p>
<p>おっと自分の親父ギャグで自らダメージ受けて気死してる場合じゃないよっ。 まぁ、 &gt;&gt;= ってのは引数のメカニズムで返り値を渡すんじゃなくてなんかイ タコのチャネルを駆使して cmain に渡している様なものと解釈することにし ましょう。その方向の理解で押し切れない時がきたら、その時点で自分の認識 を修正していくと。</p>
<p>んじゃ、cmain はどうなっとんの？</p>
<pre><code>&gt; cmain :: [String] -&gt; IO Int
&gt; cmain args = mapM_ (putStrLn . greeting) args &gt;&gt; return 0</code></pre>
<p>うーん、型は[String]これはコマンドライン引数のリストですねぇ、こいつを 受け取って IO Int を返す、と。なんだか意識が遠のいて来ましたよ。トホホ。</p>
<p>実体だけみると、 args ってのが [String] になるんでしょう。こいつにマッ プ関数を適用してますな。コマンドライン引数の各引数に対して作用させる関 数は (putStrLn . greeting) ってことのようです。</p>
<p>この . ってのが関数合成ってやつでしょう。基本的には</p>
<pre><code>(f . g) arg == f (g arg)</code></pre>
<p>と同じことだと思います。ってことはコマンドライン引数の一つに対して、 greeting を適用してそいつの返す値に対して putStrLn を適用すると。って こたぁ greeting は当然 String を受け取って String を返すんでしょう？</p>
<pre><code>&gt; greeting :: String -&gt; String
&gt; greeting = concat . flip intersperse ["もうかりまっか","はん"]</code></pre>
<p>ビンゴ！正解！！すげぇ、型推論できたよ。んじゃ、もうちょっとだ。</p>
<pre><code>List&gt; concat "はろ" "世界"
ERROR - Type error in application
*** Expression     : concat "はろ" "世界"
*** Term           : concat
*** Type           : [[d]] -&gt; [d]
*** Does not match : a -&gt; b -&gt; c</code></pre>
<p>あ、d<a href="Programming_WayToHaskeller.html" class="uri" title="Go to wiki page">?</a> -&gt; [d] か。</p>
<pre><code>List&gt; concat ["はろ","世界"]
"\164\207\164\237\192\164\179\166"</code></pre>
<p>あり？なんで？突如日本語を解さなくなったぞ？！気分悪くしたか？</p>
<pre><code>Main&gt; putStr $ concat ["はろ","世界"]
はろ世界</code></pre>
<p>ふうん。どうやら putStr とかを通さないとダメみたいっすね。</p>
<pre><code>List&gt; concat ["Hello,","World!"]
"Hello,World!"</code></pre>
<p>ま、まぁいいか。こいつで動作確認しとこう。とりあえず、concat ってのは 連結ですね。</p>
<p>flip はってーと、:find flip すると</p>
<pre><code>flip           :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
flip f x y      = f y x</code></pre>
<p>ふむ。型を見るとごちゃごちゃしてるけど、定義を見ると簡単ですね。</p>
<pre><code>List&gt; flip (++) "Hello," "World!"
"World!Hello,"
List&gt; flip (++) "World!" "Hello,"
"Hello,World!"</code></pre>
<p>とまぁこんだけの事の様です。単に関数の引数順序をひっくり返すってのをや るだけです。後で分かるけど、interperse の引数順と関係あるみたいです。</p>
<p>じゃぁラスト intersperse は確か HowTo:Listで見掛けましたね。リストの各 要素間にある要素を差し込んでたと思います。</p>
<pre><code>intersperse             :: a -&gt; [a] -&gt; [a]
intersperse sep []       = []
intersperse sep [x]      = [x]
intersperse sep (x:xs)   = x : sep : intersperse sep xs</code></pre>
<p>そんな難しい定義では無いようです。じゃ、自分で書けって言われたら「無理！ ごめんなさい！！」って即答ですけど。</p>
<pre><code>List&gt; intersperse " " ["Hello,","World!"]
["Hello,"," ","World!"]</code></pre>
<p>んじゃ、これを組合せるトコにいきましょうかね。</p>
<pre><code>&gt; greeting = concat . flip intersperse ["もうかりまっか","はん"]</code></pre>
<p>interperse ‘何か’ [“もうかりまっか”,“はん”]ってのが本来の使い方なので、 flip することで interperse [“もうかりまっか”,“はん”] ‘何か’ って形に持 ち込んでいると思われる。つまり</p>
<pre><code>g = flip interperse ["もうかりまっか","はん"]
g arg = flip interperse ["もうかりまっか","はん"] arg
      = interperse arg ["もうかりまっか","はん"]
      = ["もうかりまっか",arg,"はん"]</code></pre>
<p>って感じですね。まぁこんな風に Curry 化するために flip って関数を使っ てたんですな。そうして出来た関数 g と concat の関数合成なので結局は " もうかりまっか arg はん"っていう String になるわけかぁ。</p>
<p>・・・おっと、忘れてたっっ！！</p>
<pre><code>&gt; cmain args = mapM_ (putStrLn . greeting) args &gt;&gt; return 0</code></pre>
<p>&gt;&gt; return 0 がまだでした。うぅぅ。(–; また出たよ、記号が・・・ &gt;&gt; って &gt;&gt;= とどう違うんだよ〜単に結果を左から右に引き渡さないだけか？</p>
<p>emacs 上で &gt;&gt;= とか &gt;&gt; とかにカーソルをあわせてみる。</p>
<pre><code>&gt;&gt;=   :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
&gt;&gt;    :: Monad m =&gt; m a -&gt; m b -&gt; m b</code></pre>
<p>となります。例のボスキャラです。正直分からないので、真正面から対決せず、 遠方からその立ち姿を眺めるだけにします。</p>
<pre><code>&gt; _start = getArgs &gt;&gt;= cmain</code></pre>
<p>ここで getArgs が IO [String] 型で cmain は [String] -&gt; IO Int 型です。 上の &gt;&gt;= の型は Monad m =&gt; って見たこと無いのが付いてますけど、:find &gt;&gt;= ってやれば分かるように型そのものを意味するものでは無いようですね。 単に m はモナドってやつを意味してるよってことらしい。</p>
<p>これで &gt;&gt;= の、この局面での型に当てはめてみると、</p>
<pre><code>m  は  IO
a  は  [String]
b  は  Int

getArgs :: IO [String]
cmain   :: [String] -&gt; IO Int
&gt;&gt;=     :: IO [String] -&gt; ([String] -&gt; IO Int) -&gt; IO Int
               ↑                   ↑
              getArgs              cmain</code></pre>
<p>ってことで &gt;&gt;= は、やはり中置演算子くさいです。んじゃ、確認しましょう。</p>
<pre><code>&gt; _start = (&gt;&gt;=) getArgs cmain</code></pre>
<p>こんな風に書き換えて、同じ動作をすれば、取り合えずは良いんじゃないでしょうか？</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="c1a2b4b5ecb2a4a081aba8afa8">[email&nbsp;protected]</a>&gt; ./greeting.lhs カットシ ノブオ
もうかりまっかカットシはん
もうかりまっかノブオはん</code></pre>
<p>ぱちぱちぱち。予想的中。そんじゃ &gt;&gt; の方も確認して心を落ち着かせてみます。</p>
<pre><code>m  は  IO
a  は  String
b  は  Int

greeting  ::  String -&gt; String
putStrLn  ::  String -&gt; IO ()
(putStrLn . greeting)  ::  Sting -&gt; IO ()
mapM_  :: (String -&gt; IO ()) -&gt; [String] -&gt; IO ()
                  ↑              ↑
         (putStrLn . greeting)   args

mapM_ (putStrLn . greeting) args  :: IO ()
return  :: Int -&gt; IO Int    &lt;= return の型は a -&gt; m a なんだけど b -&gt; m b です
                               この辺は周囲の型との関係からね
&gt;&gt;  :: IO () -&gt; IO Int -&gt; IO Int
         ↑        ↑       ↑
  mapM_ ... args   ｜       ｜     
                return 0   _start</code></pre>
<p>とまぁ、多分こんなんでしょうか？んーーーー、だからどーした系の後味。(–; 要は mapM_ … args の部分は IO の絡むアクションをするけど、値は渡さず () っていう(ユニット型っていうらしい)ものを渡して、 &gt;&gt; の右項は IO Int って感じで Int を返す？というか渡す？よと。 どうも左項の mapM_ … args の結果を無視して右項だけでテキトーに結果を 作っちゃってます。全然協調してません。 &gt;&gt; ってのは。えぇ、全然パスが通っ てないです。実際 m a -&gt; m b -&gt; m b って事なんで、 m a と m b の二つの 引数をもらってながら、 m b 型が返値になってるんで、m a が消失してて全 然脈絡がないっす。ひどいヤツです。 &gt;&gt; は。 こういう奴がクラスに一人いると、雨の日に遠足の準備をして学校に来てしま い、一日中授業で肩身の狭い思いをする生徒が出て来てしまうんです。パスを もらえなかった可哀想な return は、自分の判断でオヤツとか「遠足のしおり」 しか持って来てなかったりします。この場合は 0 です。どっから出て来た？っ て数字です。ホントひどい &gt;&gt; ですね。えぇ、私がまさにそうでした。&gt;&gt; な 奴でした。ごめんなさい。m(__)m</p>
<p>え、えっと、一方で &gt;&gt;= はってーと、</p>
<pre><code>&gt;&gt;=   :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</code></pre>
<p>って事なんで、一応 (a -&gt; m b) ってところで a から b への関係を持ってま す。一応パスが通ってます。（実は細かくツッコまれると自信ないんだけ ど・・・）そういう関数を取っているところが、私と、いや &gt;&gt; と違うところ の様です。</p>
<p>まだまだ、ナットクいかねぇってところも有りますが、無理は禁物。肩の力を 抜いて、いい加減なノリで勉強を進めましょう。ユースケサンタマリアに成り 切ると丁度いいです。多分。なんせ、敵は<a href="http://www014.upp.so-net.ne.jp/tetryl/llw2004/ll-samurai.txt">LL侍</a>も恐れるモナドです。じっく り行きます。モナドは理解するより、どう使うのかを考えた方か幸せになれる と、 <a href="http://i.loveruby.net/w/HaskellFAQ.html">どっか</a>に書いてありましたしね。</p>
<p>あ、最後に一応</p>
<pre><code>&gt; cmain args = (&gt;&gt;) (mapM_ (putStrLn . greeting) args) (return 0)</code></pre>
<p>を確認しておきましょう。</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="137066673e60767253797a7d7a">[email&nbsp;protected]</a>&gt; ./greeting.lhs カットシ ノブオ
もうかりまっかカットシはん
もうかりまっかノブオはん</code></pre>
<p>はい、ぱちぱちぱち〜！</p>
<h3 id="cat.lhs-とかもみとく">cat.lhs とかもみとく</h3>
<pre><code>#! /usr/pkg/bin/runhugs

&gt; --
&gt; -- cat.hs
&gt; --
&gt; -- A simple cat command in Haskell.
&gt; --
&gt;
&gt;module Main where
&gt;     
&gt;import System
&gt;import IO
&gt;    
&gt;main :: IO ()
&gt;main = do args &lt;- getArgs
&gt;          case args of
&gt;            [] -&gt; catFile stdin
&gt;            _ -&gt; mapM_ (\a -&gt; do f &lt;- openFile a ReadMode
&gt;                                 catFile f
&gt;                                 hClose f) args
&gt;         
&gt;catFile :: Handle -&gt; IO ()
&gt;catFile f = do eof &lt;- hIsEOF f
&gt;               if eof then return () else
&gt;                  do c &lt;- hGetChar f
&gt;                     putChar c
&gt;                     catFile f</code></pre>
<p>これです。ほとんどの部分はこれまでの読み込みで理解できます。新たに出て 来たのが、case ってやつと (\a -&gt; do …) の部分の \ です。また記号。あ と、 catFile の型に現れる Handle や hIsEOF とか hGetChar hPutChar って やつ。名前からおおよそ予想はつきますけど、一応見て行きます。cat は基本 中の基本ですし。</p>
<p>case については emacs 上でカーソルをあわせると、</p>
<pre><code>case exp of { alts [;] }</code></pre>
<p>ってなってます。おそらく args の値に応じて場合分けしてるんでしょ。</p>
<p>[] だったら catFile って関数に stdin を引数に与えて呼び出します。要は コマンドライン引数が無かった場合は標準入力から読み込むんですね。一方 _ ってのは、なんでしょーか。訳分かんないのがぞくぞく出て来る。でも、どっ かで見たこと有ります。いろいろやって思い出しました。 :find head してみ ると、</p>
<pre><code>head             :: [a] -&gt; a
head (x:_)        = x

last             :: [a] -&gt; a
last [x]          = x
last (_:xs)       = last xs

tail             :: [a] -&gt; [a]
tail (_:xs)       = xs

(snip)

null             :: [a] -&gt; Bool
null []           = True
null (_:_)        = False</code></pre>
<p>こんな感じです。どうやら任意の値にマッチするようなもののようです。特殊 なシンボルってより、慣用的に用いられるシンボルでしょうか。試してみましょ う。</p>
<pre><code>&gt;            x:xs -&gt; mapM_ (\a -&gt; do f &lt;- openFile a ReadMode</code></pre>
<p>としたり、</p>
<pre><code>&gt;            _:_ -&gt; mapM_ (\a -&gt; do f &lt;- openFile a ReadMode</code></pre>
<p>としてみたり、いずれも問題なく動作します。どうやら -&gt; の右側で参照され ることのない任意のシンボルを _ で書きゃいい様です。実際後の例で、もし 右側で _ を参照したら _:_ のどっちなのか分かんないしね。ちなみに <a href="http://www.sampou.org/haskell/tutorial-j/patterns.html">ワイルドカード</a>って言うらしいです、コレ。</p>
<pre><code>(\a -&gt; do f &lt;- openFile a ReadMode
          catFile f
          hClose f)</code></pre>
<p>お次はこれですね。たびたび出て来る、この手の式はλ式らしいです。 \ a -&gt; … ってのは引数が一個 a ってのを取る匿名の関数を作ってるみたい。</p>
<pre><code>(lambda (a) (let1 f (openFile a ReadMode)
               (catFile f)
               (hClose f)))</code></pre>
<p>Scheme風に書くとこんな感じでしょう。もち、単なる擬似コードなんですけど。 これもなんとなく a がコマンドライン引数の一つになるので String だと思 いますが (実はハズレ)、こいつを openFile の第一引数に与えて、第二引数 を ReadMode つまり読み取り専用モードにしている。返って来たファイルディ スクリプタらしいものが、f に束縛されます。 おおっ！！出て来ました。ファイルディスクリプタ！これの型は？これの型！ emacs でカーソルをあわせても何にも出ません。しょーがないので :find openFile します。えいや！</p>
<pre><code>primitive stdin       :: Handle
primitive stdout      :: Handle
primitive stderr      :: Handle
primitive openFile    :: FilePath -&gt; IOMode -&gt; IO Handle  &lt;= コレ
primitive hClose      :: Handle -&gt; IO ()

primitive hFileSize   :: Handle -&gt; IO Integer

primitive hIsEOF      :: Handle -&gt; IO Bool</code></pre>
<p>ん〜、 取り合えず IO Handle ってのがファイルディスクリプタに相当する型 くさい。ってことは、 catFile f や hClose f ってのは IO Handle -&gt; 何か なはず！！</p>
<p>・・・って思ったら、オレってホント学習能力ないです。うーん。そうか、 Handle か。ますます分からなくなった。ガク。</p>
<p>と、とりあえずファイルディスクリプタってのは Handle 型みたいだ。うーん。 そういや、上の方の primitive を見てみても stdin とか stdout なんかが Handle って書いてあるじゃねーの。</p>
<p>まぁいいです。とにかくこのλ式はファイル開いて書き出してクローズしてる と。そんだけです。で、「書き出して」の部分をやってる catFile はってー と、</p>
<pre><code>&gt;catFile :: Handle -&gt; IO ()
&gt;catFile f = do eof &lt;- hIsEOF f
&gt;               if eof then return () else
&gt;                  do c &lt;- hGetChar f
&gt;                     hPutChar stdout c
&gt;                     catFile f</code></pre>
<p>これですね。この辺もさして難しくないように思うんだよね。他の言語の知識 があれば、およそは分かった気になれそう。 if then else もあるんだぁって のがささやかなへぇ〜っです。 ただ一点、しつこいようですが、ディスクリプタを返す openFile の返り値が Handle でいーじゃん！単に Handle を返すんじゃダメなの？なんで？ってト コだけナットクできねっす。(–; do ってのはモナド演算の構文糖衣って書いてあるってことは、実質 &gt;&gt; とか &gt;&gt;= なんかで繋げられたブロックだと思うので、型としての辻褄がそうなって いるらしいのはいいんだけど、ここを IO Handle じゃなくて Handle にする と何か問題でも？！全体としてそれだと、どっかで矛盾が発生するのだろう か？ってゆー疑問を抱きつつ、そろそろつかまり立ち（だから、どういう基準 だよっ？）へＧＯ！</p>
<blockquote>
<p>こんな問題が・・・と言っても分かりづらいと思うので、簡単な説明を。</p>
<p>例えば、getChar :: IO Char の IO を外した readChar :: Char を定義してみます。</p>
<pre><code>import System.IO.Unsafe

readChar :: Char
readChar = unsafePerformIO getChar

main :: IO ()
main = putStrLn [readChar, readChar]</code></pre>
<p>このコードを実行すると、最初に入力した文字が2回出力されます。 readChar で一度計算された値がキャッシュされるからです。</p>
<p>Haskell は、参照透明性(ある式の値をいつ評価しても変わらないという性質) を前提として作られています。そのおかげで、評価を必要になるまで遅らせた り、一度評価した結果をキャッシュしておいたりすることが可能になるのです。</p>
<p>しかし、そのせいで、readChar のように、評価するたびに値が異なる式をう まく扱う事ができなくなっているのです。</p>
</blockquote>
<p>まぁ一応 cat.lhs も読めました。(^^)v ・・・まだ、自分じゃ書けないけどね。</p>
<h3 id="ちょっとひとやすみピュアな怠け者">【ちょっとひとやすみ】ピュアな怠け者</h3>
<blockquote>
<p>作成中。。。</p>
</blockquote>
<p>(<a href="http://www.sampou.org/cgi-bin/haskell.cgi?p=Programming:WayToHaskeller:%EF%BF%BD%CF%A4%EF%BF%BD%EF%BF%BD%CF%A4%EF%BF%BD&amp;c=e&amp;l=jp">「はいはい」を編集する</a>)|(<a href="http://www.sampou.org/cgi-bin/haskell.cgi?Programming:WayToHaskeller&amp;l=jp">Haskellerへの道</a>)</p>
<hr>
<h2 id="つかまり立ち">つかまり立ち</h2>
<p>(<a href="http://www.sampou.org/cgi-bin/haskell.cgi?p=Programming:WayToHaskeller:%EF%BF%BD%C4%A4%EF%BF%BD%EF%BF%BD%DE%A4%EF%BF%BD%CE%A9%EF%BF%BD%EF%BF%BD&amp;c=e&amp;l=jp">「つかまり立ち」を編集する</a>)|(<a href="http://www.sampou.org/cgi-bin/haskell.cgi?Programming:WayToHaskeller&amp;l=jp">Haskellerへの道</a>)</p>
<p>すでに勉強してきたネタも尽きたし、改めて <a href="http://www.sampou.org/haskell/tutorial-j/index.html">やさしいHaskell入門</a>とか<a href="http://www.sampou.org/haskell/a-a-monads/html/index.html">モナドのすべて</a>とか読み込まないといかん。</p>
<h3 id="リストもモナド">リストもモナド？</h3>
<p>んで早速、<a href="http://www.sampou.org/haskell/a-a-monads/html/meet.html">ここ</a>を読んでたら、 リストもモナドなんだってさ。これって実は 以前も読んでたんだけど、それほど気にならなかった。でも、今の自分にはな ぜか衝撃的！ だってさ、そうだとするとオイラはモナドなんぞチンプンカンプン・・・・ ってこたリストを分かってねーじゃんっ！！げげげ。(+_+;</p>
<p>んで、リストの型構築子は [] だっちゅーわけですな。 [a] ってな感じで a を [ と ] ではさんでやれば、 a を要素にもつリストです。</p>
<p>ほほぅ、こんなんは表記の問題だからさ、もしかしたら、実装者の気の向きよ うによってはList a ってな書き方してたとしてもいーわけよ。逆に IO a っ てやつも &lt;&lt;a&gt;&gt; って表記する様になってた可能性だってあるよね？</p>
<p>実際に、</p>
<pre><code>Haskell の構文では[t] を[] t と書くことも許されています。</code></pre>
<p>って<a href="http://www.sampou.org/haskell/tutorial-j/goodies.html">ここ</a>にも書いとる。これって List ってのが [] になっただけじゃん？ じゃーさじゃーさ、</p>
<pre><code>main :: IO a</code></pre>
<p>だっつー感じで書けるんだとすると、</p>
<pre><code>main :: List a</code></pre>
<p>って書けたっていーじゃんね？っちゅーことはさ、</p>
<pre><code>main :: List a
     ↓
main :: [] a
     ↓
main :: [a]</code></pre>
<p>なんだよね？・・・・・・・・・・・・・・・えぇぇぇぇええええぇぇっっっ！！？ ちょい待て、 [a] ってリストだよん？これってどういう関数だ？</p>
<h3 id="main-は関数じゃねーのか">main は関数じゃねーのか？</h3>
<p>どういう関数もこういう関数もリストはリストだわなぁ。</p>
<p><a href="http://www.sampou.org/haskell/tutorial-j/goodies.html">ここ</a>とかには -&gt; ってのも型構築子の一種で a -&gt; b って書くと a を引数に 取って、b を返す関数って型になると書いてあった記憶がある。</p>
<p>同じように -&gt; は型構築子です。与えられた 2 つの型 t と u に対して、 t-&gt;u は型 t の要素から型 u の要素への写像をおこなう関数の型です。</p>
<p>あ、コレコレ！この文章！・・・ってことはやっぱり、これ関数じゃないよ？ main って名前なもんだから、何の疑いも持たずに関数だと思い込んでたけど、</p>
<pre><code>main :: IO a</code></pre>
<p>って、どこをどうみても関数らしい型宣言になってねーぞ？じゃあ何よ？</p>
<pre><code>#!/usr/pkg/bin/runhugs

&gt; main :: [a]
&gt; main = [1,2,3]</code></pre>
<p>ってしてみて、ロードしてみる。</p>
<pre><code>Type checking
ERROR "/home/cut-sea/script/haskell/test2.lhs":3 - Cannot justify constraints in type annotation
*** Expression    : [1,2,3]
*** Type          : [b]
*** Given context : ()
*** Constraints   : Num b

Prelude&gt; </code></pre>
<p>ありゃ？なんで？ Type は [b] ってことは、別に [a] でも正しいような気が するんだけど、とりあえず型を外してみるか？</p>
<pre><code>#!/usr/pkg/bin/runhugs

&gt; main = [1,2,3]</code></pre>
<p>これでどーだ！ロード！！</p>
<pre><code>Main&gt; main
[1,2,3]
Main&gt; main 1   &lt;= 例の常套手段で型を教えてもらってる
ERROR - Type error in application

*** Expression     : main 1
*** Term           : main
*** Type           : [Integer]
*** Does not match : a -&gt; b</code></pre>
<p>あー、[a] じゃダメなんだ。[Integer] なのかぁ。間違っちゃいない気もする んだけどなぁ。 (<a href="Type.html" class="uri" title="Go to wiki page">Type</a>参照：ほう、なるほど) まぁいいや。今はそれどころじゃ ないし。</p>
<pre><code>#!/usr/pkg/bin/runhugs

&gt; main :: [Integer]
&gt; main = [1,2,3]

Main&gt; main
[1,2,3]</code></pre>
<p>おっけー！走るとは思えないけど一応コマンドラインから実行！</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="d8bbadacf5abbdb998b2b1b6b1">[email&nbsp;protected]</a>&gt; ./test.lhs 

Program error: fromDyn failed.  Expecting &lt;&lt;IO ()&gt;&gt; found &lt;&lt;[()]&gt;&gt;
runhugs: Error occurred</code></pre>
<p>うむ。まぁいい。これは無視！ とにかく、これと同じことなんじゃないだろうか？つまり、これまで悶々とし ててイマイチ釈然としなかったんだけど、 IO () とかを関数だと思ってたの が間違いなんじゃね？もしかすっと。</p>
<p>恐れ多くてとても口に出来ないので書いちゃいますけど。もしかするともしか してIO ()型の main は関数じゃなくて値 なんでないすか？</p>
<p>んじゃーどういう値よ？って言われたらアクションっていう値なんじゃないか？</p>
<pre><code>Main&gt; main
[1,2,3]</code></pre>
<p>って感じで、main がたまたまリストの場合は評価された結果、リスト[1,2,3]っ てのがオメミエするわけだけど、 main の値がたまたまアクションの場合は評 価結果としてアクションを取って見せる、と。</p>
<p>全然話が違うけど ASCII コードの 07h ってコードに bell ってのがあるね。 ほとんど、どのコードも印字された時の表示形式があるけど、 bell は我々の 目には見えず、耳に聞こえる形で、その存在をみせてくれる。平たく言えば ビーッって泣きやがる。あ、良く見たら他にもあるわ。BS とか DEL とか。。。 そだ！ BS や DEL なんか、まさにそのアクションでもって、その文字コード がそこにあることを教えてくれるよね？</p>
<p>・・・えっと、何言いたかったんだっけ？(^^;; ・・・ど、どーゆー理屈だか自分でも不可解だけど、値ってやつが全て印字さ れたときの表示形式を持ってなくちゃならないって決まってなくて、我々の視 覚以外の感覚器官に訴える形であっても良いわけよ。あるいは何も訴えなくたっ ていいわけで、cp.lhs なんかその最右翼じゃない？ (まだ作ってねーけど) アクション型(勝手につけてるし・・・)の場合には、我々の目に見えるとか聞 こえるとかが本質じゃなくて、まさに何らかのアクションをするって形で、そ の存在を示すんじゃないかしらん。たまたま、Hello,World!って印字したりと か、ビーってビープ音を出すかもしれんけど。</p>
<p>数値だって本質は整数の何番目の数とか、そーゆー難しい抽象的な存在なわけ で、それ自体はそもそも目に見えるものじゃないんじゃないかな。多分。その 印字名として 1 とか 2 とかって表示が与えられてるにすぎねーのよ。人間に とって便利だからさ。うん。 逆に数値だって印字表現がなくてカワイイ女の子の声で「いち♪」とか「に♪」 とかって表現されたらどうよ？もしそうだったら数値は目には見えないけど、 やっぱりデータだよね？この論法、かなり無理くさいですか？そうですか・・・</p>
<blockquote>
<p>Haskell では印字可能クラスというのあります。Show class です。Integerや Charなどは Prelude で、Show class のインスタンスとして宣言されています ので、評価結果が Integer や Char になるものはインタープリタで評価した ときに評価結果が表示されます。要素 a が Show クラスのインスタンスであ れば、[a] も Show クラスのインスタンスであることが宣言されていますので、 [Integer] なども印字可能です。</p>
<p>しかし、id とか head とか Prelude で Show クラスのインスタンスであるこ とが宣言されていない関数は、評価すると印字用の show 関数(Show クラスの メソッド)がないぞ、というエラーが出るはずです。</p>
</blockquote>
<h3 id="io-a-の-a-と-a-の-a">IO a の a と [a] の a</h3>
<p>でもさ、そうすっと IO a って本来は、そのお姿を見せてくれないんだから、 IO () だろうが、 IO String だろうが、 IO [String] だろうが同じじゃねぇ か？つまり、String とか [String] とか IO にとっては違いは関係ないんじゃ ね？</p>
<p>・・・うーむ、脳味噌が沸騰しはじめた。ε=(+_+;=3</p>
<p>いやいやリストだって同じだ。確かに IO a において a は内部に隠されてて 見えないけど、 [Integer] とか [String] ってリストだって同じなんだよ、 きっと。</p>
<p>実際には List a の a は内部に隠し持ってて、本来リストとして見たときに は Integer とか String とかは見えないんじゃねーかな？</p>
<pre><code>Main&gt; [1,2,3]
[1,2,3]
Main&gt; ["cut-sea","nobsun"]
["cut-sea","nobsun"]</code></pre>
<p>こんな風に確かに 1 とか 2 とか “cut-sea” とか “nobsun” とか見えている けど、そりゃーたまたま(？) Haskell の実装においてリストの表示は、その 内部に隠し持っているメンバであるところの 1 とか 2 とか “cut-sea” とか “nobsun” とかを表示する様になってるだけなんじゃん？</p>
<p>もしかしたら、実装者になんかの気の迷いがあったりして、</p>
<pre><code>Main&gt; [1,2,3]
#&lt;List 0x8121e60&gt;          &lt;= こんな印字形式とかさ
Main&gt; ["cut-sea","nobsun"]
#&lt;List 0x8121e64&gt;</code></pre>
<p>みたいな、そういうリストの印字表現を持つような、そんな実装があったとし ても、それはそれでいいんじゃないかなぁ。 リストの先頭っていうかルートへのポインタを指すオブジェクトをこう、さ。うん。</p>
<p>そのポインタから継っている全体がリスト、そういう構造みたいなのがリスト であって、内部に持っている要素にアクセスする手段として car/cdr じゃねー や、 Haskell だと head/tail があって、これを使えば、全要素にアクセスで きるし、それにアクセスした時にリストが [Integer] なら Integer の 1 と か 2 とか、 [String]なら “cut-sea” とか “nobsun” が見えると。これは実 際には [Char] だから、そういう実装だと、 “cut-sea” とは表示されずに、 さらに #&lt;List 0x8121e68&gt;みたいな表示になっちゃうだろうから〜・・・ うぇっ！すんげー不便だ、なんだこりゃ！美的センスゼロじゃん。 ともかく、そういう実装だとしたらリストだって、結局 [a] の a ってのは内 部に 隠し持たれてるものであって、リストの印字表現に含まれなきゃならな いものじゃないんだよ〜、多分。リストの本質は head とか tail とかって演 算によってアクセスされたり、 :って演算によって構成されたりする、そうい う構造そのものが本質だと。</p>
<p>同じ様に IO a でも IO () ってのと IO String ってのと IO [String] って のは、 IO っていう(リストと同様に何らかの構造とか性質を持った)値として 存在してて、そいつが内部に隠し持っているデータとして () とか String と か [String] とかがある？</p>
<p>んじゃ、そういう目でもっかい echo.lhs を見てみるとしようか。</p>
<pre><code>Main&gt; main 1 2 3
ERROR - Type error in application
*** Expression     : main 1 2 3
*** Term           : main
*** Type           : IO ()
*** Does not match : a -&gt; b -&gt; c -&gt; d

Main&gt; main

Main&gt; </code></pre>
<p>うむ。やっぱ関数じゃない。main の値が現れました。 おぉっ、見える！わたしにも値が見えるぞ！ラ○ァ！！ ・・・えっと、とり あえず、自分の中ではナットク出来た気がするんだけどなぁ。</p>
<p>見えねぇもんが見えるなんて、なんか瞳孔おっぴろげて変な宗教にハマってる ヒトみたく、危ない方向につっ走ってますか、私？</p>
<h3 id="thunk-はどう書くのか">thunk はどう書くのか？</h3>
<p>うぅっ、こんなつもりじゃなかったのに、次々に疑問が湧き出す。 そもそもアクションが値なんて勢いで言ったけど、アクションて結局は関数の 評価プロセスそのものなんじゃないか？ カッコがないと、いまいち違いが分かりにくいので、あえてScheme?で書くけど、</p>
<pre><code>gosh&gt; (define f (lambda () body))</code></pre>
<p>ってな定義があったときに、</p>
<pre><code>gosh&gt; f</code></pre>
<p>これを評価した結果得られるのは、関数実体つまり第一級のデータですねぇ。</p>
<pre><code>gosh&gt; (f)</code></pre>
<p>これは関数を評価した結果生まれるアクションですねぇ。 UNIX システムで言 えば、 f の評価の結果として得られるのはプログラムで、 (f) の評価の結果 得られるのはプロセスだな。これ、トーゼン全くの別人さんです。はい。</p>
<p>前者は関数型言語におけるデータと言って差し支えないけど、その評価プロセ ス(？)は違うな。 [] a と IO a とのアナロジーからの話の展開に自信持っ ちゃってましたけど。 あぁぁあ((((( ;゜Д゜))))ガクガク。 要は何が言いたいかっちゅーと、アクションが値だってーのはかなり嘘くさい ぞ？私のゴーストがそうささやいとる。つまり勘です。はい。</p>
<p>そーすっとすぐさま気になるのは！ ‘引数を持たない関数 thunk は Haskell ではどう書くのか？’ っちゅーことです。そういや、勉強はじめてからまだ一度も見てない気がする。</p>
<p>純粋関数型言語では同じ式は何度評価しても同じ値を返すっちゅーので、引数 という、関数の動作を変更する源が無い場合には、結局即値と同じモノって気 がしないでもない。</p>
<blockquote>
<p>ell にはサンクという概念がありません。だって、Lazy なんだから。値は必要になるまで計算されません。敢て言うなら、全部サンク。</p>
<pre><code> = sum [1..]</code></pre>
<p>いてあっても、hoge の値は必要とされているわけではありませんよね。 、ここでクイズ、hoge の値は、何時、どんな場合に必要とされるでしょう？ –nobsun</p>
<p>型は？その本体の定義は？っちゅー訳で探し回ってみる。 ・って、探している内に神の声で thunk って概念はないよ、とのこと。 む、thunk についての理解が足りてないのか？？どうも神の問かけに詰まっ まった。</p>
<p>げーおーげー、まぁ落ち着け。ここは一つクールにいこう。・・・まず、 トが含まれている。と思う。</p>
<pre><code> = sum [1..]</code></pre>
<p>は’敢えて言うなら全部サンク’の例でしょう。 も停止しない式として書かれておる。</p>
<p>&gt; hoge 123 &lt;= 例の常套手段 R - Type error in application Expression : hoge 123 Term : hoge Type : Integer Does not match : a -&gt; b</p>
<p>。 Type は Integer か。実は、</p>
<pre><code> :: -&gt; Int     &lt;= 苦しまぎれ</code></pre>
<p>ってすると、</p>
<p>ing file “/home/cut-sea/script/haskell/test.lhs”: ing……………………………………………………. R “/home/cut-sea/script/haskell/test.lhs”:16 - Syntax error in type signature (unexpected `-&gt;’) ude&gt;</p>
<p>構文エラーが出るし、</p>
<pre><code> :: _ -&gt; Int   &lt;= 悪あがき</code></pre>
<p>すると、</p>
<p>ing file “/home/cut-sea/script/haskell/test.lhs”: ing……………………………………………………. R “/home/cut-sea/script/haskell/test.lhs”:16 - Haskell 98 does not support anonymous type variables ude&gt;</p>
<p>叱られる。 Haskell では関数は引数が無きゃならんのかもしれん。と思 めてたとこだったりする。引数の無い関数ってのは、そのままデータだっ うことか。 言えば、あらゆるデータは全て thunk だってことでしょう。</p>
<p>ゃ、 thunk を復習してみるとしよう。</p>
<p>&gt; (define (f x y) (* 2 x)) &lt;= 第二引数は評価の必要無い関数を定義</p>
<p>&gt; (f (+ 2 3) (read)) &lt;= 正格評価を試してみる</p>
<pre><code>                       &lt;= 第二引数が停止しないので強制終了！
                          標準入力から何か打ち込みゃ良いけど疑似的にね</code></pre>
<p>ERROR: unhandled signal 2 (SIGINT) k Trace: ___________________________________</p>
<pre><code> (read)
    At line 9 of "(stdin)"</code></pre>
<p>&gt; (define (h x y) (* 2 (x))) &lt;= thunk 用です。やはり第二引数評価は不要</p>
<p>&gt; (h (lambda () (+ 2 3)) (lambda () (read))) &lt;= 非正格評価</p>
<p>&gt;</p>
<p>ですね。Haskell においてはデータは全てサンクだってことは、 Haskell 全ての値は (lambda () value) って感じにくるまれているのか。でもっ Haskell の式評価は (thunk) って感じで force しているのか。</p>
<p>ゃ、問題の hoge の値は何時、どんな場合に必要とされるか？ですな。</p>
<p>&gt; (define (h x y) (* 2 (x)))</p>
<p>&gt; (define hoge (lambda ()</p>
<pre><code>                 (let loop ((n 1))
                   (+ n (loop (+ n 1))))))  &lt;= hoge はこう</code></pre>
<p>&gt; (define five (lambda () 5)) &lt;= Haskell での 5 はこうか？</p>
<p>&gt; (h five hoge) &lt;= Haskell での評価をエミュレート</p>
<p>&gt; (h hoge five) &lt;= hoge が必要な計算の例</p>
<pre><code>                                      &lt;= したがって強制終了</code></pre>
<p>ERROR: unhandled signal 2 (SIGINT) k Trace: ___________________________________</p>
<pre><code> (loop (+ n 1))
    At line 7 of "/home/cut-sea/script/scheme/test.scm"
 (loop (+ n 1))
    At line 7 of "/home/cut-sea/script/scheme/test.scm"
 (loop (+ n 1))
    At line 7 of "/home/cut-sea/script/scheme/test.scm"</code></pre>
<p>&gt;</p>
<p>む。・・・ムツカシイ(–;) ゃ、どんな場合に必要とされないか？を考えてみるか。</p>
<p>&gt; (h (lambda () (+ 2 3)) (lambda () (read))) &lt;= 非正格評価</p>
<p>&gt;</p>
<p>場面で (lambda () (read)) は結局必要とはされなかったなぁ。実際私が しなくても計算は勝手に完了した。これはまさに (read) が評価されなかっ 拠だな。うん。</p>
<pre><code> て値は (read) に無関係に決まった値ですねぇ。</code></pre>
<p>り、ある式が結果として、ある値に至る場合を考えると、その値に hoge が影響を与える場合に hoge は必要とされるんですね！</p>
<p>・って分かったような気になったけど、コレってお題を言い換えただけ？(^^; ません。いっぱいいっぱいまで脳圧上げて考えましたが降参です。お許し下せぇ。</p>
<blockquote>
<p>例えば、次のような関数を定義してみよう。</p>
<pre><code>isLT7 :: Int -&gt; Bool
isLT7 = \ n -&gt; n &lt; 7</code></pre>
<p>これは、与えられた引数が 7 より小さいかを判定する関数です。さて、 Haskell では、hoge も isLT7 も定義しただけでは、計算は何もおこりません。 これがまず、Scheme と違うところです。</p>
<p>では、計算はいつ起るかというと、式を評価しようとした時です。</p>
<pre><code>isLT7 hoge </code></pre>
<p>をインタープリタのプロンプトのところで評価すると何が起るかを考えてみましょう。</p>
<p>注意することは、 lazy evaluation では、必要になるまでは計算されないと いうことです。</p>
<p>つまり、なにを求められているか、それには何が必要か、という順で考えることです。</p>
<p>インタープリタのプロンプトのところに、isLT7 hoge と入力すると、</p>
<ol type="1">
<li>インタープリタは、isLT7 hoge の値を印字しようとする</li>
<li>印字ためには、isLT7 hoge の値を(False または True に)確定しなければならない</li>
<li>そこで、isLT7 hoge の関数適用を計算する
<ol type="1">
<li>isLT7 を定義にしたがって、置き換えると (\ n -&gt; n &lt; 7) hoge</li>
<li>λ式の本体の仮引数を、実引数で置き換えると hoge &lt; 7</li>
<li>これが、確定したBool型を返すには、hoge と 7 の確定値が必要
<ol type="1">
<li>hoge の確定値を計算</li>
<li>7 の確定値を計算(これは 7 ですね)</li>
</ol></li>
<li>hoge &lt; 7 の確定値計算</li>
</ol></li>
<li>isLT7 hoge の確定値を得たので、これを印字</li>
</ol>
<p>となる(はず)ですね。つまり、hoge の(確定)値は 3.3. のところで始めて必 要とされるわけです。で、実際には、この値を確定しにいくところで、無限の 計算にはいってしまって、先へは進まなくなるわけです。このような状態の hoge の値は ⊥ です。</p>
<p>正格(strict)とは、x ＝ ⊥ ならば f x ＝ ⊥ となるような関数 f の性質 のことで、非正格(non-strict)とは、x ＝ ⊥ であっても g x ≠ ⊥ となる ような 関数 g の性質のことを言います。</p>
<p>もうひとつ別の例を考えてみましょう。</p>
<pre><code>from :: Int -&gt; [Int]
from n =  n : from (n + 1)

longerThan :: Int -&gt; [a] -&gt; Bool

longerThan 0 (_:_)  = True
longerThan _ []     = False
longerThan n (x:xs) = longerThan (n-1) xs

hage :: [Int]
hage = from 0</code></pre>
<p>こんな定義をしておいて、今度は、</p>
<pre><code>longerThan 3 hage</code></pre>
<p>を評価すると何がおこりますか？</p>
<pre><code>longerThan 3 (repeat (1 `div` 0))</code></pre>
<p>ではどうでしょう？</p>
<blockquote>
<p>(2004/09/30 11:48:42 JST): ごめん。(0/0)じゃなくて(1 `div` 0)にしてく ださいな。 (0/0) だと、⊥にならなくて,NaNになっちゃう。以下の (0/0) を 全部、(1 `div` 0) に置き換えちゃいます。</p>
</blockquote>
</blockquote>
<p>うぅむ。 何を求められているか？ってのが、すんげぇポイントなのかぁ。</p>
<p>これまで未定義値を含む式は誰がなんと言おうと未定義値！ってそういう頑固 オヤジだと思ってましたよ、あたしゃ。（いや、非正格を非正確に認識してま したねぇ。まだまだブルーだわ。） んが、どうも様子が変なんだよなぁ。それを求めて（要求して）いるヤツ（な んちゅーか継続？）ってのがいて、どの辺まで突っ込んだモノを求められて （要求されて）いるか？ってのが評価されるかどうかのミソ？</p>
<p>最後の例で repeat (1 `div` 0) って式がありますなぁ。こいつは (lambda () (1 `div` 0)) って thunk を一要素として無限のリストを構成する。</p>
<p>こいつは直感的には</p>
<pre><code>[(lambda () (1 `div` 0)),(lambda () (1 `div` 0)),(lambda () (1 `div` 0))..]</code></pre>
<p>おぉっ、 Haskell と Scheme? のダブルさんだ。(^^; ま、とりあえず、こんなんだねぇ？あくまで直感的にね。こいつをトップレベ ルが求めているのだとすると (lambda () (1 `div` 0)) の 印字をするところ まで求められる。っちゅーことは、これを印字したい、印字する必要が出てき たところで _|_ か。</p>
<p>ところが、上の例で repeat (1 `div` 0) の値を求めている longerThan って やつは、そこまで突っ込んだものは欲しがってないんだ！</p>
<h3 id="型宣言をみてみよー">型宣言をみてみよー！</h3>
<p>ん、んん？・・・どあぁーーーーーっ！！！ なんかめちゃくちゃ当ったり前のことに今ごろ気付いたかもしんない。もう、 まるで巨大恐竜が足を蚊に刺されてから何分も経って、ようやく気付いて「か ゆ〜」って思う様に私の頭脳はめちゃめちゃ遅延評価です。はい。（意味がち が・・・）</p>
<pre><code>longerThan :: Int -&gt; [a] -&gt; Bool</code></pre>
<p>これ！これを見ると [a] ってのがある。これは [Int] だっていいし、 [String] だって許される。もち、 [IO ()] だって、きっと許されるだろう。 多分。単にそういう任意の型を表すという側面でしか見れて無かったです、 えぇ。(^^;</p>
<p>これって別の言いまわしをすると、 longerThan は [a] っていうリスト構造 にのみ関心があり、 リスト構造までを要求しており、リストの内部までは要 求してない っていうことでも有りますよね？そうですよね？！そうだ！そう に決まった！！！</p>
<p>もう、目が血走って、今にも犯罪犯しそうな雰囲気マンマンにコーフンしちゃっ てます。こういう時にイキオイで書いた文章が間違ってると、死ぬほどはずい です。えぇ。でも私は懲りません。全然。漢（オトコ）って感じしませんか？ そうですかしませんか。がっくり。</p>
<pre><code>longerThan :: Int -&gt; [a] -&gt; Bool</code></pre>
<p>この型宣言において、</p>
<pre><code>longerThan 3 hage
longerThan 3 (repeat (1 `div` 0))</code></pre>
<p>この二つの式は、（ hage も repeat も）ともに longerThan からは [a] ま でしか求められておらず、リスト構造さえ作って提供してくれりゃ、中に格納 されているデータが (lambda () (1 `div` 0)) だろうが、気にしな〜い気に しな〜い♪ってことだ。</p>
<p>もしも、もしもですよ？</p>
<pre><code>longerThan :: Int -&gt; [Int] -&gt; Bool
                       ↑
                     コレね</code></pre>
<p>なんて型宣言になるような関数だったら、そんな longerThan 関数から呼ばれ た repeat (1 `div` 0) は [Int] って形までを求められる。つまり、 (lambda () (1 `div` 0)) の値を評価する必要を迫られる。</p>
<pre><code>[(lambda () (1 `div` 0)),(lambda () (1 `div` 0)),(lambda () (1 `div` 0))..]</code></pre>
<p>こいつを</p>
<pre><code>[1/0の値,1/0の値,1/0の値..]</code></pre>
<p>な形にまで簡約されることを求められる。ゆえにぃ、v(^^)v 1/0 の値を求め る段で多分 _|_ を返すと。</p>
<p>んじゃ、お題に戻ると、こういう回答になるんでしょうか？</p>
<pre><code>hoge :: Int
hoge = sum [1..]</code></pre>
<p>と書いてあっても、hoge の値は必要とされているわけではありませんよね。<br>
では、ここでクイズ、hoge の値は、何時、どんな場合に必要とされるでしょう？</p>
<p>それは、 hoge を引数に持つ関数が評価される場面において、その関数の型宣 言で hoge が位置する引数の型が Int として型宣言している場合は hoge の 値は必要とされる。</p>
<p>仮に</p>
<pre><code>fuga :: a -&gt; Bool
deya :: Int -&gt; Bool</code></pre>
<p>という二種類の関数の型宣言があって、 fuga および deya の値が要求されて いる場面において、 fuga hoge とある場合には hoge はその値までは必要と はしないし、 deya hoge とある場合には hoge はその計算された値を必要と する。と。</p>
<p>もちろん、再帰的に呼び出し元にも同じ事が言えて、 deya を引数に持つもの が、 Bool を必要としてれば、その値を要求されるけど、 deya を呼んでいる のが、 deya の引数のところの型を a として宣言しているなら、deya hoge であっても hoge は値を要求されることはないと。 結局 main などのエントリポイントから a とかって型変数に行き当たったら、 そっから先は値そのものは要求されない。多分 リストだとかほにゃららモナ ドと称される様な構造にしか関心はないんじゃね？一方で、末端構成員まで具 体的な型が宣言され続けている場合には値が必要になる・・・可能性がある？ （if とかがあるんでちょっと自信なくした）のかと。</p>
<p>遡って確認すると、 isLT7 はどうなっとる？</p>
<pre><code>isLT7 :: Int -&gt; Bool
isLT7 = \ n -&gt; n &lt; 7</code></pre>
<p>これで、</p>
<pre><code>isLT7 hoge</code></pre>
<p>を評価すると、 isLT7 は引数 hoge に対して Int まで突っ込んだ情報を欲し がってる。つまり、hoge は計算された値を必要とされる。</p>
<p>・・・ってことで終了しねぇ計算がぁ〜！</p>
<blockquote>
<p>あうあうあう じゃあ、</p>
<p>dorya :: Int -&gt; Int dorya = const 1</p>
<p>と定義しておいて、</p>
<p>dorya (1 `div` 0)</p>
<p>を評価するとどうなる？</p>
</blockquote>
<p>がぁん！なにやらイキオイで書いたのが、案の定間違っとるくさいぞ？(^^; やべぇ。ネット中引き回しの上さらし首だ。</p>
<p>const ってのは多分固定値を返すんじゃないかと思うんだけど、まぁここでは あまり本質的な問題じゃないな。いちおー、 const を調べておくか。</p>
<pre><code>const          :: a -&gt; b -&gt; a
const k _       = k</code></pre>
<p>あら？引数二つ持つのか。でも第二引数はシカトしとる。</p>
<p>とにかく、引数が dorya 本体に無関係だってのがポイントなんだ。にも関わ らず、その引数の型は Int に縛られとるがな。そんな御無体な・・・(–;</p>
<p>・・・ここで dorya ってのは Int -&gt; Int ってあるけど、この型宣言は a -&gt; Int でも良さげに思えますねぇ。っつーか私の理屈だと、それなら通るんだよ なぁ。でも Int -&gt; Int となると、確かにダメだわ、こりゃ。早速、破綻しちゃ いましたねぇ。</p>
<p>デジャブったので、ずーっと上の方を見ると、</p>
<pre><code>&gt; main :: [a]
&gt; main = [1,2,3]</code></pre>
<p>ってした時にもエラーを食らってますな〜。この時私は「間違っては無い気が する」って感想を漏らしておる。</p>
<p>ここでも同じく a -&gt; Int で間違っちゃいない気がするのだが、多分 a -&gt; Int ってすると全く同じエラー食らっちゃいそうだな。とにかく試してみるか？</p>
<pre><code>&gt; dorya :: a -&gt; Int
&gt; dorya = const 1</code></pre>
<p>こうしておいて、どりゃ？！</p>
<pre><code>Main&gt; dorya (1 `div` 0)
1</code></pre>
<p>あー、そっか。 dorya の型としては a -&gt; Int でいけるんだ、 const が a -&gt; b -&gt; a だから。うん。じゃさ、じゃさー Haskell の型推論システムとし てはどうなんじゃろ。予想は多分同じじゃねーかと思うんだけどね。ってわけ で型宣言を削って例の常套手段でお伺いを立ててみる。</p>
<pre><code>Main&gt; dorya
ERROR - Cannot find "show" function for:
*** Expression : dorya
*** Of type    : a -&gt; Integer</code></pre>
<p>・・・ということは、ユーザがコードに書く型宣言て Haskell の型推論と同 じか、もしくは、それより厳しい方向には宣言可能？なんでしょか。ゆるゆる にする方向には叱られたもんねぇ。多分厳しくする分には問題ないけど、ゆる ゆるにすると、本体で足し算してるのに、ゆるゆるの隙を突いて String とか IO () とか、足し算をすることが出来ないシロモノが入って来ちゃうからかな。</p>
<p>いずれにせよ、型宣言を見て値の計算が要求されるかどうかを見分けるのは無 理なんですねぇ。</p>
<p>んじゃ、 Haskell の型推論で見たらどうなんでしょ？ Haskell の型推論がコー ド全体を解析した結果、ある関数の型の引数部分に a って型変数が残ったも のは、型を具体的に特定できなかったってことっすよね？ ・・・あれ？？、なんで特定出来なかったんだろ。(?_?;) とりあえず、その関数の評価においては、その型変数が残った引数は値を求め られず、先送りにされるんでないすかね？</p>
<p>あーでも、違うわ、こりゃ。 const ってのがまさに、それを物語っておる。</p>
<pre><code>const          :: a -&gt; b -&gt; a</code></pre>
<p>これは全部型変数だけど、</p>
<pre><code>Main&gt; const (1 `div` 0) 0

Program error: {primQrmInteger 1 0}

Main&gt;</code></pre>
<p>こんなんなります。つまり、 (1 `div` 0) の値を求めようとされてる。えぇ。 ガックリ、型変数 a だけどキッチリ値を求められることを要求されとるがな。</p>
<p>って思ったんだけど、いやいやこれってトップレベルか要求してるからじゃね？ トップレベルに印字することを要求されるからか。例えば、</p>
<pre><code>Main&gt; length [const (1 `div` 0) "cut-sea"]
1</code></pre>
<p>うむ。ここで (1 `div` 0) の値は最後まで評価されずに遅延されて、評価さ れず仕舞いだよね。結局誰も、(1 `div` 0) の値に関心を持たなかった、それ を要求しなかったからだ。 length の型は</p>
<pre><code>length           :: [a] -&gt; Int</code></pre>
<p>だしね。</p>
<p>あー違う！頭ぐるぐるんなる・・・。これって longerThan でやったのと変わっ てねーじゃん。同じトコぐぅるぐぅる回ってますよ〜いつもよりたくさん回っ てます。はい。</p>
<p>何を求められているか、何が必要かがポイントなんだった。落ち着けオレ！返 り値と引数をちゃんと区別せんといかんように思う。</p>
<pre><code>const          :: a -&gt; b -&gt; a</code></pre>
<p>ここで、 最初の a と二番目の b は引数だ。この引数の値については const は必要としないのではないかな？</p>
<p>んで、返り値の a については const 式を引数として呼び出した側の関数がど う思っているかだよね？その呼び出し側が値を求めて（要求して）れば計算さ れるし、求めて（要求して）なければ計算されずにさらに先送り。と。</p>
<p>・・・ってことは、トップレベルってどういう関数になってんだろ？これって 絶対に値を要求してるけど、型は不問だよねぇ。 まぁ考えても無駄ってか、ハマルと挫折が待ってそうなんで逃げます。はい。 あっしの脳ミソの限界はるか彼方に越えてます。</p>
<p>ただ、一応メモっておこう。 main から末端構成員に向けて調べるってのは逆 だわ。少なくとも。 末端構成員から、そいつが値を求められる(要求される)のはどこか？ってのを main なんかのエントリポイントに向かって調べることになりそう。最後まで 値の計算を先送りにされた時に行きつくのがそこだしねぇ。</p>
<blockquote>
<p>型の計算ってのは実行の前処理として行われるだけなんじゃないでしょうか。 型推論機構と評価機構は分けて考えるべきものなのでは。</p>
</blockquote>
<h3 id="型推論より厳しい型宣言の必要性">型推論より厳しい型宣言の必要性</h3>
<p>んで、結論は分かんないけど、疑問だけはどんどんでてくるわけよ。(^^; Int -&gt; Int な dorya において、引数の型チェックを Int とする事に意味が あるような、そんな場面てどんな状況だろう。そもそもあるのだろうか。</p>
<p>Haskell ではそれを許しているってことは必要だからかなぁ、やっぱ。一つ言 えることは、振舞の上で、こんな違いが生まれますなー。</p>
<pre><code>&gt; dorya :: a -&gt; Int
&gt; dorya = const 1</code></pre>
<p>でもって、</p>
<pre><code>Main&gt; dorya "cut-sea"
1</code></pre>
<p>いえーす！おっけ。じゃぁこっちね。</p>
<pre><code>&gt; dorya :: Int -&gt; Int
&gt; dorya = const 1

Main&gt; dorya "cut-sea"
ERROR - Type error in application
*** Expression     : dorya "cut-sea"
*** Term           : "cut-sea"
*** Type           : String
*** Does not match : Int</code></pre>
<p>うん。まぁそだね。なんかの入力チェックか？でも弾いても弾かなくても結果 同じ気がする。むむむ(–; そろそろコードを・・・</p>
<p>まぁ、今の私がこーゆーもろもろの疑問を抱えてるって事を未来の自分に託し ておいて、 (問題先送り、これぞ遅延評価？)そろそろコードを書かんといか んすねぇ。はい。 多分 Haskell のコードを書かないと、いつまで立っても二足歩行に行けません。</p>
<p>その前に、上でさらっと流しちゃった部分を確認しときます。 `div` っての は、ここ にあるように関数値を中置演算にするものだそうです。あ、 div が じゃなくて注目はバッククウォートで括ってるってトコです。中置演算を前置 にするのが (++) みたいにするのに対して、その逆ですね。んじゃ、早速ため してみましょう。</p>
<pre><code>Main&gt; 1 `const` 2
1</code></pre>
<p>できました。んじゃ、これはどーなんでしょ？</p>
<pre><code>Main&gt; "abc" `(++)` "xyz"
ERROR - Syntax error in expression (unexpected `(')
Main&gt; (`const`) 1 2
ERROR - Syntax error in expression (unexpected `)')</code></pre>
<p>あらら、どうも構文エラーになっちゃいますね。まぁ、そういうものみたいね。</p>
<p>あと、も一個確認してみます。なんとなく IO a 型の main において、 a は本体内にどんな影響があんのか(どんな風に現れるのか)が気になってます。</p>
<pre><code>#! /usr/pkg/bin/runhugs

&gt; main :: IO ()
&gt; main = putStrLn "んちゃ!"</code></pre>
<p>これはうまく動作しますね。んじゃ、 main を IO Int にするとどうなるんで しょうか？</p>
<pre><code>&gt; main :: IO Int
&gt; main = putStrLn "んちゃ!"

ERROR "/home/cut-sea/script/haskell/dummy.lhs":4 - Type error in explicitly typed binding
*** Term           : main
*** Type           : IO ()
*** Does not match : IO Int</code></pre>
<p>型が違うって叱られました。なんとなく、こうかなぁ？</p>
<pre><code>&gt; main :: IO Int
&gt; main = putStrLn "んちゃ!" &gt;&gt; return 123</code></pre>
<p>おー、おっけーみたいですね。じゃ、同じようにこんなんも出来そうです。</p>
<pre><code>&gt; main :: IO String
&gt; main = putStrLn "んちゃ!" &gt;&gt; return "うりゃ!"</code></pre>
<p>さらに</p>
<pre><code>&gt; main :: IO [String]
&gt; main = putStrLn "んちゃ!" &gt;&gt; return (repeat "うりゃ")</code></pre>
<p>おぉ？ return は</p>
<pre><code>return :: Monad m =&gt; a -&gt; m a</code></pre>
<p>だからいいのかな。repeat “うりゃ” 自体は値を必要としないんだね。なんか 実行前にはプロンプトに戻ってくんのか不安でしたけど。</p>
<p>さらにさらに</p>
<pre><code>&gt; main :: IO (IO Int)
&gt; main = putStrLn "んちゃ!" &gt;&gt; return child
&gt; 
&gt; child :: IO Int
&gt; child = putStrLn "ぷびー" &gt;&gt; return 0</code></pre>
<p>いや、単に IO (IO Int) を main の型にしてみたかっただけっすけど。 ここまでの所結果は全部</p>
<pre><code>Main&gt; main
んちゃ!</code></pre>
<p>って感じです。はい。いやぁ実に変わり映えしないですね。すんません。ん じゃ、これは？</p>
<pre><code>&gt; main :: IO a
&gt; main = putStrLn "んちゃ!" &gt;&gt; return child
&gt; 
&gt; child :: IO a
&gt; child = putStrLn "ぷびー" &gt;&gt; return main</code></pre>
<p>相互再帰的にしちゃろうと思ったんですけど、どうでしょう？</p>
<pre><code>ERROR "/home/cut-sea/script/haskell/dummy.lhs":7 - Inferred type is not general enough
*** Expression    : child
*** Expected type : IO a
*** Inferred type : IO (IO a)</code></pre>
<p>うーん。ダメでした。ちょっと調子に乗りすぎましたね。まぁ、いいです。 ずーっと振り返ってみると何となく分かった気がしないでもないですが、 IO () だけ return が無くてもおっけーなのがちょい気になります。</p>
<pre><code>&gt; main :: IO ()
&gt; main = putStrLn "んちゃ!" &gt;&gt; return ()</code></pre>
<p>これでイケるかな〜？まさかなぁって思ったら、</p>
<pre><code>Main&gt; main
んちゃ!</code></pre>
<p>あらら、大丈夫でした。なんか統一的に扱えるんですね。いちおー。 return ってのが生み出したものは、一体どこへ消えていくのでしょう？(?-?)</p>
<blockquote>
<p>Hugsでは、インタープリタのプロンプトに IO a 型が渡されると、対応するア クションが実行され、結果の値は無視されるようです。ただ、‘:set +I’ とす ると、結果の値が表示されるようです。 (<a href="http://cvs.haskell.org/Hugs/pages/users_guide/using-hugs.html#BASIC-COMMANDS">ここ</a>参照)</p>
</blockquote>
<p>ここまで &gt;&gt; ってやつを使ってましたが、これは例のパスを渡さない奴なんで、 右項側で好き勝手出来るんで、こうやって遊んでみるのには楽チンな感じです。 はい。</p>
<p>とにかく、 main が IO a 型なら、最終的に return a が返ればおっけーそう ですね。理解は出来てないですけど、一応押えておきます。はい。 return は</p>
<pre><code>Monad m =&gt; a -&gt; m a</code></pre>
<p>なので、どっから m が IO だと知るのかが、謎ですけどね。もし良きに計らっ てくれるんだとすれば、</p>
<pre><code>IO String
   ↓
[] String</code></pre>
<p>って置き換えても良さげですね。っちゅーわけでぇ</p>
<pre><code>&gt; main :: [] String
&gt; main = return "んちゃ!"</code></pre>
<p>んじゃ、ロード！</p>
<pre><code>Main&gt; main
["\164\243\164\193\164\227!"]</code></pre>
<p>いいですね。</p>
<pre><code>&gt; main :: [String]
&gt; main = return "んちゃ!"</code></pre>
<p>上のはこれと同じですんで、 return ってのは、モナドのインスタンスを作っ てるようなものってことでしょうか？そうだとすると、どんなプログラムも取 り合えず return 使って終端すりゃー万事おっけーですかい？</p>
<p>でも、String のリストを作るのかと思ったら、</p>
<pre><code>&gt; main :: [String]
&gt; main = return "んちゃ!" "ぷぽ?"</code></pre>
<p>えい！</p>
<pre><code>ERROR "/home/cut-sea/script/haskell/dummy.lhs":4 - Type error in explicitly typed binding
*** Term           : main
*** Type           : [Char]
*** Does not match : [String]</code></pre>
<p>型から言えば当然ですけど、さすがに [“んちゃ!”,“ぷぽ?”] を作ってくれる わけでは無いんすねぇ。(–; うーむ、 return って一体・・・</p>
<blockquote>
<p>リストがモナドである事を示すために定義されているのでしょう。 一応、<a href="http://www.sampou.org/haskell/tutorial-j/monads.html">ここ</a>にリストのreturnの使用例があります</p>
</blockquote>
<h3 id="たらいまわし関数">たらいまわし関数</h3>
<p>えーっと、たらいまわし関数を作って結果を印字させるプログラムを組んでみ ます。なんせ、たらいまわし関数なら LL 中、 まぁ<strong>最速</strong>じゃねぇ？と言われ ている位です。たらいまわし関数を計算するコマンドは、やはり Haskell で 実装すべきでしょ。 それ以外考えられません。はい。 え？一体何に使うのかって？そんなちっちぇコト気にしちゃダメっす。もっと おーっきな目で見ないとね、おーっきな目で。</p>
<p>もち、現時点でホントに私の手元には影も形もありません。内容的にはそれほ ど難しいとは思ってないのですが、ここまでで出て来なかった関数なんかも必 要になりそうな気がしてます。</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="b5d6c0c198c6d0d4f5dfdcdbdc">[email&nbsp;protected]</a>&gt; tak 12 6 0</code></pre>
<p>みたいにコマンドラインから実行出来るようにしたいと思っているので、真っ 先に、どうやるんだろ？って浮かぶ課題が、</p>
<ol type="1">
<li>引数は文字列で渡されるので、こいつを数値に変換</li>
<li>計算した数値を文字列にして、結果を印字</li>
</ol>
<p>この二点です。で、「やさしいHaskell入門」とかを斜め読みしてると、まぁ た横道それるんだけど、 <a href="http://www.sampou.org/haskell/tutorial-j/io.html">ここ</a>に「アクションは Haskellの値です」って書い てある。ってことは、理詰めで導いたのは正しくて、私のゴーストのささやき （要はカンね）の方が間違ってたらしい。まさに「自分のゴーストが信じられ ない」状態に。うますぎ(^^; ちなみにすぐ横道にそれたり、どんどんスタック積み上げまくって本筋に戻っ て来れずにオーバーフローするのは私の特技だったりします。しかもスタック の上限が異常に浅いです。はい。</p>
<p>おっとっと、いかんいかん！目的をすぐ見失いそうになります。数値を文字列 に変換したり、文字列を数値に変換するんだった。</p>
<p>えーっとー。・・・結構探したけどそれっぽいのが見当たらないっす。まぁい いです。何事も勉強です。 digitToInt とか intToDigit ってのが <a href="http://www.sampou.org/haskell/report-revised-j/char.html">ここ</a>にあっ て、型からして、使えそうなんで試してみましょう。</p>
<pre><code>Main&gt; digitToInt '7'
7
Main&gt; digitToInt '9'
9</code></pre>
<p>はい、まずはこれが文字列から数値に変換する時に使えそうな気がします。</p>
<pre><code>Main&gt; intToDigit 7
'7'
Main&gt; intToDigit 9
'9'</code></pre>
<p>これが、数値から文字列を作るのに使えそうな感じなんですけど、あまりにも 遠そうですんで、もしかしたら作ってるうちに使えそうな関数に出会えるのを 期待することにします。まぁ、こいつはキープってことで。</p>
<p>無謀ですけど、まず型宣言を書いてみましょう。実際に Haskeller な方がど ういう感じでコーディングするのかは、リアルタイムで見たことが無いのでど ういう順かは知りませんが、多分、型から入るんじゃないかなぁと思ったって ことでチャレンジ！</p>
<p>まず、main です。とりあえず、印字だけさせようと思います。 return も書 かないつもり。</p>
<pre><code>main :: IO ()</code></pre>
<p>main 内では putStrLn とかを使って書こうと思います。したがって、 putStrLn に渡すたらいまわし関数の返り値を文字列に変換する必要があるん で、その関数は整数から文字列への関数になると。</p>
<pre><code>numberToStr :: Int -&gt; String</code></pre>
<p>あ、その前に getArgs から貰った引数の文字列を整数に変換する関数が要りますな。</p>
<pre><code>strToNumber :: String -&gt; Int</code></pre>
<p>んで、このコマンドのまさに核部分です。言わずと知れた超有名な関数です。 ちなみに tak 関数とかたらいまわし関数とか色々言われるみたいなんですけ ど、正式にはどうなんですかね？まぁ、引数に整数を三つ貰って、んでから返 り値も整数です。</p>
<pre><code>tak :: Int -&gt; Int -&gt; Int -&gt; Int</code></pre>
<p>こんなとこでしょうか？あと必要になったら、気付いた時点で追加することにします。</p>
<p>んじゃ、まず文字列を整数に変換してみます。</p>
<pre><code>Prelude&gt; map digitToInt "123"
[1,2,3]</code></pre>
<p>map に関しては実は mapM だの mapM_ だのを見てたので、どーしよーかと思っ たんですが、小細工なしで map でいったれ！ってやってみたら、すんなり動 いてくれちゃいました。</p>
<p>んじゃ、[1,2,3] とかってなったリストを各桁と見なした複数桁の数値にします。</p>
<pre><code>Prelude&gt; foldl1 (\x y -&gt; 10*x+y) [1,2,3]
123</code></pre>
<p>わーい、意外とすんなりいきました。ちょっと飲み会の後で少しアルデヒドが 脳細胞に刺激を与えている位が丁度いいのかもしれません。このすんなり具合 は中毒症状では無いので大丈夫(^^)v</p>
<p>んじゃ、strToNumber を作ります。</p>
<pre><code>#!/usr/pkg/bin/runhugs

\begin{code}

main :: IO ()

numberToStr :: Int -&gt; String

strToNumber :: String -&gt; Int
strToNumber str = foldl1 (\x y-&gt;10*x+y) $ map digitToInt str

tak :: Int -&gt; Int -&gt; Int -&gt; Int

\end{code}</code></pre>
<p>これでロードしてみます。</p>
<pre><code>Reading file "/home/cut-sea/script/haskell/tak.lhs":
Parsing........................................................................
ERROR "/home/cut-sea/script/haskell/tak.lhs":5 - Missing binding for variable "main" in type signature</code></pre>
<p>ありゃ？えーっと、なになに？ main 変数に束縛がねーぞって叱ってる。あー、 本体の定義後まわしにしようと思ったんだけど、ダメなんだぁ。残念。</p>
<p>んじゃ、</p>
<pre><code>#!/usr/pkg/bin/runhugs

main :: IO ()

numberToStr :: Int -&gt; String

\begin{code}

strToNumber :: String -&gt; Int
strToNumber str = foldl1 (\x y-&gt;10*x+y) $ map digitToInt str

\end{code}

tak :: Int -&gt; Int -&gt; Int -&gt; Int</code></pre>
<p>こんな感じになるかな？んで、走れ！</p>
<pre><code>Main&gt; strToNumber "123"
123</code></pre>
<p>いぇーい！！d(^-^)b いや、感心してないで次いきましょう。 numberToStr です。</p>
<pre><code>numberToStr :: Int -&gt; String
numberToStr num = do (q,r) &lt;- (quotRem num 10)
                     (numberToStr q) ++ [intToDigit r]</code></pre>
<p>パターンなんぞをタプルに適用してみました。いや、使えるのかどうか知らん けどね。これでいけんじゃね？えいやー！</p>
<pre><code>Type checking
ERROR "/home/cut-sea/script/haskell/tak.lhs":13 - Type error in generator
*** Term           : (q,r)
*** Type           : (a,b)
*** Does not match : Int</code></pre>
<p>うがっ？なんだこれ？</p>
<pre><code>quotRem :: Integral a =&gt; a -&gt; a -&gt; (a, a)</code></pre>
<p>ってある。なんか Integral が意味分からんが、 (a, a) を返している。問題 は上のエラーメッセージ中で (a, b) って出ているところ。んーと、んじゃ、 これはどうよ？</p>
<pre><code>numberToStr :: Int -&gt; String
numberToStr num = do q &lt;- quot num 10
                     r &lt;- rem num 10
                     if (q == 0) then [intToDigit r]
                                 else (numberToStr q) ++ [intToDigit r]</code></pre>
<p>タプルをパターンにするのがダメだったのかもしれんと思ったわけだ。ほれ！</p>
<pre><code>Type checking
ERROR "/home/cut-sea/script/haskell/tak.lhs":13 - Type error in generator
*** Term           : num `quot` 10
*** Type           : Int
*** Does not match : a b</code></pre>
<p>あ？だめだこりゃ。 <a href="http://www.sampou.org/haskell/report-revised-j/exps.html#sect3.14">これ</a>見てもどうも何が悪いのかよくわかんねぇっす。はい。</p>
<blockquote>
<p>doはモナド専用なので、 <a href="http://www.sampou.org/haskell/tutorial-j/patterns.html">let,where</a>を使いましょう</p>
</blockquote>
<p>・・・・・・・・・・・・・・・・・・・・・・・・おっと、ついのめり込ん でしまっちゃって実況中継忘れた。もう意地で do にこだわったんだけど、全 然型が通らない。押してダメなら引いてみなってことで、もちっと簡単にして みる。</p>
<pre><code>numberToStr :: Int -&gt; String
numberToStr num = if (num &lt; 10)
                  then [intToDigit num]
                  else (numberToStr $ quot num 10) ++ [intToDigit $ rem num 10]</code></pre>
<p>こいつでどーだっ！！</p>
<pre><code>Main&gt; numberToStr 123
"123"
Main&gt; numberToStr 987654321
"987654321"</code></pre>
<p>ほっ。よっしゃ！何とかいけたね。</p>
<p>んじゃ、 tak 関数を作ってみます。えーっと、私のずたぼろの「はじめての 人のためのLISP」を見ます。私を S式の世界にいざなってくれた真っ赤なハレ ンチ本です。</p>
<pre><code>tak :: Int -&gt; Int -&gt; Int -&gt; Int
tak x y z = if (x &gt; y) then tak (tak (x-1) y z)
                                (tak (y-1) z x)
                                (tak (z-1) x y)
                       else y

んで、ロード！

Main&gt; tak 6 3 0
6
Main&gt; tak 8 4 0
8
Main&gt; tak 10 5 0
10
Main&gt; tak 12 6 0
12
Main&gt; tak 100 50 0
100
Main&gt; tak 200 100 0
200</code></pre>
<p>うーっむ、定義を間違ってねーか？って思うくらい異常に早いです。信じらん 無いくらい。ボーゼンとしてしまいます。</p>
<p>えっと、残るは main だけ？よしゃ。その前にだいたいの流れを確認。</p>
<pre><code>Main&gt; map (strToNumber) ["200","100","0"]
[200,100,0]</code></pre>
<p>こいつに tak を適用すりゃいいだけ！うわ (^^) 取ったもドーゼン！！へへへ〜 ・・・あら？リストの各要素に適用しないとダメじゃん。しまった、どしよ。</p>
<p>とりあえず、 Scheme? とかだと apply とかってのを使う方向に考えるんだけど、 :find apply とかしても出て来ない。しょーがないから、急遽関数を作ることにしましょう。</p>
<pre><code>apply f [x,y,z] = f x y z</code></pre>
<p>こんなんアリ？だいたい型はどーなるんだよ？</p>
<pre><code>Main&gt; map (strToNumber) ["200","100","0"]
[200,100,0]
Main&gt; apply tak [200,100,0]
200</code></pre>
<p>おぉっ！動くじゃん。すげえすげえ。じゃあ例の常套手段を使って〜って、今回は違うぞ！一応型を自分で作ってみよう。</p>
<pre><code>apply :: (tak の型) -&gt; [a] -&gt; a</code></pre>
<p>かな？ってーことは、</p>
<pre><code>apply :: (Int -&gt; Int -&gt; Int -&gt; Int) -&gt; [a] -&gt; a</code></pre>
<p>え、違うわ、 全部 Int かな。</p>
<pre><code>apply :: (Int -&gt; Int -&gt; Int -&gt; Int) -&gt; [Int] -&gt; Int</code></pre>
<p>んでロードだ。</p>
<pre><code>Main&gt; apply (tak) [100,50,0]
100</code></pre>
<p>おっけー！もー得意気になっちゃうよ！天狗天狗！！</p>
<p>一応 Haskell の型推論を確認すっと、</p>
<pre><code>Main&gt; apply
ERROR - Cannot find "show" function for:
*** Expression : apply
*** Of type    : (a -&gt; a -&gt; a -&gt; b) -&gt; [a] -&gt; b</code></pre>
<p>あらら。めちゃめちゃ応用範囲広いじゃん。オレってばすんげぇ apply の活 用を絞りすぎた。やっぱ難しいなぁ。型宣言するのが良いのって、ある程度プ ログラマの方も型推論がしっかり出来なきゃあまり意味無いって思うのオイラ だけっすか？ どーも、具体例が頭にあるだけについ絞っちゃうんだよね。型宣言するときに、 具体的に考えている使い方以上に抽象化して考えないと、実際には Haskell の型推論レベルのものが得られない気がする。</p>
<pre><code>import System

main :: IO ()
main = do args &lt;- getArgs
          putStr $ numberToStr $ apply (tak) $ map (strToNumber) args</code></pre>
<p>こんなんですね。えっと、ロードがうまくいくんでファイルに実行権限つけて コマンドラインから実行！</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="6a091f1e47190f0b2a00030403">[email&nbsp;protected]</a>&gt; ./tak.lhs 6 3 0
<a href="email-protection.html" class="__cf_email__" data-cfemail="af99ccdadb82dccaceefc5c6c1c6">[email&nbsp;protected]</a>&gt;</code></pre>
<p>あ、そっか。 putStr じゃなくて putStrLn の方がいいか。 んで、書き換えたんでコード全体はこんな感じになります。</p>
<pre><code>#!/usr/pkg/bin/runhugs

\begin{code}

import System

main :: IO ()
main = do args &lt;- getArgs
          putStrLn $ numberToStr $ apply (tak) $ map (strToNumber) args

apply :: (a -&gt; a -&gt; a -&gt; b) -&gt; [a] -&gt; b
apply f [x,y,z] = f x y z

numberToStr :: Int -&gt; String
numberToStr num = if (num &lt; 10)
                  then [intToDigit num]
                  else (numberToStr $ quot num 10) ++ [intToDigit $ rem num 10]

strToNumber :: String -&gt; Int
strToNumber str = foldl1 (\x y-&gt;10*x+y) $ map digitToInt str

tak :: Int -&gt; Int -&gt; Int -&gt; Int
tak x y z = if (x &gt; y) then tak (tak (x-1) y z)
                                (tak (y-1) z x)
                                (tak (z-1) x y)
                       else y

\end{code}</code></pre>
<p>実行例じゃー。</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="d4b7a1a0f9a7b1b594bebdbabd">[email&nbsp;protected]</a>&gt; ./tak.lhs 6 3 0
6
<a href="email-protection.html" class="__cf_email__" data-cfemail="c7a4b2b3eab4a2a687adaea9ae">[email&nbsp;protected]</a>&gt; ./tak.lhs 100 50 0
100
<a href="email-protection.html" class="__cf_email__" data-cfemail="593a2c2d742a3c381933303730">[email&nbsp;protected]</a>&gt; ./tak.lhs 200 100 0
200
<a href="email-protection.html" class="__cf_email__" data-cfemail="066573722b756367466c6f686f">[email&nbsp;protected]</a>&gt; ./tak.lhs 300 150 0
300
<a href="email-protection.html" class="__cf_email__" data-cfemail="e7849293ca948286a78d8e898e">[email&nbsp;protected]</a>&gt; ./tak.lhs 400 200 0
400</code></pre>
<p>よしゃ！すばらしい！！オレってすげぇ！！ んじゃ、引続きこのコードを他にも書き換えられねぇか少し遊んでみよう。</p>
<p>しかし、やっぱはえぇっ！！ 400 200 0 って与えた時はさすがに回答まで一 呼吸置くんだけど全然待たされてる気がしない。同一マシンで Emacs Lisp で の 12 6 0 を評価した時は、カップラーメンが作れちゃったくらいでしたよ？ しかもかなりふやけてしまってスカスカになってたし。いや、そこまで律義に 待つオイラもどーかと思うけどさ。</p>
<blockquote>
<pre><code>#!/usr/local/bin/runhugs
\begin{code}
module Main where
import System
import IO
main :: IO ()
main = do args &lt;- getArgs
          case args of 
            x:y:z:_ -&gt; print $ tarai (read x) (read y) (read z)
            _       -&gt; hPutStr stderr usage
usage :: String
usage = "Usage: tarai x y z"

tarai :: Int -&gt; Int -&gt; Int -&gt; Int
tarai x y z | x &lt;= y    = y
            | otherwise = tarai (tarai (x-1) y z)

                                (tarai (y-1) z x)
                                (tarai (z-1) x y)
\end{code}</code></pre>
</blockquote>
<p>おぉっ、引数チェックの様なものを入れたいと思ってたとこ。いくつか確認し たいので自分のコードをいじくる前にちょい見てみる。まず、大幅に楽チンに 済ませているのが read と print ですな。</p>
<p>んーっと :find read ってすると、なんだかごちゃごちゃしてるんだよな。芋 づる式でぐちゃぐちゃ readHogeってのが出てくるんすよ。マニュアル類を見 ていると ここに read ってのと show ってのが出てくるなぁ。ふむふむ。ど うやら型だの型クラスだのを少しかじっておいた方が良さげな感じ。</p>
<p>でもいきなり意味不明用語連発で死にたくなってくる。少しもどって、ちまち まやってみよう。 カタにハメてやろうか</p>
<p>さらに戻ってみると、 Color って型を定義してます。 んが、イマイチよう分からん。まぁ、よく理解できない時にはHaskellとお話 をして反応をうかがうんです。</p>
<pre><code>data Color = Red | Blue | Green
isColor :: Color-&gt;Bool
isColor c = case c of
              Red -&gt; True
              Blue -&gt; True
              Green -&gt; True
              _ -&gt; False</code></pre>
<p>んで、遊んでみましょう。</p>
<pre><code>Main&gt; :e color.hs
Main&gt; isColor Red
True
Main&gt; isColor 123
ERROR - Cannot infer instance
*** Instance   : Num Color
*** Expression : isColor 123

Main&gt; isColor "Red"
ERROR - Type error in application
*** Expression     : isColor "Red"
*** Term           : "Red"
*** Type           : String
*** Does not match : Color

Main&gt; isColor Yellow
ERROR - Undefined constructor function "Yellow"

Main&gt; Red == Red
ERROR - Cannot infer instance
*** Instance   : Eq Color
*** Expression : Red == Red</code></pre>
<p>ふむ。なんとも面白いのは Red だの Blue だの Green だのってリテラルが data Color の右辺、つまりデータ構築子として出現しただけで、存在しちゃ うってこと。 C の enum なんかと同じみたいなんだけど、これってScheme?で 言えばどういうこと？敢えて書くとするとこんな感じでシンボル自身を指すシ ンボルを作るって感じだろうか？</p>
<pre><code>(define Color '(Red Blue Green))
(define Red 'Red)
(define Blue 'Blue)
(define Green 'Green)
(define (isColor c) (if (memq c Color) #t #f))</code></pre>
<p>と思ったら、</p>
<pre><code>Main&gt; Red
ERROR - Cannot find "show" function for:
*** Expression : Red
*** Of type    : Color</code></pre>
<p>あー、 show クラスじゃないから印字表現がねぇよって言われます。つまり、</p>
<pre><code>(define Red 'Red)
(define Blue 'Blue)
(define Green 'Green)</code></pre>
<p>ってトコまではやりすぎかな。まぁ全然内部でやってることは違うくさいけど。 どうも、RedとかBlueとかGreenとかってシンボルをColorってグループの一員 としてインターンしているって感じだろう。とりあえず、そう思ってみる。</p>
<p>んじゃ、お次は show クラスってやつだね。でも、つらつら見ててやっぱりキ ビシー！！いや、一部が分からない分にはいいんです。えぇ、大半が分からな いと気持ちが萎えます。</p>
<p>それでもケナゲに <a href="http://www.sampou.org/haskell/tutorial-j/stdclasses.html">ここ</a>の導出されたインスタンスを見て、deriving ってな単 語に遭遇！わおっ。由来するとかって意味？しかもクラスっぽいのを継承して ますよ〜って電波をバシバシ感じます。</p>
<pre><code>data  Tree a            =  Leaf a | Branch (Tree a) (Tree a)  deriving Eq</code></pre>
<p>こーゆーとこに(^^) ちゅーわけで、</p>
<pre><code>data Color = Red | Blue | Green deriving (Eq, Show)</code></pre>
<p>これならどーよ！じゃじゃじゃーん！！</p>
<pre><code>Main&gt; Red
Red
Main&gt; Green
Green
Main&gt; Blue
Blue</code></pre>
<p>やたっ。正解じゃん。なんかそれっぽいのを継承したみたいっす。 でまぁ、 Eq ってクラスも継承してるつもりなんで、</p>
<pre><code>Main&gt; Red == Red
True
Main&gt; Red == Blue
False
Main&gt; Red == 123
ERROR - Cannot infer instance
*** Instance   : Num Color
*** Expression : Red == 123</code></pre>
<p>ってなワケでさっきは叱られた == なんかも適用可能と。クラスってのは他の 言語でいうクラスと同じようなもんなんでしょう。適用可能なメソッドとかも そのレベルで持っていると思われる。</p>
<p>・・・えーっ？そーいや、ずっと型がクラスみたいなもんかと思ってたぞ。(^^; そうか、違うのか。んー(-"-)</p>
<blockquote>
<p>Haskell でのクラスとほかの言語でのクラスの意味が違うだけでしょう。 Java と比較するとこんなかんじ。</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align:left">Haskell</td>
<td style="text-align:left">Java</td>
</tr>
<tr class="even">
<td style="text-align:left">クラス</td>
<td style="text-align:left">インターフェイス</td>
</tr>
<tr class="odd">
<td style="text-align:left">インスタンス</td>
<td style="text-align:left">(型) クラス</td>
</tr>
<tr class="even">
<td style="text-align:left">値</td>
<td style="text-align:left">インスタンス(オブジェクト)</td>
</tr>
</tbody>
</table>
<p>まーいーや、show クラスってのがなんか見えてきた。多分関数なんかも show クラスを継承させられると、Scheme?みたく関数だけを入力してやるとエラー じゃなくてそれっぽい印字名で見えてくるんだろう。しかし、さっきはどう表 示するのか指定しなかったのによきに計らってくれたな。関数とかだとどう指 定するんだろうね。</p>
</blockquote>
<p>じゃあ引き続き、read クラスに行ってみようか。</p>
<pre><code>Main&gt; read
ERROR - Unresolved overloading
*** Type       : Read a =&gt; String -&gt; a
*** Expression : read</code></pre>
<p>って感じになってますな。 Read a ってのが List a ってのや IO a ってのと 似た様に a をなんかでくるんでるモノってやつです。</p>
<blockquote>
<p>Read a は、型 a がクラス Read のインスタンスでなければならない、という 制約です。 <a href="http://www.sampou.org/haskell/tutorial-j/classes.html">ここ</a>参照</p>
</blockquote>
<pre><code>Main&gt; read "123"
ERROR - Unresolved overloading
*** Type       : Read a =&gt; a
*** Expression : read "123"

Main&gt; read "Hello"
ERROR - Unresolved overloading
*** Type       : Read a =&gt; a
*** Expression : read "Hello"</code></pre>
<p>んー、どうもトップレベルは Read a ってやつの印字表現が分からず困ってる んでしょうか。そのままでは使えない感じです。でも、</p>
<pre><code>Main&gt; (read "123") + (read "456")
579 </code></pre>
<p>ってのは動作してくれますねぇ。どういうこったろ。</p>
<pre><code>Main&gt; (read "Hello") ++ (read "World")
ERROR - Unresolved overloading
*** Type       : Read a =&gt; [a]
*** Expression : read "Hello" ++ read "World"</code></pre>
<p>って感じでだめだしさぁ。(–;</p>
<p>ちゅうわけで再度<a href="http://www.sampou.org/haskell/tutorial-j/stdclasses.html">この辺</a>を読んでみます。さっきより若干なりとも触った経験があるので、少しは読めるようになってんじゃない？っていうとっても甘い考えです。</p>
<pre><code>Read クラスには、その値を表現する文字列を構文解析する演算が用意されています。
Show クラスの最も単純な関数は show です。</code></pre>
<p>だそうですね。これってあるデータオブジェクトの印字表現をXとするような データオブジェクトxがあったら、Read X により x を作りますよってことか な。だとすると、read “Hello” ってのはまずくて、 read “\”Hello\"" って しないとだね。</p>
<pre><code>Main&gt; read "\"Hello\""
ERROR - Unresolved overloading
*** Type       : Read a =&gt; a
*** Expression : read "\"Hello\""</code></pre>
<p>は？もしかして受取り側がいるのかな。</p>
<pre><code>Main&gt; putStrLn $ read "\"Hello\""
Hello</code></pre>
<p>うむ。どうもそうみたいね。では、 ++ に渡してみましょう。えいや！</p>
<pre><code>Main&gt; (read "\"Hello\"") ++ (read "\"World\"")
ERROR - Unresolved overloading
*** Type       : Read a =&gt; [a]
*** Expression : read "\"Hello\"" ++ read "\"World\""</code></pre>
<p>あ、そっかすぐ忘れる。これでどーよ？</p>
<pre><code>Main&gt; putStrLn $ (read "\"Hello,\"") ++ (read "\"World\"")
Hello,World</code></pre>
<p>おおーっ、ぱちぱちぱち。</p>
<blockquote>
<pre><code>Main&gt; (read "123")::Int
123
Main&gt; (read "\"123\"")::String
"123"
Main&gt; (read "\"Hello, \"" ++ read "\"World!\"")::String
"Hello, World!"</code></pre>
</blockquote>
<p>お？何やら神のお告げによると、値の型を指定出来ちゃうんだ？んー、 :: っ て一体・・・？(+_+) Cで言えば強制的に値をキャストするようなもんだろか。</p>
<blockquote>
<p>型を指定するというよりは、型推論とプログラマの意志の突き合わせができるという感じかなあ。</p>
</blockquote>
<pre><code>Main&gt; ((read "123")::Int) + ((read "456")::Int)
579
Main&gt; ((read "\"123\"")::String) ++ ((read "\"456\"")::String)
"123456"</code></pre>
<p>うむ。これで所望の型に指定できちゃうわけね。なかなか便利じゃん。これ。</p>
<blockquote>
<p>Main&gt; read “\”Hello,\"" ++ " " ++ read “\”World!\"" “Hello, World!” Main&gt; let x = read “123” in x + 0 123 Main&gt; (\ x -&gt; x + 0) (read “123”) 123 Main&gt; read “123” `asTypeOf` length [1..] 123</p>
</blockquote>
<p>ほう。</p>
<pre><code>Main&gt; let x = read "123" in x + 0
123</code></pre>
<p>これ見た瞬間に awk の var "" とか var+0 とか思い出してしまった。どうも 周囲の型とつき合わせて、 辻褄が合うような解釈が可能なら、そういう型だ と解釈してくれる って感じかなあ。 でも、そうするってーと、</p>
<pre><code>Main&gt; (read "\"Hello\"") ++ (read "\"World\"")
ERROR - Unresolved overloading
*** Type       : Read a =&gt; [a]
*** Expression : read "\"Hello\"" ++ read "\"World\""</code></pre>
<p>これと</p>
<pre><code>Main&gt; read "\"Hello,\"" ++ " " ++ read "\"World!\""
"Hello, World!"</code></pre>
<p>これの差がわかんないね。なんで上のはエラーが発生しちゃったんだろ。(?_?) " " ってやつは空白文字１文字を含むリストだな。ん？もしかして read “\”Hello\"" は [a] であって a = Char までは解決してくんないのか。あー はいはい。 ++ はあくまでリスト同士をつなぐだけだからこいつは、中に格納 されている要素が ‘H’ だとか ‘e’ だとか評価せずに [a] ってリスト構造を そのまんま返すんだ。</p>
<p>・・・いやいや、やっぱ納得できてないや。そいつを受け取ったトップレベル は印字できねぇの？印字しようとして値を求めた瞬間に具体的に “Hello,World” って分かるはずだよね。んむむ〜。</p>
<p>とにかく " " ってのが具体的にリスト内の型を特定するのに役立っているん だろうけど、どうにも釈然としないぞ。順を追ってみようか。</p>
<pre><code>Main&gt; (read "\"Hello\"") ++ (read "\"World\"")</code></pre>
<p>ここで “\”Hello\"" ってのは [‘"’,‘H’,‘e’,‘l’,‘l’,‘o’,‘"’] だよね。こい つに read を apply すると read 自身は String-&gt;a (但し a は Read a) だ から、 “\”Hello\""自体が String ってのはいいんだ。こいつが Read a って のを返すんだな。あー、こいつに ++ を apply しようとしたってダメなんか？ ++ は [b] と [b] とを引数にとるわけだから、 Read a なんてリストじゃな いものを渡したらそりゃ怒るわ。カンカンですわ。そっかトップレベルが印字 できねぇって怒ってるんじゃなかったのか?もしかして。</p>
<p>んじゃ、オッケーな方を検証してみようでないの。</p>
<pre><code>Main&gt; read "\"Hello,\"" ++ " " ++ read "\"World!\""</code></pre>
<p>これは read “\”Hello,\"" ってした結果 Read a な a が得られるよ、と。 " " については [Char] だね。そうすっと ++ は [b]-&gt;[b]-&gt;[b] だから [b]-&gt;[Char]-&gt;[b] で b = Char だと。んで、 Read a な a は [b] なわけだ から a = [Char] だとみなされる？あーやっぱ awk の var "" を連想します ね。私は。</p>
<p>もっかいダメダメな方を考えると (read “\”Hello\"“) ++ (read”\“World\”") は a ++ a （但し a は Read a）なんだけど、 ++ 自体は確か に [b]-&gt;[b]-&gt;[b] だから a はリストだとはみなしてくれるのかもしれない なぁ。ありゃ？(^^; だったら、やっぱリストとして ++ をしてくれて、トップレベルが印字しよう と評価した瞬間に String だと分かるんで無いか？やっぱダメじゃん。理解で きてねーじゃん。うぁぁああ。(+,+;;</p>
<ol type="1">
<li>read “Hello” てしたら多分 Hello ってのを内部にもった Read オブジェクトを作るんだよね？</li>
<li>read “\”Hello\"" ってしたら “Hello” ってのを内部にもった Read オブジェクトを作るんだろう。</li>
<li>read “123” ってしたら 123 を内部にもつ Read オブジェクトを作るだろうし、</li>
<li>read “\”123\"" なら “123” ってのを内部にもった Read オブジェクトを作るはず。</li>
</ol>
<p>仮に read が Scheme? で言うところの read-from-string 的なものだとすれ ば、 1番目のやつはシンボルHelloなオブジェクトを作り出すだろう。 2番目 と4番目は文字列オブジェクトを作るし、 3番目のだと数値データオブジェク トを作るはず。</p>
<p>ただ、Haskellだとreadが返す時点では、まだシンボルだとか数値だとか文字 列だとかってのは分かってないんじゃないかと思うのだ。別に根拠ねーんだけ どさ。</p>
<blockquote>
<p>shiro: たぶん、「ここで帰って来る値はこういうオブジェクト」という考え方をしない方がいいんじゃないかと思います。Schemeなんかだと、実際にメモリ上にある型タグ付きのオブジェクトに触っている感触がありますが、 Haskellの場合、実行前に型推論が解決してるので、実行時にオブジェクトの型を見る必要は無い。「何かを中に持つReadオブジェクト」なんて存在しないんですよ。実行時にはreadが何の型を返すかは既に決まっていて、それを実行時に判断する必要はない。ただ、そのためには、readが何の型を返すかがコンパイル時にわかってないとならないってわけです。</p>
</blockquote>
<p>へぇっ。最初よくわからなかったんだけど、何度か反芻してるうちにようやく ウンウン！て激しくヘッドバンキング！ くくぅ！年も考えずに変なコトしたから首の筋痛めたくさい・・・。osz</p>
<p>そっか。型推論と評価は完全に分離したフェーズなんだ。だから型推論してい るフェーズ（段階）では、値を求めた結果として分かる様な具体的な型っての は分からないよと。型推論の段階で決め切れなかった結果、 showメソッドが ないねぇって思われたらジエンドっすね？</p>
<p>ってことはだ、</p>
<pre><code>Main&gt; read "\"Hello,\"" ++ " " ++ read "\"World!\""</code></pre>
<p>ここで " " をはさむって行為は ::[Char] って感じで型を指定（プログラマ の意図とすり合わせる？）のと同じ意味を持つんだ。もちろん、ここでは実際 に空白文字を一文字挟んじゃうわけだけど。</p>
<p>とか何とか思ってたら、<a href="Lazy.html" class="uri" title="Go to wiki page">Lazy</a>ってページに遅延評価についても、いろいろ解説 されてるようだよ。実にタイムリー！ってかオイラの理解が一向に好転しない んで見かねて解説はじめてくれちゃったか？</p>
<p>ふむふむと分かった気になるかと思ったが、また新たな敵（味方？）が・・・ WHNF? ってなんや〜！！</p>
<p>ってわけで google に教えてもらったら、haskell-jp の豊福さんのスレッド に遭遇。ふむふむ。やっぱ同じようなとこで同じような疑問を持つんだよなぁ と感心。しかしやはり WHNFってほとんど断りなく使ってるな。 Weak Head Normal Formってのか?なんのこったか分からんが[Lazy]には、</p>
<pre><code>WHNF というのは、乱暴にいうと一番外側(の一番左)に
データコンストラクタが出てきた形、または、 λが出てきた形です。</code></pre>
<p>だそうだ。この一番外の一番左ってのは、後続の具体例を読まないとイマイチ 釈然としなかったんだが、引数ってわけでもなさそうね。 show (1+1) だと show ってのがそうらしい。そいつが WHNF? になるまでは評価（簡約？）され るんだと。</p>
<p>うーむ。いろいろ出てきて自分が立っているところが分からなくなってきたよ。ガク。</p>
<p>ただ、haskell-jp のスレッドの<a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/haskell/haskell-jp/181">Nothing</a>と<a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/haskell/haskell-jp/181">putChar</a>のあたりをざーっと読ん で、<a href="Lazy.html" class="uri" title="Go to wiki page">Lazy</a>もふんがーって読むと、</p>
<pre><code>Prelude&gt; 1 + 1</code></pre>
<p>を入力すると、show (1 + 1)を「評価をする」というのが 出発点と考えられるわけです。</p>
<p>ってのが、知りたかったとこかもしれん。実質 show は print から必要とさ れているんで、段階を踏むんだけどさ。この show ってやつが、ここずーーーっ と引っ掛かってる部分なわけだったんだ。</p>
<p>とりあえず、確認のため :find print ってしてみると、</p>
<pre><code>print     :: Show a =&gt; a -&gt; IO ()
print      = putStrLn . show</code></pre>
<p>ふむ。show して文字列にしてから putStrLn に渡すと。</p>
<p>あ、あとさっきの haskell-jp の話題でおぉっってのは「トップレベルのロジッ クはフツーに read-eval-print-loop だよ〜」ってとこ。但し eval はクセモ ノだけど。</p>
<p>その辺を気にかけながら、read とか show を使ってもっかい Haskell と対話 してみようか。</p>
<pre><code>Main&gt; show $ putStr "Hello"
"&lt;&lt;IO action&gt;&gt;"

Main&gt; show [putStr "Hello",putStr "World"]
"[&lt;&lt;IO action&gt;&gt;,&lt;&lt;IO action&gt;&gt;]"</code></pre>
<p>まずは噂の &lt;&lt;IO action&gt;&gt; を拝んでおこう。 putStr “Hello” は印字までは 実行せずとも WHNF? ってやつになるらしく、 “Hello” とは印字せず、そうす る IO 型のオブジェクトになる。そいつを show に渡したら一応 show クラス らしくて印字表現があるため、 (っつっても &lt;&lt;IO action&gt;&gt; だけだけど)って のを印字すると。二番目の例だと show が適用される段階では [IO a] だって ことなんだろうな。</p>
<pre><code>Main&gt; "Hello"
"Hello"

Main&gt; show "Hello"
"\"Hello\""

Main&gt; show $ show "Hello"
"\"\\\"Hello\\\"\""

Main&gt; show $ show $ show "Hello"
"\"\\\"\\\\\\\"Hello\\\\\\\"\\\"\""

Main&gt; show $ show $ show $ show "Hello"
"\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"Hello\\\\\\\\\\\\\\\"\\\\\\\"\\\"\""</code></pre>
<p>・・・爆笑。いや、オレってば何がしたいんだ？って。 えっと、何したかったんだか忘れちゃった。えーっと、これは “Hello” 自体 は印字形式は文字列 “Hello” になる。つまり、こいつは <a href="https://wiki.haskell.jp/Old/sampou.org/=%22Hello%22">‘H’,‘l’,‘l’,‘o’</a> になるね。こいつに show を適用すると、</p>
<pre><code>show :: show a =&gt; a -&gt; String</code></pre>
<p>なので、この場合、 a 自体も String になっている。たまたまね。そのため に左右のダブルクォーテーションもリストのメンバに取り込まれるんだね。 <a href="https://wiki.haskell.jp/Old/sampou.org/=%22%22Hello%22%22">‘"’,‘H’,‘l’,‘l’,‘o’,‘"’</a>ってな感じにさ。さらにそいつがエ スケープされると。まぁ print も同じなんだろうな。</p>
<pre><code>Main&gt; print $ show "Hello"
"\"Hello\""

あれ？ print も一発 show を含んでいるから show $ show "Hello" ってしたのと同じようになると思ったんだけど、なんでだろ？

Main&gt; print "Hello"
"Hello"

Main&gt; putStrLn "Hello"
Hello</code></pre>
<p>あー、 putStrLn がこうなるんだっけ。これは返り値が文字列ってワケじゃな くて、イタコのチャネル（この場合には標準出力）に Hello ってディスプレ イするっていうアクションの結果として見えているんだな。出力先がファイル ディスクリプタだったら書きこまれるだけで、モニタ上にはなんも出ないと。</p>
<h3 id="続たらいまわし">続たらいまわし</h3>
<p>だいぶスタックの深いトコから一気に戻るけど、窒素酔いを起こさないよーに。 たらいまわしコマンドをHaskellで実装したわけだが、こいつを色々いじくり まわして遊んでみようじゃないかってことです。</p>
<p>っつーわけで再掲。</p>
<pre><code>#!/usr/pkg/bin/runhugs

\begin{code}

import System

main :: IO ()
main = do args &lt;- getArgs
          putStrLn $ numberToStr $ apply (tak) $ map (strToNumber) args

apply :: (a -&gt; a -&gt; a -&gt; b) -&gt; [a] -&gt; b
apply f [x,y,z] = f x y z

numberToStr :: Int -&gt; String
numberToStr num = if (num &lt; 10)
                  then [intToDigit num]
                  else (numberToStr $ quot num 10) ++ [intToDigit $ rem num 10]

strToNumber :: String -&gt; Int
strToNumber str = foldl1 (\x y-&gt;10*x+y) $ map digitToInt str

tak :: Int -&gt; Int -&gt; Int -&gt; Int
tak x y z = if (x &gt; y) then tak (tak (x-1) y z)
                                (tak (y-1) z x)
                                (tak (z-1) x y)
                       else y

\end{code}</code></pre>
<p>まずは一度挫折している numberToStr の一時的な束縛を使ったコード。あの 後、神のささやきにて let,where を使うよろし！だって。(なぜに中国人風？)</p>
<pre><code>numberToStr :: Int -&gt; String
numberToStr num = let (q,r) = (quotRem num 10)
                  in (numberToStr q) ++ [intToDigit r]</code></pre>
<p>こんな感じになるはず。多分。 let decl in body ってな具合です。んで emacs 上で試してみる。</p>
<pre><code>Main&gt; numberToStr 123
"
Process hugs illegal instruction (core dumped)</code></pre>
<p>あ、がぁん！！Hugs殺しちゃったよ〜。そんなに悪いことした？オレ(++;アタフタ えっとーどういうこったろ。</p>
<pre><code>Main&gt; numberToStr 1
"
Process hugs illegal instruction (core dumped)</code></pre>
<p>ダメだ。でもよーく見るとコアダンプの直前に " ってダブルクォーテーショ ン一個だけの断末魔の叫びが。</p>
<p>どうやら処理しようとはしてくれている。しばし考えててようやく分かりまし た。いやぁ、何とも間抜けなんだけど再帰で書いてて基底条件が無いじゃん。</p>
<pre><code>numberToStr :: Int -&gt; String
numberToStr num = let (q,r) = (quotRem num 10)
                  in if q == 0
                     then [intToDigit r]
                     else (numberToStr q) ++ [intToDigit r]</code></pre>
<p>こんな風に in の中に書いてやる。そんでからプロンプトにぃ〜食らえ！！</p>
<pre><code>Main&gt; numberToStr 123
"123"
Main&gt; numberToStr 987654321
"987654321"
Main&gt; </code></pre>
<p>やたっ！ちなみに where 節ってのも使えるらしいから、試しておこう。</p>
<pre><code>numberToStr :: Int -&gt; String
numberToStr num | q == 0 = [intToDigit r]
                | otherwise = (numberToStr q) ++ [intToDigit r]
                where (q,r) = (quotRem num 10)</code></pre>
<p>otherwise とかいけんのかな？って思ってたら大丈夫でした。えーっともしか して _ とか使えないかな？</p>
<pre><code>                | _ = (numberToStr q) ++ [intToDigit r]</code></pre>
<p>こうやって、ロードしてやると・・・</p>
<pre><code>Type checking..................................................................
Compiling......................................................................
Reading file "/home/cut-sea/script/haskell/tak.lhs":
Parsing........................................................................
Dependency analysis
ERROR "/home/cut-sea/script/haskell/tak.lhs":27 - Illegal `_' in expression
System&gt; </code></pre>
<p>あーだめか。 case っぽいのとはまた違うのかな？うーん。どうも整理できて ないんだよな。まーいーんだけどね。</p>
<blockquote>
<p>‘_’はパターン部(’|‘の前)でしか使えません。ガード部(’|‘の後)には真偽値しか来ません。 ちなみに、’otherwise’ が使えるのは、Prelude で True と 定義 されているからです。</p>
</blockquote>
<p>とにかく time とかで計測してみたけど、この三種類ではあんまし大差ない感 じ。ところが、意外だったのは神の提示された read を使っているコードが若 干遅めだったこと。これって凄い不思議な感じ。なんでかって？だって read って個人的には言語核の read-eval-print における read だと思ってたんだ よね。これは高速だろうなと、はい。</p>
<p>一方 numberToStr はっつーと別の関数として実装してて、一文字ずつ読み込 んでは変換してって作業をしているわけだから明らかに遅そうじゃん？一体全 体なんなんでしょう。もしかして read ってのは read-eval-print の read とは別モンなんだろうか。(–; それとも read 自体の問題じゃなくて他になんか遅くなる要因があるんだろう か。もしくは私のread は速えぇって感覚の方がおかしいんだろうか。</p>
<p>プロファイラとかあればいいんだろうけどなぁ。そういやデバッグの標準的な やり方とかも知らんな。なんとなくエラーメッセージからアタリつけたり、あ と神のツッコミだよりって感じ。あ、あと遅延評価(要は問題先送り精神のこ とね)。</p>
<blockquote>
<p><a href="http://cvs.haskell.org/Hugs/pages/users_guide/observe.html" class="uri">http://cvs.haskell.org/Hugs/pages/users_guide/observe.html</a>[ Hugs のマ ニュアル]によると、デバッグには Observe (もしくは Hugs.Observe)モジュー ルが使えるようです。このモジュールをインポートして、監視したい値の前に ‘observe “name”’ と付ければ、実行後に値を表示してくれます。</p>
<pre><code>Observe&gt; let f x = if x == 0 then 1 else x * observe "f" f (x-1) in f 10
3628800

&gt;&gt;&gt;&gt;&gt;&gt;&gt; Observations &lt;&lt;&lt;&lt;&lt;&lt;

f
  { \ 9  -&gt; 362880
  , \ 8  -&gt; 40320
  , \ 7  -&gt; 5040
  , \ 6  -&gt; 720
  , \ 5  -&gt; 120
  , \ 4  -&gt; 24
  , \ 3  -&gt; 6
  , \ 2  -&gt; 2
  , \ 1  -&gt; 1
  , \ 0  -&gt; 1
  }

strToNumber = foldl1 (\x y -&gt; 10 * x + y) . map digitToInt</code></pre>
<p>に対して hugs +s で</p>
<pre><code>Main&gt; strToNumber "123"
123
(124 reductions, 212 cells)
Main&gt; read "123" :: Int
123
(1048 reductions, 1537 cells)</code></pre>
<p>でした。</p>
<p>readはただの関数でRead Intも /usr/local/lib/hugs/libraries/Hugs/Prelude.hs で定義されています。御参 考まで。</p>
<p>余計なお世話かもしれませんが、型推論の時のエラーと実行時のエラーを混同 されているように見受けられます。 (特に read の辺り) Hugs では、実行時のエラーは ‘Program error:’ と表示されます。</p>
<pre><code>Prelude&gt; [1] !! (-1)

Program error: Prelude.!!: negative index</code></pre>
<p>ここまでの WayToHaskeller に載っているエラーメッセージで、 ‘Program error:’ と表示されているのは2箇所だけです。つまり、今までのエラーは、 ほとんど型推論の段階で起きていて、コードはいっさい実行されていない、と いう事になります。</p>
</blockquote>
<p>ふむふむ。ちょっとしたデバッグプリントやオプションが使えるんだぁ。言わ れてみれば確かに read って色々分岐しまくってたな。 reduction ってのは 何回簡約されたかですな。cells ってのは消費したメモリセル？ Lispのご本 尊みたいなものの消費量かなぁとか予想してみる。とりあえず簡約回数だけみ ても、あー read って何回も色々やることがあるんだぁってのが伺えちゃいま す。</p>
<h3 id="デバッグの手段を知ろう">デバッグの手段を知ろう</h3>
<p>この辺りを知って、しかも話の流れからすると・・・たらいまわし関数の値の デバッグプリントとか見てみたくないですかい？わしゃ見たい！っちゅーわけ で見てみることにしてみましょう。はい。</p>
<p>まずは、Observe をインポートすんだね。import System の下あたりに追加します。</p>
<pre><code>import System
import Observe  &lt;= コレ</code></pre>
<p>でもって emacs 上で Ctrl-c Ctrl-l でロードしてから、</p>
<pre><code>Main&gt; observe "tak" tak 6 3 0
6

&gt;&gt;&gt;&gt;&gt;&gt;&gt; Observations &lt;&lt;&lt;&lt;&lt;&lt;

tak
  { \ 6 3 0  -&gt; 6
  }</code></pre>
<p>あれぇ？ 6 3 0 じゃ小さいのか？そんな問題じゃねーよな。でも、一応確認 してみよう。</p>
<pre><code>Main&gt; observe "tak" tak 200 100 0
200

&gt;&gt;&gt;&gt;&gt;&gt;&gt; Observations &lt;&lt;&lt;&lt;&lt;&lt;

tak
  { \ 200 100 0  -&gt; 200
  }</code></pre>
<p>うーん。やっぱ関係ないね。もっかい神の啓示を振り返ってみると、</p>
<pre><code>Observe&gt; let f x = if x == 0 then 1 else x * observe "f" f (x-1) in f 10</code></pre>
<p>・・・あーっそっか！ハイハイ。デバッグプリントだった。評価するステップ で印字するんだ。</p>
<pre><code>Main&gt; let tak x y z = if (x &gt; y)
                      then tak (observe "tak" tak (x-1) y z)
                               (tak (y-1) z x)
                               (tak (z-1) x y)
                      else y in tak 10 5 0
10

&gt;&gt;&gt;&gt;&gt;&gt;&gt; Observations &lt;&lt;&lt;&lt;&lt;&lt;

tak
  { \ 9 5 0  -&gt; 9
  , \ 8 5 0  -&gt; 8
  , \ 7 5 0  -&gt; 7
  , \ 6 5 0  -&gt; 6
  , \ 5 5 0  -&gt; 5
  , \ 3 0 6  -&gt; 6
  , \ 2 0 6  -&gt; 6
  , \ 1 0 6  -&gt; 6
  , \ 0 0 6  -&gt; 0
  , \ 3 0 7  -&gt; 7
  , \ 2 0 7  -&gt; 7
  , \ 1 0 7  -&gt; 7
  , \ 0 0 7  -&gt; 0
  , \ 3 0 8  -&gt; 8
  , \ 2 0 8  -&gt; 8
  , \ 1 0 8  -&gt; 8
  , \ 0 0 8  -&gt; 0
  , \ 3 0 9  -&gt; 9
  , \ 2 0 9  -&gt; 9
  , \ 1 0 9  -&gt; 9
  , \ 0 0 9  -&gt; 0
  , \ 3 0 10  -&gt; 10
  , \ 2 0 10  -&gt; 10
  , \ 1 0 10  -&gt; 10
  , \ 0 0 10  -&gt; 0
  }</code></pre>
<p>おおぉっ！でけたでけた。ぱちぱちぱち。 一方Schemeインタプリタだと、どうなるかってーと、</p>
<pre><code>gosh&gt; (define (tak x y z) (if (&gt; x y)
                              (tak #?=(tak (- x 1) y z)
                                      (tak (- y 1) z x)
                                      (tak (- z 1) x y))
                              y))
tak</code></pre>
<p>さぁ、試してみましょう。</p>
<pre><code>gosh&gt; (tak 10 5 0)
      :
      :</code></pre>
<p>・・・(+_+)えぇ、とても書き込めません。そんな必要無いですし。 しかし、最初の引数を observe しただけでもアレですから大変なもんです。 全部を observe したらどうなるでしょうかね。</p>
<pre><code>Main&gt; let tak x y z = if (x &gt; y)
                      then tak (observe "tak" tak (x-1) y z)
                               (observe "tak" tak (y-1) z x)
                               (observe "tak" tak (z-1) x y)
                      else y in tak 10 5 0
10

&gt;&gt;&gt;&gt;&gt;&gt;&gt; Observations &lt;&lt;&lt;&lt;&lt;&lt;

tak
  { \ 9 5 0  -&gt; 9
  , \ 8 5 0  -&gt; 8
  , \ 7 5 0  -&gt; 7
  , \ 6 5 0  -&gt; 6
  , \ 5 5 0  -&gt; 5
  , \ 4 0 6  -&gt; 6
  , \ 3 0 6  -&gt; 6
  , \ 2 0 6  -&gt; 6
  , \ 1 0 6  -&gt; 6
  , \ 0 0 6  -&gt; 0
  , \ (-1) 6 1  -&gt; 6
  , \ (-1) 6 2  -&gt; 6
  , \ (-1) 6 3  -&gt; 6
  , \ (-1) 6 4  -&gt; 6
  , \ 4 0 7  -&gt; 7
  , \ 3 0 7  -&gt; 7
  , \ 2 0 7  -&gt; 7
  , \ 1 0 7  -&gt; 7
  , \ 0 0 7  -&gt; 0
  , \ (-1) 7 1  -&gt; 7
  , \ (-1) 7 2  -&gt; 7
  , \ (-1) 7 3  -&gt; 7
  , \ (-1) 7 4  -&gt; 7
  , \ 4 0 8  -&gt; 8
  , \ 3 0 8  -&gt; 8
  , \ 2 0 8  -&gt; 8
  , \ 1 0 8  -&gt; 8
  , \ 0 0 8  -&gt; 0
  , \ (-1) 8 1  -&gt; 8
  , \ (-1) 8 2  -&gt; 8
  , \ (-1) 8 3  -&gt; 8
  , \ (-1) 8 4  -&gt; 8
  , \ 4 0 9  -&gt; 9
  , \ 3 0 9  -&gt; 9
  , \ 2 0 9  -&gt; 9
  , \ 1 0 9  -&gt; 9
  , \ 0 0 9  -&gt; 0
  , \ (-1) 9 1  -&gt; 9
  , \ (-1) 9 2  -&gt; 9
  , \ (-1) 9 3  -&gt; 9
  , \ (-1) 9 4  -&gt; 9
  , \ 4 0 10  -&gt; 10
  , \ 3 0 10  -&gt; 10
  , \ 2 0 10  -&gt; 10
  , \ 1 0 10  -&gt; 10
  , \ 0 0 10  -&gt; 0
  , \ (-1) 10 1  -&gt; 10
  , \ (-1) 10 2  -&gt; 10
  , \ (-1) 10 3  -&gt; 10
  , \ (-1) 10 4  -&gt; 10
  }

Main&gt; </code></pre>
<p>スゴイデスネ〜ワタクシビックリギョウテンデゴザイマス〜。 こりゃ速いハズだわ。うん。ちなみに observe したやつはコマンドラインか ら ./tak.lhs 10 5 0 とかってしても印字はされません。投げてるポートか違 うんでしょうね。</p>
<p>でもってよーく考えてみると、事実上たらいまわし関数の値を求めるのに必要 な評価ってのはこれだけで済む訳で、考えようによっては、これって一種のコ ンパイラの最適化じゃない？</p>
<p>さらに trace なんかもあるらしい。こいつも試してみよう。 Everyday:2004-10-31を参考にしてみる。</p>
<pre><code>apply :: (a -&gt; a -&gt; a -&gt; b) -&gt; [a] -&gt; b
apply f [x,y,z] = trace ("trace:"++show x++","++show y++","++show z++"=") $ f x y z</code></pre>
<p>さあ、これでどーよ？</p>
<pre><code>Type checking
ERROR "/home/cut-sea/script/haskell/tak.lhs":31 - Cannot justify constraints in explicitly typed binding
*** Expression    : apply
*** Type          : (a -&gt; a -&gt; a -&gt; b) -&gt; [a] -&gt; b
*** Given context : ()
*** Constraints   : Show a

Trace&gt; </code></pre>
<p>？！ Cannot justify constraints in explicitly typed binding って型があ わねぇっておっしゃってるんだろうか。 show a がまずいのかな？ってゆーか、 もしかしてこうかい？</p>
<pre><code>-- apply :: (a -&gt; a -&gt; a -&gt; b) -&gt; [a] -&gt; b
apply :: (Int -&gt; Int -&gt; Int -&gt; Int) -&gt; [Int] -&gt; Int
apply f [x,y,z] = trace ("trace:"++show x++","++show y++","++show z++"=") $ f x y z</code></pre>
<blockquote>
<pre><code>apply :: Show a =&gt; (a -&gt; a -&gt; a -&gt; b) -&gt; [a] -&gt; b</code></pre>
<p>でもうまくいきます。</p>
</blockquote>
<p>どうかな？</p>
<pre><code>Main&gt; apply tak [6,3,0]
trace:6,3,0=6
Main&gt; </code></pre>
<p>あ、おっけーですね。でもまた同じ間違いをしちゃいました。こんなトコに書 いたってしょーがねーじゃんね。</p>
<pre><code>tak :: Int -&gt; Int -&gt; Int -&gt; Int
tak x y z = if (x &gt; y)
            then trace ("trace:"++show x++","++show y++","++show z++"\n") $ tak (tak (x-1) y z)
                                                                                (tak (y-1) z x)
                                                                                (tak (z-1) x y)
            else y</code></pre>
<p>ここでした。これで一応それっぽい動きが確認できますな。</p>
<pre><code>Main&gt; tak 6 3 0
trace:6,3,0
trace:5,3,0
trace:4,3,0
trace:2,0,4
trace:1,0,4
trace:2,0,5
trace:1,0,5
trace:2,0,6
trace:1,0,6
6</code></pre>
<p>ってね。ぱちぱちぱち〜。 でも正直 observe の方が便利な気がするんですけどね。それって gosh の #?= に慣れちゃってるからかなぁ。</p>
<p>いずれにせよデバッグの秘宝も手にしたし、ページもでかくなって来てそろそ ろ編集するのも辛いので (すでに理由をナメてんな)よちよち歩きへGO！！</p>
<h3 id="ちょっとひとやすみメイビー">【ちょっとひとやすみ】メイビー？</h3>
<blockquote>
<p>やっぱりまだまだ先。。。</p>
</blockquote>
<p>(<a href="http://www.sampou.org/cgi-bin/haskell.cgi?p=Programming:WayToHaskeller:%EF%BF%BD%C4%A4%EF%BF%BD%EF%BF%BD%DE%A4%EF%BF%BD%CE%A9%EF%BF%BD%EF%BF%BD&amp;c=e&amp;l=jp">「つかまり立ち」を編集する</a>)|(<a href="http://www.sampou.org/cgi-bin/haskell.cgi?Programming:WayToHaskeller&amp;l=jp">Haskellerへの道</a>)</p>
</blockquote>
<hr>
<h2 id="よちよち歩き">よちよち歩き</h2>
<p>(<a href="http://www.sampou.org/cgi-bin/haskell.cgi?p=Programming:WayToHaskeller:%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%E2%A4%AD&amp;c=e&amp;l=jp">「よちよち歩き」を編集する</a>)|(<a href="http://www.sampou.org/cgi-bin/haskell.cgi?Programming:WayToHaskeller&amp;l=jp">Haskellerへの道</a>)</p>
<p>他の方々がさくさくHaskellのコードを紡いでいるのを見ていると、まだまだ 道のりは長いらしい。 実は入門の目次見てても型関係とモナド関係でおしまい？って気がしないでも なかったんだが、かなり勘違い？なのが見て取れる。 とにかく二足歩行にちゃれんじだぜ！べいべっ！！</p>
<h3 id="自分で型を">自分で型を</h3>
<p>かの<a href="http://www.sampou.org/haskell/tutorial-j/index.html">やさしいHaskell入門</a>が実は入門者に難しいという定説があるんだけど、 思うに<a href="http://www.sampou.org/haskell/tutorial-j/goodies.html">ココ</a>が</p>
<p>しっしっ！けーれ！こちとら一見さんはお断りでいっ！っておっしゃってる様 に思える。 でもさ、自分の問題に合わせて型とかを作るのって、言語によらず基本中の基 本じゃないすか？ なんもかもリストとかなんもかも配列とか、そういう言語上でだって、見掛け 上だけでもそれっぽい型に見えるようなナニモノかをでっち上げるもんね？</p>
<p>っちゅーわけで、以前から Tree とか気になってたりするわけさ。</p>
<pre><code>data Tree a             = Leaf a | Branch (Tree a) (Tree a) </code></pre>
<p>この直前に</p>
<p>・・・ような型構築子とPtのようなデータ構築子は別の名前空間にあります。つまり、つぎのように、型構築子とデータ構築子に同じ名前を使うことが できるということです。</p>
<pre><code>data Point a = Point a a</code></pre>
<p>こんな説明があるのだが、なんか足りない気がする。 うーん。Point ってデータ構築子はいつどこでだれが作るんだろう?</p>
<p>というワケで例によってHugsの反応をうかがいつつ考えてみましょー。</p>
<pre><code>#! /usr/pkg/bin/runhugs

\begin{code}

data Tree a = Leaf a | Branch (Tree a) (Tree a)

\end{code}</code></pre>
<p>まずは、これだけのコードを C-c C-l でロードしてみる。</p>
<pre><code>/usr/pkg/share/hugs/lib/Prelude.hs
/home/cut-sea/script/haskell/tree.lhs
Main&gt; </code></pre>
<p>お？予想外に通りました。何を予想してたかってーと、左辺のやつは型構築子 てやつで、右辺にあるのがデータ構築子だってことらしいけど、どっこにも定 義してないんだよね？このデータ構築子ってのがさー。にも関わらずエラーも 何も出ないと考える方が異常かなぁっと。 もしかしてたまたま Branch とか含まれてるのか？と思って :find Branch っ てすると、なんと自分で書いた上のコードがそのまま表示されやがった。 :find Tree しても同じ。</p>
<p>・・・ってーことはデータ構築子ってのは勝手に作られるんだね。そういや、 以前<a href="http://www.sampou.org/cgi-bin/haskell.cgi?p=Programming:WayToHaskeller:%EF%BF%BD%C4%A4%EF%BF%BD%EF%BF%BD%DE%A4%EF%BF%BD%CE%A9%EF%BF%BD%EF%BF%BD&amp;l=jp#9">ここ</a> で Color をいじった時にも、何もしなくたって良かったな。 Red とか Blue とかどうやって作るか？なんて考えもしてないわ。どうやら具体的 にどのように実装するものかってのを定義しなくてもいいわけか。以前は列挙 型ってことだったんで、 Red や Blue ってまるでリテラルの定義の様に錯覚 してたけど、改めて説明を読むと、これって（無引数）データ構築子だから Red とか Blue のインスタンスを生成する関数（？）のようなもんなわけか。</p>
<p>しかもユーザ定義のデータ型とかって、例えば C ならどんな構造体だとか、 この要素は int だとか char * だとか指定しないといけないけど、 Haskell の場合には不必要と？んーっむ、すんげー不思議(–; ってゆーかペテンにかけられてる気がする。どんな構造（気持ち的には実装） か指定してもいないのになんとなく作れちゃうのか？単に型同士の関係さえ掴 めればいいのだろうか？ でもさぁ、そうだとしても、さらなる疑問が出て来るぞ。型同士の関係って意 味でいうと次のところとか気になるんだよなぁ。個人的に。</p>
<p>型構築子とデータ構築子は別の名前空間にあるんなら、</p>
<pre><code>data Tree a = Leaf a | Branch (Tree a) (Tree a)</code></pre>
<p>この型宣言の左辺にある Tree ってやつと 右辺の Tree ってやつの関係は？ 右辺の Tree ってのは Tree って型のデータを作るためのデータ構築子だと思っ てたけど違うのか？ emacs 上でカーソルを合わせるけど案の定なんも表示されないね。ミニバッ ファ。 んじゃ、 Main&gt; プロンプトに Leaf 1 とか入れてみようか？</p>
<pre><code>Main&gt; Leaf 2
ERROR - Cannot find "show" function for:
*** Expression : Leaf 2
*** Of type    : Tree Integer</code></pre>
<p>ありゃ、ダメだ。そっか show クラス継承せんといかんな。</p>
<pre><code>data Tree a = Leaf a | Branch (Tree a) (Tree a) deriving Show</code></pre>
<p>改めてロード！</p>
<pre><code>Main&gt; Leaf 1
Leaf 1
Main&gt; Leaf 2
Leaf 2
Main&gt; Tree 1
ERROR - Undefined constructor function "Tree"</code></pre>
<p>ふむ、Tree はデータ構築子じゃねーよ！って叱られちった。やっぱそうなんか。 んだらば、コレは？</p>
<pre><code>Main&gt; Branch 1 2
ERROR - Unresolved overloading
*** Type       : Num (Tree a) =&gt; Tree a
*** Expression : Branch 1 2</code></pre>
<p>あ、違った。(^^;</p>
<pre><code>Main&gt; Branch (Leaf 1) (Leaf 2)
Branch (Leaf 1) (Leaf 2)
Main&gt; </code></pre>
<p>うむ。ってーことは、右辺に現れる大文字英字から始まるシンボル名の内、ど れがデータ構築子で、どれが型構築子なんじゃろ(?_?)</p>
<pre><code>data Point a = Point a a deriving Show</code></pre>
<p>これはアリなんだよねぇ？うーん。 こういう時は、大っ嫌いなんだけど仕様書みるっきゃねーか。 <a href="http://www.sampou.org/haskell/report-j/decls.html#datatype-decls">ユーザ定義のデータ型</a>を見てみよう。</p>
<pre><code>topdecl         -&gt;      data [context =&gt;] simpletype =  constrs [deriving]      
simpletype      -&gt;      tycon tyvar1 ... tyvark         (k&gt;=0)
constrs         -&gt;      constr1 | ... | constrn         (n&gt;=1)
constr  -&gt;      con [!] atype1 ... [!] atypek   (arity con = k, k&gt;=0)
        |       (btype | ! atype) conop (btype | ! atype)       (infix conop)
        |       con { fielddecl1 , ... , fielddecln }   (n&gt;=0)
fielddecl       -&gt;      vars :: (type | ! atype)        
deriving        -&gt;      deriving (dclass | (dclass1, ... , dclassn))    (n&gt;=0)
dclass  -&gt;      qtycls</code></pre>
<p>・・・うわっ。(^o^; 基本的には topdecl は data simpletype = constrs だよってーとこから下っ ていって、 constr1 | constr2 … | constrn って感じの列挙になるよと。 でもって constr ってのがどうも難し過ぎて閉口しちゃいました。ただ、なん となくなんだけど con ほげほげ ってな感じになってそうなんで、 con って のが constructor の略だとすれば、最初の一個目のシンボルだけがデータ構 築子ってことの様に思える。残りの atype ってのは多分、なんかの型だと思 うんだけど自信ねぇや。 [!]って感じで角括弧で囲まれたやつは省略可ってこ とだと思うんだけど、これも自信無し。まぁ、あまり突っ込んでも、まだ分か らないと思うんで潔くあきらめる。 とりあえず、| で区切って、各部分の最初のシンボルがデータ構築子の名前に なるんでしょーって思っておこう。 (ただし、途中に infix 云々があるんで、 こいつはちょい別っぽいけど)</p>
<pre><code>data Tree a = Leaf a | Branch (Tree a) (Tree a) deriving Show</code></pre>
<p>つまり、ここで Branch ほげ ふがってのは、この時点で Branch がデータ構 築子、ほげとふがが型を表してんだね。ってーことは、</p>
<pre><code>data Tree a = Leaf a | Tree (Tree a) (Tree a) deriving Show
                      ~~~~~~</code></pre>
<p>こんな風に書いた場合、ここに出てくる Tree のうち、最初の波下線つけた Tree だけがデータ構築子で、続く (Tree a) (Tree a) が型であり、データ構 築子 Tree の引数(って言い方が妥当かどうか知らんが)にもなるシロモノだね。</p>
<pre><code>Main&gt; Tree (Leaf 1) (Leaf 2)
Tree (Leaf 1) (Leaf 2)
Main&gt; Tree (Tree (Leaf 1) (Leaf 2)) (Tree (Leaf 3) (Leaf 4))
Tree (Tree (Leaf 1) (Leaf 2)) (Tree (Leaf 3) (Leaf 4))
Main&gt; Tree (Tree (Leaf 'a') (Leaf 'b')) (Tree (Leaf 'c') (Leaf 'd'))
Tree (Tree (Leaf 'a') (Leaf 'b')) (Tree (Leaf 'c') (Leaf 'd'))
Main&gt; </code></pre>
<p>うん。なんとなく正解くさくないっすか？</p>
<p>さて、ここで重要なんじゃないかと思うのは、まさに Tree がどんな構造（こ こも気持ち的には実装ね）か？なんて一切指定というか記述されてないこと！ ではなかろーか。 上の Tree 型の定義をみたら、規格外の偏屈者でもない限り、</p>
<pre><code>        Tree (Leaf 1) (Leaf 2)
               +---+---+
               | + | + |
               +/--+--\+
               /       \
           +--/+       +\--+
           | + |       | + |
           +---+       +---+
          Leaf 1       Leaf 2</code></pre>
<p>こーんな感じの木構造を思い浮かべるハズ。（だよね？だよね？DAYONE？オレ が規格外の偏屈者ってこたないと・・・） でも、多分 Haskell は 「想像すんのは勝手だけど、どんな風に実現してるか はオレの勝手じゃ！」とおっしゃるかもしれんワケだ。</p>
<p>例えば、Scheme? とかの Lisp? 系言語ではフツーはリストって言えば、おそ らく上の Tree みたいになっているハズだけど、全く違う実装も考えられる。</p>
<pre><code>(define (cons x y)
  (lambda (z) (z x y)))
(define (car z)
  (z (lambda (x y) x)))
(define (cdr z)
  (z (lambda (x y) y)))</code></pre>
<p>なんて感じで実装されてたって良いわけやね。要は cons/car/cdr が互いに、 インターフェースがピシッと合わせてあって、ソトヅラさえ、正しく動けば、 どんなんでもそんなん自由なわけか。</p>
<p>ただ、上記で定義した cons/car/cdr は、こいつらの中だけで仲間意識があって、</p>
<p>native に実装されている cons/car/cdr とは協定組んでないんで、いっしょ くたにして書いても動かないのは当ったり前。つまり、こいつらはこいつらの 世界だけで構成される計算ロジックの中でだけうまく動くので、ちゃんと閉じ 込めてやらないといけないんだよね。 （実はモナドってやつの世界観もコレっぽい気がせんでもないんだが）</p>
<pre><code>data Tree a = Leaf a | Tree (Tree a) (Tree a) deriving (Show,Eq)</code></pre>
<p>こんな風に Eq も継承させてみる。そうすっと、</p>
<pre><code>Main&gt; Tree (Leaf 1) (Leaf 2) == Tree (Leaf 1) (Leaf 2)
True
Main&gt; Tree (Leaf 1) (Leaf 2) == Tree (Leaf 1) (Leaf 3)
False</code></pre>
<p>比較判定もできるようになるんですな。さて、ここでこんなん試してみましょう。</p>
<blockquote>
<p>ちょっと割り込み。Quiz です(まず、脳内で考えましょう。それから、処理系に訊きましょう)。</p>
<pre><code>data Tree a = Leaf a | Branch (Tree a) (Tree a)</code></pre>
<ul>
<li>Leaf の型は？</li>
<li>Branch の型は？</li>
</ul>
<p>–nobsun(2004/12/08 10:23:37 JST)</p>
</blockquote>
<p>おっと、割り込み要求を受信してしまった。しかも、処理系に聞かないように とクギさされました。なんか行動見抜かれてます。ぎく。(-_-;</p>
<p>でも忘年会帰りでアルデヒドが脳内で暴れ狂ってるんで何か分かりそうな気がする。</p>
<p>えーと、 Leaf とか Branch ってのはデータ構築子ですねぇ。データ構築子に 型なんてあんの？と一瞬固まったんだけど、こいつは確かに一引数とか二引数 の関数とみなせそうですな。 Leaf は 任意の型 a を引数にとり、 Tree a な 型のデータを生成する関数なんじゃない？ 生成するなんて言い方が妥当かどうか怪しいんだけど。同様に、 Branch は Tree a を二つ引数に取って、 Tree a な型のデータを返す関数ですよね？ これって妙に身構えちゃってたけど、良く考えたら構築子が関数ってのは別に 驚くようなこっちゃねぇな。(^^; ま、ともあれ口頭で話すよか書いた方が綺麗かなぁ。</p>
<pre><code>Leaf :: a -&gt; Tree a
Branch :: Tree a -&gt; Tree a -&gt; Tree a</code></pre>
<p>こんな感じじゃなかろかしらん。しかも今回は結構自信マンマン。(^^)v なんかすげぇつじつま合ってそうだし。同様に推測すると Red や Blue なんかも。</p>
<pre><code>Red :: Color
Blue :: Color</code></pre>
<p>ですね。無引数の関数って実質 thunk で、それは Haskell では値だ。これも 自分的には納得できる。</p>
<p>んじゃ、自信もあるんでファイナルアンサー！</p>
<pre><code>Main&gt; Leaf
ERROR - Cannot find "show" function for:
*** Expression : Leaf
*** Of type    : a -&gt; Tree a

Main&gt; Branch
ERROR - Cannot find "show" function for:
*** Expression : Branch
*** Of type    : Tree a -&gt; Tree a -&gt; Tree a

Main&gt; </code></pre>
<p>ビンゴ！！やったね！！(^^)v しかしアルコール入るといー感じなのは喜ぶべきなんか・・・？ってな自己ツッ コミはおいといて、素晴らしい！！ダテに二足歩行しちゃいねぇ！ ・・・あれ？ってことはデータ構築子って関数？オイラそんな関数なんて定義 してねぇぞ？(@<a href="email-protection.html" class="__cf_email__" data-cfemail="752a35">[email&nbsp;protected]</a>;えぇっ？？ 関数って定義してないのに関数が出来てるくさいんですけど、コレ・・・。酔っ 払いすぎてマボロシでも見てますか？ワタシ？？</p>
<p>気になるので逆にこんなんしてみる。これで逆に Tree a 型ってのができちゃっ たりして。ゴクリ。</p>
<pre><code>#! /usr/pkg/bin/runhugs

\begin{code}

{-
data Tree a = Leaf a | Branch (Tree a) (Tree a) deriving (Show,Eq)
data Tree a = Leaf a 
            | Tree (Tree a) (Tree a) deriving (Show,Eq)

data Point a = Point a a deriving Show
-}

Leaf :: a -&gt; Tree a
Branch :: Tree a -&gt; Tree a -&gt; Tree a

\end{code}</code></pre>
<p>つまり、今度は data Tree a を宣言するんじゃなくて、 Leaf や Branch 関 数の型宣言をすることで、あたかも Tree a 型が宣言できちゃうんじゃないか なぁ？って企てだ。いけーっ！！</p>
<pre><code>Prelude&gt; :load /home/cut-sea/script/haskell/tree.lhs
Reading file "/home/cut-sea/script/haskell/tree.lhs":
Parsing
ERROR "/home/cut-sea/script/haskell/tree.lhs":13 - Syntax error in declaration (unexpected `::')
Prelude&gt; </code></pre>
<p>あーぁ、これはハズレだ。</p>
<blockquote>
<p>「えっ？ 型？ あ、そうか。そんなものもあったな。いやあ、すっかり忘れておったわ」</p>
</blockquote>
<p>ガーーーッン (‾□‾;)</p>
<blockquote>
<p>タイプ量は増えるけど、処理系に礼儀正しく型を聞く方法。</p>
<pre><code>Hugs.Base&gt; :t id
id :: a -&gt; a</code></pre>
</blockquote>
<p>よくよく考えたら分かったかも。</p>
<p>あ、いや、上で Leaf や Branch を定義することで Tree a が出来るか？って ムボーなチャレンジがダメな理由がね。</p>
<p>やっぱ引用は<a href="http://www.sampou.org/haskell/tutorial-j/goodies.html">こっから</a>だ。</p>
<p>すべての値は型 (type)をもちます。 (直観的には型は値の集合と考えることができます。)</p>
<p>そうよ、型は値の集合なんよね。（あくまで直観的にってお断りあるけど） 例えば、上の例で言えば Leaf か Branch で構築されるものだけが Tree なん だ。 Leaf だけでもないし、Branch だけでもない。また、それ以外のものも 含まれちゃいない。だけど、ムボーなチャレンジの方で、もし私が Leaf だけ 定義してたとしたら、 Tree を完全に表現できてないんだね。（でも完全なの か不完全なのかすら分からん） 同じく Leaf と Branch だけで Tree の全てかどうかは Tree が明かされてな い以上は保証できん。</p>
<p>逆に型 Tree を記述すれば、要素は全部明確になっているから、どの要素だっ て生成するための関数の存在を仮定する（？）ことは可能なような気がする。 なんとなくだけどさ。私の信用ゼロのゴーストがそうささやいている。</p>
<blockquote>
<p>nobsun (2004/12/12 23:35:47 JST): データ構築子は関数のような型をもっていますし、関数のように使えますが、関数ではありません。</p>
<pre><code>data Tree a = Leaf a | Branch (Tree a) (Tree a)

tree,tree' :: Tree a -&gt; Tree a -&gt; Tree a
tree  = Branch
tree' = Branch</code></pre>
<p>この tree および tree’ は関数です。では、tree、tree’ と Branch ではなにが違いますか？</p>
<p>「ただの」関数ではないけれど、関数であるべき用件は満たしているのでは。 – yts</p>
<p>Paul Hudak:</p>
<pre><code> &gt; the Haskell designers might have used the following syntax:
 &gt;
 &gt; data Shape where
 &gt;      Circle :: Float -&gt; Shape
 &gt;      Square :: Float -&gt; Shape
 &gt;
 &gt; which conveys exactly the same information, and makes it quite clear 
 &gt; that Circle and Square are functions. </code></pre>
<p><a href="https://www.haskell.org//pipermail/haskell-cafe/2004-November/007357.html" class="uri">http://www.haskell.org//pipermail/haskell-cafe/2004-November/007357.html</a></p>
</blockquote>
<p>データ構築子は関数では無いのか？</p>
<p>うーん。分かりません。(+_+; とりあえず、関数は関数の本体が無いとダメだけど、データ構築子は無くても おっけー！ってか無い。</p>
<blockquote>
<p>nobsun(2004/12/15 15:31:31 JST)</p>
<p>データ構築子はタグのようなもので、強いて関数として書くなら、</p>
<p>(define (Leaf x) (list ’Leaf x)) (define (Branch t1 t2) (list ’Branch t1 t2))</p>
<p>と同じようなものです。これなら、どれも同じパターンなので、強いて本体を書く必要はないでしょう(Haskell では書きたくても書けませんが。。。)。</p>
<p>前に上げた、tree、tree’ と Branch の重要な違いは、たとえば、</p>
<p>Branch (Leaf 5) (Leaf 1)</p>
<p>というデータがあったとき、このデータは、tree によって作られたものなの か tree’ によって作られたものかは解らないですよね。でも、Branch で作ら れたものだということは、解ります。</p>
</blockquote>
<p>他になんかあるかなぁって思っていくつか式入力してみたけど、特に差らしき とこが分かんないです。違いの分からない男です。えぇ・・・。</p>
<p>・・・ってワケで、googleさん使ってカンニングしちゃいます。 <a href="http://wiki.ocaml.jp/index.php?%EF%BF%BD%D8%BF%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD/%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD">関数型言語の比較／型の定義</a>なんぞをみると、関数とデータ構築子は名前空 間は別って書いてあるな。名前の先頭文字が大文字・小文字の差はある。他に なんか美味そうなネタないかしらん。</p>
<p>あとは、（今神が導こうとしているとこと違うかも知れないけど） この<a href="http://www.sampou.org/haskell/tutorial-j/moretypes.html">フィールドラベル</a>か。</p>
<pre><code>data T = C1 {f :: Int, g :: Float}
       | C2 {f :: Int, h :: Bool}

フィールド名 f は型 T の両方の構築子に適用されています。
つまり、もし、x の型が T ならば、x {f=5} は T 内の
どちらの構築子が生成した値に対しても機能します。</code></pre>
<p>ふむ。これはちょっと、いやかなり面白いかも。 ここで C1 とか C2 とかってのが、 Leaf や Branch にあたるわけだけど、こ の例で x ってやつは葉っぱか枝かはっきりしてない状態でデータが作れちゃ うんだって。</p>
<p>とかなんとか言ってるうちにお告げがありました。ほー。ってことは、こうい うのはダメなのかな。</p>
<pre><code>\begin{code}

data Tree a = Leaf a | Branch (Tree a) (Tree a) deriving (Show,Eq)

data Three a = Leaf a | Branch a deriving Show

\end{code}</code></pre>
<p>つまり、 Leaf で作られたり Branch で作られたりしたデータが、自分でなん の型か分からないとか唯一に決まんないのはNG食らいそう。 例によって C-c C-l してやると。</p>
<pre><code>Prelude&gt; :load /home/cut-sea/script/haskell/tree.lhs
Reading file "/home/cut-sea/script/haskell/tree.lhs":
ERROR "/home/cut-sea/script/haskell/tree.lhs":5 - Repeated definition for constructor function "Leaf"
Prelude&gt; </code></pre>
<p>って感じで、 Repeated definition ってのが Leaf に対して出される。 ちなみに Branch で出ないのはなんでか？今の時点で考えられるのは、</p>
<ol type="1">
<li>Leaf でエラー出るから、そっから先はまだ目が行ってない。</li>
<li>Branch の引数の取り方が違うんでちゃんと見分けてくれてる。</li>
<li>それ以外の何か。(思い付かん)</li>
</ol>
<p>さぁどれかな。</p>
<pre><code>data Three a = Branch a deriving Show</code></pre>
<p>こうしてみる。 Three から Leaf を除くの。</p>
<pre><code>Prelude&gt; :load /home/cut-sea/script/haskell/tree.lhs
Reading file "/home/cut-sea/script/haskell/tree.lhs":
ERROR "/home/cut-sea/script/haskell/tree.lhs":5 - Repeated definition for constructor function "Branch"
Prelude&gt; </code></pre>
<p>って訳でいっちゃん上のやつでした。 んー、やっぱS式で表現されると実にスンナリ受け入れられマス。</p>
<p>さて、じゃあ Tree みたいなありがちな構造だけじゃなく、もちっと複雑な型 を見てみよう。でも自分じゃ考えらんない。そもそもどういった構造を考えて も所詮既成概念からくるようなべったべたの工夫のカケラもないものになるの が目に見えておる。</p>
<p>というわけでネタ探しだ。っつーか、心当たりはあるのだが。えーっと。あ、 <a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/haskell/haskell-jp/8">これこれ</a>ここにある型構築子の不動点だのバランス木だの、これでんがな。</p>
<pre><code>型構築子の不動点を表す、
  newtype Fix f = In (f (Fix f))
くらいは私も見たことがあったのですが、
完全バランス木を表す
  data Fork a = Fork a a
  data Perfect a = ZeroP a | SuccP (Perfect (Fork a))</code></pre>
<p>しかし、 newtype ってまた。(^^;ガン○ム世代をくすぐるねぇ ちなみに Newtype 宣言とかいうやつで、やさしい Haskell 入門にはこうあります。</p>
<p>プログラミングの練習に共通していることは、表現が既存の型と同一であるが、 型システムのなかでは別ものであるような型を定義することです。 Haskell では newtype 宣言が既存の型から新しい型をつくりだします。</p>
<p>うーん。C の typedef みたいなもんかと思ったんだけど、ちょっと違う気も する。型システムの中では別物って書いてあるけど、それの意味するところが 理解できてないのが致命的なんだろうね。</p>
<p>まぁ、こいつを肴にひさかたぶりにHaskellをいぢいぢしてみるかい。のんび りね。のんびり。</p>
<p>まず、型構築子の不動点を表すとかいうやつです。</p>
<pre><code>newtype Fix f = In (f (Fix f))</code></pre>
<p>・・・(-"-) えーっと、久々なんでかなり忘れてる。やべぇ。復習、復習。あ、 そうだ。In がデータ構築子だね。 f がなんだかよう分からんが、 Fix は型 構築子になるんじゃないかな。あれ? もしかして Fix f っていう型かな。 IO () とか IO String みたいに f は a とか b なんかと同じ型変数だろうか。 だとすると、IO a みたいなもんだな。 Fix f ってのが型変数 f を内部に持 つ Fix 型と。んー、とりあえずそう考えてみるか。あんまり抽象的だとつい てけないから、具体的な型にしてみるか。</p>
<pre><code>newtype Fix Int = In (Int (Fix Int))</code></pre>
<p>これならどーよ。念のためにロードしてみよう。うりゃ！久々の一発！</p>
<pre><code>Hugs session for:
/usr/pkg/share/hugs/lib/Prelude.hs
Type :? for help
Prelude&gt; Reading file "/home/cut-sea/script/haskell/fix.lhs":
ERROR "/home/cut-sea/script/haskell/fix.lhs":12 - Illegal left hand side in datatype definition
Prelude&gt; </code></pre>
<p>うがぁっ！えーと、datetype 定義の左辺がだめだってか? やっぱ Int とかに したらいけないのか。</p>
<blockquote>
<p>例えば、Scheme で</p>
<pre><code>(define (g x) x)</code></pre>
<p>を具体的な値にしたくて</p>
<pre><code>(define (g 0) 0)</code></pre>
<p>としたら、エラーになりますよね。要するに、Fix の仮引数 f まで Int にし てしまったのがエラーの原因です。</p>
<p>やるのであれば、</p>
<pre><code>newtype Fix = In (Int Fix)</code></pre>
<p>でしょうか。(ほかのエラーが出ると思いますが)</p>
</blockquote>
<pre><code>newtype Fix f = In (f (Fix f))</code></pre>
<p>んじゃ、元に戻してみよう。C-cC-lだっ。</p>
<pre><code>/usr/pkg/share/hugs/lib/Prelude.hs
/home/cut-sea/script/haskell/fix.lhs
Main&gt; </code></pre>
<p>うむ。しかし、どうやって使えばいいのかが分からん。(-_-; いやいや、落ち着け、オレ。例えば、</p>
<pre><code>data Tree a = Leaf a | Branch (Tree a) (Tree a) deriving (Show,Eq)</code></pre>
<p>この Tree の例で言えば、Tree って型はデータ構築子の Leaf か Branch で 作られるんだったよね。これってLeafやBranchってタグが付けられるようなも んだとかって話があったな。それからすると、例えば Leaf 10 とかってして Tree 型のデータを作るみたく In (10 (Fix 10)) とかって感じか? でも (10 (Fix 10)) は何か変。型変数の名前の付け方が f ってところからして俺のこ と関数だと思ってよ〜 って電波をビシビシ感じます。ええ。そうすっと、例 えば・・・</p>
<pre><code>Main&gt; In ...</code></pre>
<p>ん？んんんん〜？あれれ？なんか書けないぞ、コレ。なんでだ？(@<a href="email-protection.html" class="__cf_email__" data-cfemail="8fd0cf">[email&nbsp;protected]</a>;; えーっと。Tree なんかだとこうだよな。</p>
<pre><code>Main&gt; Leaf 10
Leaf 10
Main&gt; :t (Leaf 10)
Leaf 10 :: Num a =&gt; Tree a
Main&gt; Branch (Leaf 1) (Leaf 2)
Branch (Leaf 1) (Leaf 2)
Main&gt; :t Branch (Leaf 1) (Leaf 2)
Branch (Leaf 1) (Leaf 2) :: Num a =&gt; Tree a</code></pre>
<p>あー、そうか再帰的な型なのはいいんだけど、基底っていって良いのかなぁ、 Leaf みたいな、そういうデータ構築子がFixに無いからだ。こりゃ。</p>
<blockquote>
<p>まあ、</p>
<pre><code>Main&gt; :t In Nothing
In Nothing :: Fix Maybe</code></pre>
<p>とか書けない事も無いですが、素直に<a href="http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/haskell/haskell-jp/14">ここ</a>から例を引っ張ってきた方がいい と思います。</p>
</blockquote>
<p>それでも不動点についてなんか無いかしらんと google に頼ってみると結構説 明してるのが多いな、うん。個人的には <a href="http://d.hatena.ne.jp/tanakh/20040813">この説明</a> が結構一歩一歩説明してあっ て分かりやすいかも。 …いや、分かったような気にしてもらえるかも、って んで推奨。</p>
<p>Haskell に限らないみたいだが Schemeなんかでもふとしたキッカケでぶわーっ て不動点の話題が燃え上がることがあるようで。</p>
<p>なんだか fix って操作というか簡約の方向を、自分を呼び出すような仕掛け を作りこむのに使ってる感じがするわいな。不動点て聞くとどうも勘違いしや すいのよね。(私だけかい?) 検索中にもどっかで見かけたが、関数を与えたら 勝手に不動点を計算してくれる〜みたいなさ。 (^^;いやまさに私もそう思っ てましたって感じで、ははは。</p>
<p>さて、神の助言にしたがって入力してみる。 (実はその前に見てて fold/unfold の定義を見落としてた。はずい〜)</p>
<pre><code>\begin{code}

newtype Fix f = In (f (Fix f))

out (In x) = x
fold f     = f . fmap (fold f) . out
unfold f   = In . fmap (unfold f) . f

data ListF a x = Nil | Cons a x

instance Functor (ListF a) where
  fmap f Nil        = Nil
  fmap f (Cons a x) = Cons a (f x)

type List a = Fix (ListF a)

nil       = In Nil
cons x xs = In (Cons x xs)

lengthFix = fold f where
                f Nil = 0
                f (Cons _ n) = n + 1

\end{code}</code></pre>
<p>length はそのまま使うとmultiple define だって叱られるんで、とりあえず、 lengthFix としてみる。</p>
<p>…うぅ、あまりにも初めて見る方々が多いので、ちょっとキビシイ。(–; instanceだのFunctorだのぞくぞく新キャラ登場。</p>
<p>まぁ、いろいろ考えた末に一番最後の式から見ていくことにするわけさ。</p>
<pre><code>lengthFix = fold f where
                f Nil = 0
                f (Cons _ n) = n + 1</code></pre>
<p>これはいいねぇ。すっごい抽象的にだけど、イメージは分かる。「lengthFix リストっぽいもの」が「fold f リストっぽいもの」って感じで使われるんじゃ ないかしらん。で、whereってのは、まぁこの文脈でfはこれこれこういうモノ だよってことだね。つまり、fはNilなら0を返して、(Cons _ n)ならnに1を足 すという関数だと。 あっしゃ大域的に名乗るほどの者じゃございやせんとかっ てfを局所的に定義しているようなもんだ。</p>
<p>んん？「リストっぽいもの」を普通のリストだと考えると、ちょっと引っかか るぞ。 Consってデータ構築子だよね。</p>
<pre><code>data ListF a x = Nil | Cons a x</code></pre>
<p>うん、そうだよね。 ListF って型はNilか、もしくは型変数 a x に Cons タ グ付けたものだとするんだけど、もしかしたら a と x は別の型なのかもしれ ない。んー、ってかそうだって書いてあるじゃん。これは変数じゃなくて型変 数なんだから Cons a a じゃなくて Cons a x って書いてあるってことはやっ ぱり別の型なんだよっ。(^^; いや、まぁScheme?のリストでも確かに違うっちゃ違うけどさ。なんか驚いちゃった。</p>
<p>こういう使われ方をするってことは、(Cons _ n)の n には整数が来て、 _ な ワイルドカードにはリストを構成する要素みたいなもんが来るということです な。 Scheme?っぽいリスト表現で書くと、</p>
<pre><code>'(a b c d e f g)   =&gt; (a b c d e f g ())
                   =&gt; (a b c d e f g 0)
                   =&gt; (a b c d e f 1)
                   =&gt; (a b c d e 2)
                   =&gt; (a b c d 3)
                   =&gt; (a b c 4)
                   =&gt; (a b 5)
                   =&gt; (a 6)
                   =&gt; (7)</code></pre>
<p>みたいな感じの計算になるんじゃないか？多分。あくまでだいたいね。そうす るとなんか fold って感じしません？ 次にぽーーんっと飛ぶけど、</p>
<pre><code>out (In x) = x
fold f     = f . fmap (fold f) . out</code></pre>
<p>これと、lengthFixの例を見ると、</p>
<pre><code>lengthFix == fold f
lengthFix リストっぽいもの == fold f リストっぽいもの
                           == f . fmap (fold f) . out   リストっぽいもの
                                                 ~~~~~~~~~~~~~~~~~~~~~~~~</code></pre>
<p>ってなるから、なんとなーくだけど リストっぽいもの == In x で表現される ものって感じじゃないかな。なんて軽く言っちゃったけどfoldの定義が再帰構 造になってるわ、 fmapもあるわで、ちとツライかも。(TヮT)アハハ こーゆー自分の頭を越えたかな〜って時は素直に参りましたm(__)m ってワビ入れてから、具体的な値で計算を追ってみる作戦を採用する。一番簡 単なのはNilとかだよね。こいつはListF型だな。こいつとInていうデータ構築 子とがどう絡んでくるのがはっきりしないんだけど、</p>
<pre><code>instance Functor (ListF a) where
  fmap f Nil        = Nil
  fmap f (Cons a x) = Cons a (f x)</code></pre>
<p>このfmap f Nilって使い方が取っ掛かりになるかな〜？ lengthFix は fold f で、 fold f は f. fmap (fold f) . out だよね。ってことは、In xって感じ で作られた「リストっぽいもの」にoutを適用して得られた xがfmap (fold f) x って感じに適用される訳だな。ってことはxがListF型らしい気がする。そー 思いません？</p>
<p>じゃ、そうだと仮定してNilをInなデータ構築子に渡してみよう。タグ付けさ れるイメージで考えると、In Nil なデータになるね。 そーすっとー、こうだっ！</p>
<pre><code>lengthFix (In Nil) =&gt; fold f (In Nil)                     -- lengthFix の定義
                   =&gt; (f . fmap (fold f) . out) (In Nil)  -- fold の定義
                   =&gt; (f . fmap (fold f)) Nil             -- 適用
                   =&gt; f (fmap (fold f) Nil)               -- 式変形
                   =&gt; f Nil                               -- ListF a　に対するFunctorのメソッド？fmap の定義から
                   =&gt; 0                                   -- lengthFixのwhere部から</code></pre>
<p>おぉおぉぉぉっ！正解くせぇぞ。 (ちなみに上のfが“大域的に名乗るほどのものじゃございやせん”なfなんで一 応確認ね) んじゃ調子に乗って、も少しリストっぽいものを作って動作を追っ てみようか。</p>
<p>………………………………………………………………あ。(‾□‾;)</p>
<p>とんでもないことに気付いちゃった。 Fixにちっとも触れてないよ。(–; さらにこの後でCons使った例をやっても、なんだか触ること無しに終わりそう な予感がするんだけど気のせいか？</p>
<p>えーと、気づかなかったことにして、とりあえず追うよ。</p>
<pre><code>Cons "Hello" Nil</code></pre>
<p>とかしてもいいのかな？えーっと、</p>
<pre><code>instance Functor (ListF a) where
  fmap f Nil        = Nil
  fmap f (Cons a x) = Cons a (f x)</code></pre>
<p>これからすると、Cons a x の x は f x って感じで f に適用されるんだから、 そういう型じゃなきゃダメだね。</p>
<pre><code>lengthFix (In Nil) =&gt; fold f (In (Cons ? ??))
                   =&gt; (f . fmap (fold f) . out) (In (Cons ? ??))
                   =&gt; (f . fmap (fold f)) (Cons ? ??)
                   =&gt; f . fmap (fold f) (Cons ? ??)
                   =&gt; f . Cons ? (fold f ??)</code></pre>
<p>なんだから ?? つまり Cons a x の x は、fold f に適用可能なものじゃなきゃ ダメだ。</p>
<pre><code>fold f     = f . fmap (fold f) . out</code></pre>
<p>だから、 ?? は In x のように In データ構築子で生成されるものなんだ。</p>
<pre><code>Cons ? (In Nil)</code></pre>
<p>とかが Nil の次に簡単な「リストっぽいもの」候補かな。ちなみに ? は結局 値を必要とされないので、多分なんだっていけそうな気がする。 Cons データ 構築子で作られたものはListF型なので、こいつを In で包めば、また別の Cons の cdr (か?)にすることができるね。</p>
<pre><code>In (Cons [1..] (In (Cons [0..] (In Nil))))</code></pre>
<p>こんなんでどうでしょ。なんかとりあえずリストっぽい感じがせんでもないん じゃない？こいつをlengthFixに適用させてやるとどうなるかシミュレートし てみる。</p>
<pre><code>lengthFix (In (Cons [1..] (In (Cons [0..] (In Nil)))))
       =&gt; fold f (In (Cons [1..] (In (Cons [0..] (In Nil)))))
       =&gt; (f . fmap (fold f) . out) (In (Cons [1..] (In (Cons [0..] (In Nil)))))
       =&gt; (f . fmap (fold f)) (Cons [1..] (In (Cons [0..] (In Nil))))
       =&gt; f . fmap (fold f) (Cons [1..] (In (Cons [0..] (In Nil))))
       =&gt; f . (Cons [1..] (fold f (In (Cons [0..] (In Nil)))))
       =&gt; f . (Cons [1..] ((f . fmap (fold f) . out) (In (Cons [0..] (In Nil)))))
       =&gt; f . (Cons [1..] ((f . fmap (fold f)) (Cons [0..] (In Nil))))
       =&gt; f . (Cons [1..] (f . fmap (fold f) (Cons [0..] (In Nil))))
       =&gt; f . (Cons [1..] (f . (Cons [0..] (fold f (In Nil)))))</code></pre>
<p>ふぅ。 あ、くどいけど、このfは例の大域的に名乗るほどの者じゃありやせんのfです よん。 (最初にミスってるなぁ。fold f の f を g とかにしとけばよかった んじゃん) だから、(fold f (In Nil))はさっきやったばっかりのやつね。結 果は 0。</p>
<pre><code>       =&gt; f . (Cons [1..] (f . (Cons [0..] 0)))</code></pre>
<p>ようやくlengthFixのfの一般条件が使える。</p>
<pre><code>lengthFix = fold f where
                f Nil = 0
                f (Cons _ n) = n + 1  -- こいつね。</code></pre>
<p>っちゅーわけで、ゴールまで一直線。</p>
<pre><code>       =&gt; f . (Cons [1..] (f . (Cons [0..] 0)))
       =&gt; f . (Cons [1..] (0 + 1))
       =&gt; ((0 + 1) + 1)
       =&gt; 2</code></pre>
<p>ほっ。なんかよさそうだけど釈然としねぇ。なんで In out を使ったのか、な んで Fix が必要だったのか。再帰の原動力はもともと不動点型にあると予想 してたんだけど、今は fold f の定義がそうじゃん、とか思い始めてるし。</p>
<p>再掲。</p>
<pre><code>\begin{code}

newtype Fix f = In (f (Fix f))

out (In x) = x
fold f     = f . fmap (fold f) . out
unfold f   = In . fmap (unfold f) . f

data ListF a x = Nil | Cons a x

instance Functor (ListF a) where
  fmap f Nil        = Nil
  fmap f (Cons a x) = Cons a (f x)

type List a = Fix (ListF a)

nil       = In Nil
cons x xs = In (Cons x xs)

lengthFix = fold f where
                f Nil = 0
                f (Cons _ n) = n + 1

\end{code}</code></pre>
<p>見返すと、他にも使ってないものがある。 nilとconsだ。もしかしたら、直接 NilやConsやInを使うのが間違ってんのか？</p>
<p>今ごろ気付くとは、不覚！</p>
<pre><code>In (Cons [1..] (In (Cons [0..] (In Nil)))) == (cons [1..] (cons [0..] nil))</code></pre>
<p>おわっ！すげぇ！たったこんだけの事だけど、全然違って見えるわ。こりゃ。 ふーん。なるほどなるほど。</p>
<p>いや、こんなん感心しててもしょうがない。本丸はこっちなんだよな。</p>
<pre><code>newtype Fix f = In (f (Fix f))</code></pre>
<p>うーっ、なんか分かるような分からんような手が届かない感じでキモチ悪い。 fold fの定義の再帰性はlengthを求めるアルゴリズムの再帰性の元で、 Fix f の再帰性は、なんだか「リストに何かをconsしたものもまたリストになる」っ ていうそういう再帰構造の源なんだろうか。再びゴーストがささやいてるんだ けど。（なにせ信用ないからなぁ(–;;）</p>
<p>すっきりしないのは多分 newtype Foo = … な説明は<a href="http://www.sampou.org/haskell/tutorial-j/moretypes.html">入門</a>にもあるんだけど、 newtype Fix f = となった時のことが分かってないからか。ふむ。</p>
<p>えーっと、どっか別の場所にないかいな。やっぱり、<a href="http://www.sampou.org/haskell/report-revised-j/syntax-iso.html">構文リファレンス</a>かなぁ。</p>
<pre><code>topdecls -&gt; topdecl1 ; ... ; topdecln (n&gt;=0) 
topdecl -&gt; type simpletype = type 
 | data [context =&gt;] simpletype = constrs [deriving] 
 | newtype [context =&gt;] simpletype = newconstr [deriving]    -- これね
 | class [scontext =&gt;] tycls tyvar [where cdecls] 
 | instance [scontext =&gt;] qtycls inst [where idecls] 
 | default (type1 , ... , typen) (n&gt;=0) 
 | decl </code></pre>
<p>このnewtype宣言から始まって、今のケースではcontextは無いから、 simpletypeがFix fだ。</p>
<pre><code>simpletype -&gt; tycon tyvar1 ... tyvark (k&gt;=0) </code></pre>
<p>というわけでFixが型構築子でfが型変数。うーん。合ってるなぁ。</p>
<pre><code>tyvar -&gt; varid (type variables) 
tycon -&gt; conid (type constructors) </code></pre>
<p>ほれ、この通り。 (f (Fix f))みたく使われているんだからやっぱり型変数f は関数型のデータなんだよね。なんも新しい発見が無かった。orz</p>
<pre><code>newtype Fix f = In (f (Fix f))</code></pre>
<p>以前確認した通り、左辺のFixは型構築子で右辺のInはデータ構築子で、右辺 のFixは型構築子だ。ここで、ちょっと視点を変えてっていうか戻して、</p>
<pre><code>(cons [1..] (cons [0..] nil))</code></pre>
<p>こいつと見比べてみよう。 fって型変数によって代表されるのはnilとか(cons [1..])のような関数になる のかな。実際nilは無引数の関数で(cons [1..])は一引数の関数だ。 nilを (nil (Fix f))って感じで適用されることはないけど、 (Fix nil)ってのはア リアリなんだよね。（あ、もちろん意味的にってことであって実際の式じゃな いです、キモチの話ね） つまり、Fix fは nil とか Fix f にcons ??な関数を適用した結果できるもの だと。（なお、cons とか nil とかの場合にはInは含まれているのに注意） おおぉ、全てがかみ合ってきたぞい！？もしかしてようやくたどり着いたか？ （どこに！？）</p>
<p>そうすると、なんか新しい視点が開けた感じだな。</p>
<pre><code>(cons 1 (cons 2 (cons 3 ())))
                        ~~
                        ↑
                        ()は値→値はthunk→thunkは無引数の関数→()は関数の仲間だよね</code></pre>
<p>とみなすことから始まって、</p>
<pre><code>(cons 1 (cons 2 (cons 3 ())))
                ~~~~~~~
                  ↑
                  cons 3 をcurry化して関数とみなす
                  Scheme なら (cut cons 3 &lt;&gt;) なキモチ</code></pre>
<p>てな風にする。()がfでcons ??もfの仲間。生成されるリストってやつがFix f で表現されるもの。つまり、リストにfを適用したものがリストになる。くど いけど、()またはリストにcons ??を適用した結果できるのはリスト。そう見 るとリストって不動点型ってわけだね。</p>
<p>ではでは、実機確認！！</p>
<pre><code>Main&gt; lengthFix nil
0
Main&gt; lengthFix (cons 1 (cons 2 (cons 3 nil)))
3
Main&gt; lengthFix (cons [1..] (cons [0..] nil))
2</code></pre>
<p>へっへっへー！やったネ！！(^^)v</p>
<p>そうすると配列も同じように不動点型として定義できそうな気がするぞ。配列 に (++) すると配列になる、とかね。この場合は f は ((++) [1..]) みたい な感じでさ。 nilに相当するのは当然[]だろう。おおっ、全体を書く根性も能 力もまだまだないけどなんかできそうじゃん。</p>
<p>ありゃ？そうすっと整数も整数に足し算（や引き算）をすることで整数になる わけだから、これも不動点型か？おいおい(^^;)</p>
<p>えーっと、ちょびっとだけチャレンジ。</p>
<pre><code>lengthFix = fold f where
                f Nil = 0
                f (Cons _ n) = n + 1

consFix = fold f where
                 f Nil = []
                 f (Cons x xs) = x:xs

strAppendFix = fold f where
                      f Nil = ""
                      f (Cons x xs) = x ++ xs

intFix = fold f where
                f Nil = 0
                f (Cons x y) = x + y</code></pre>
<p>なんだかconsFixってのは変な名前だけど、</p>
<pre><code>Main&gt; consFix (cons 1 (cons 2 (cons 3 nil)))
[1,2,3]

Main&gt; strAppendFix (cons "Hello" (cons "," (cons "World" (cons "!" nil))))
"Hello,World!"

Main&gt; intFix (cons 10 (cons 20 nil))
30</code></pre>
<p>残念ながらconsFixの場合には[]がshow出来ないのでエラーでちゃうけどね。(^^; ま、あとは全く同じConsの定義をplusとかstring-appendみたく、いい名前に 付け直してやれば、それっぽくなるんじゃない？</p>
<blockquote>
<p>「fって型変数によって代表されるのはnilとか(cons [1..])のような関数」で はありません。</p>
<pre><code>type List a = Fix (ListF a)</code></pre>
<p>この定義を見れば分かりますが、f はこの場合 (ListF a) です。また、以前出した例</p>
<pre><code>Main&gt; :t In Nothing
In Nothing :: Fix Maybe</code></pre>
<p>では、f は Maybe です。</p>
<p>つまり、f には、(ListF a) や Maybe のような「型を受け取って新たな型を 返す関数(のようなもの)」が入ります。正確に言うと、f には、類 ‘*→*’ を 持つ型が入る事になります。 (<a href="http://www.sampou.org/haskell/tutorial-j/classes.html">入門</a>の「類」の説明を参照)</p>
<p>あと、lengthFix, strAppendFix, intFix は、length, concat, sum の [a]を List aに置き換えたものですし、consFix は List a-&gt;[a] のコンバータなの で、不動点型を定義しているわけではありません。</p>
<p>そもそも、型の不動点のキモは、</p>
<pre><code>data List a = Nil | Cons a (List a)</code></pre>
<p>のような再帰的な型を、再帰を使わずに</p>
<pre><code>data ListF a x = Nil | Cons a x
type List a = Fix (ListF a)</code></pre>
<p>のように定義できる、という所にあります。</p>
</blockquote>
<h3 id="るるる類kindって">る、るる、類(kind)って？</h3>
<p>えっと、まず神の示された類っちゅー単語に意識集中して 入門を読みませう。</p>
<p>読みましたか？私は以前も読んでたハズなんだけど、こんな内容だったっけ？っ て位初めて読んだ感じ。(–;; いや、以前は読めてなかったんでしょう。実は先日来CLOS系のお勉強なんぞも やってて、その副作用かもしれないけど、類が出てくるまでの前半部分は結構 すんなり頭に入ってきました。はい。総称関数とメソッドの関係みたいなのが ここにもあるなーとか思っちゃいましたよ。 少なくとも類が出てくるところまではね。</p>
<p>んじゃ、どこで躓いたかっていうと…</p>
<pre><code>ここまで、「第一級の」型を使ってきました。
つまり、型構築子 Tree はこれまで常にひとつの引数と組になっていました。
たとえば、 Tree Integer ( Integer 型の値を含む木)、
あるいは、 Tree a ( a 型の値を含む木の族をあらわす)です。
しかし、Tree それ自身は型構築子であり、ひとつの型を引数としてとり、
ひとつの型を返します。Haskell にはこの種の値はありませんが、
このような「高階の」型はクラス宣言のなかで使用することができます。</code></pre>
<p><a href="http://www.sampou.org/haskell/tutorial-j/classes.html">型クラスと多重定義</a>からの引用ですが、この中の最初の文ね。</p>
<p>あれぇ？確か型は第一級じゃないよって言ってなかったか？と思ったわけです。</p>
<pre><code>Haskell の値はすべて「第一級の対象」です。
すなわち、関数の引数、関数の返り値、になり得ます。
また、データ構造などのなかに入れることもできます。
一方、Haskell の型は「第一級の対象」ではありません。</code></pre>
<p>あ、コレコレ。 値、型その他の有用な概念 にきっちりうたっとりまんがな。 (-"-)うーっむ。</p>
<blockquote>
<p>「値、型その他の有用な概念」に出てくる「第一級の対象」と「型クラスと多重定義」に出てくる「第一級の」とは別物です。</p>
<p>「値、型その他の有用な概念」に出てくる「第一級の対象」は ‘first-class’ の訳で、「型クラスと多重定義」に出てくる「第一級の」は ‘first-order’ の訳です。</p>
<p>個人的には、‘first-order’ は「一階の」と訳すべきだと思います。</p>
<ul>
<li>御指摘の通りこれは明らかな誤訳です．修正しました．– nobsun (2005/03/25 09:05:47 JST)</li>
</ul>
</blockquote>
<p>なるほど、確かにfirst-orderになってました。という訳で、訳文訂正のフィー ドバックをかけておいて先へ進みましょう。</p>
<p>そうすると、型構築子のうち、「型を引数に取って型を返す」という「高階の 型」なんちゅうもんが出てきちゃいました。 高階って聞くと なんだかまたすごいことが記述できちゃうのか？ ってワクワ クしませんか？そー思うワタシはビョーキですかね。。。(^^;;; 高階関数なんてもんが使えるようになった時、ちょっとの違いが大違い、そ りゃーもーキノコ食ったヒゲおじさんくらいパワーアップしたの覚えてますよ。</p>
<p>ここでもどうやら</p>
<pre><code>こうした能力は大変便利なものです。
これは総称的「コンテナ」型を記述する能力のあることを示し、
fmap のような、任意の木、リストあるいは他の型の上で
統一的に動作する関数を可能にします。</code></pre>
<p>と、なにやら魅惑的な誘い文句が書かれとります。魅惑的ってのは○○を記述 する能力のあるって文言のことです。もうLLプログラマにとっては垂涎ものの 殺し文句じゃないかい？</p>
<p>しかも驚いたことに、すでにこういう型構築子を扱ってたんだとさ。</p>
<pre><code>[型適用は関数適用とおなじやりかたで書きます。
型 T a b は (T a) b のように構文解析されます。
タプルのような特別な構文を使う型はカリー化可能な別のスタイルで書きます。
関数については、 (-&gt;) が型構築子です。
f -&gt; g と (-&gt;) f g とは同じです。同様に、[a] と [] a とは同じです。
タプルについては、型構築子(同時にデータ構築子でもありますが)
は (,)、(,,) などとなります。]</code></pre>
<p>ということで -&gt; とか [] がまさにそうなんですって。確かに f -&gt; g を (-&gt;) f g とか書くと分かるような気もする。</p>
<p>んで、類ってなんじゃ？というと、</p>
<pre><code>型式は別々の類に分類されます。これは次の 2 つの形式をとります。

 +  記号 * は具体的なデータ対象に結びついた型の類をあらわす。
   すなわち、 もし、値 v の型が t であるなら、v の類は * で なければならない。

 +  もし、k1 と k2 とが類ならば、k1-&gt;k2 は k1 という類の型をとり、
   k2 という類の型を返す型の類である。

型構築子 Tree の類は、 *-&gt;* であり、Tree Int の類は * です。
Functor クラスのメンバーはすべて、類 *-&gt;* でなければならず、
類付けのエラーは、次のような宣言により引き起こされます。</code></pre>
<p>…む、ムツカシイ(-"-; わざとやってねぇか？Haskell！？ えっと、なんかの型があるとして、そいつが具体的なデータの型をあらわして るなら、類*で、型を引数に取って型を返すような型の場合には*-&gt;*って感じ で高階の型って扱いになると。 Treeの例を見ると分かるような気にさせられ るんだけど。。。通常の(曖昧な言葉だなぁ)型の類は*で高階の型の場合には *-&gt;*とか*-&gt;*-&gt;*とかって思っていいのかな。</p>
<p>もっかい神の助言を読み返すか。</p>
<pre><code>つまり、f には、(ListF a) や Maybe のような
「型を受け取って新たな型を返す関数(のようなもの)」が入ります。
正確に言うと、f には、類 '*→*' を持つ型が入る事になります。</code></pre>
<p>んー、ってことはfはなんらかの関数型が来るってことじゃねーかい？いや、 形からしてさ、*-&gt;*ってのがいかにもそんな感じ。つまりfのとこにはただの 型じゃなくてなんか関数型に分類されるものが来ると。</p>
<pre><code>data List a = Nil | Cons a (List a)</code></pre>
<p>のような再帰的な型を、再帰を使わずに</p>
<pre><code>data ListF a x = Nil | Cons a x
type List a = Fix (ListF a)</code></pre>
<p>のように定義できる</p>
<p>ってのが型の不動点のキモだってことなんだけど、この関係だけ確認しておこ う。</p>
<h3 id="myeqクラスってヤツ">MyEqクラスってヤツ</h3>
<p>えー、確認しておこう。なーんつってナレーション風に書いておいて放置プレ イすること７ヵ月。 長き沈黙をやぶり、今再びはじめちゃおうかな。</p>
<p>気づけば*.lhsなファイルをEmacsに読み込んでもhaskell-modeにならないわ、 C-cC-lしてもマトモに評価できないわ。 完全に忘れてしまってて足腰がなまってしまってたんで、よちよち歩きがます ますぐずぐずに。そりゃもう狂牛病になった牛みてーな状態。</p>
<p>世の中には1ヵ月でHaskellを学んで、次の1ヵ月でPerl6を実装してしまうっつー 変態もいるっちゅーのにね。(-,-;;</p>
<p>まぁ雑談はほどほどにして早速書いてみる。</p>
<pre><code>\begin{code}

class MyEq a where
    (===) :: a-&gt;a-&gt;Bool

instance MyEq Integer where
    a === b = a == b

data Foo = Foo Integer String

instance MyEq Foo where
    Foo x _ === Foo y _ = x === y

\end{code}</code></pre>
<p>実はね、クラスとか型とかが難しいYo!って愚痴ったら示してくれたのが上の 様なコード。実際に自分で書き下ろしてちゃんとHugsにロードできる様になる までに四苦八苦したよ。</p>
<p>でもデバッグする際にあらためて ここを読んでたら、まんま書いてあんじゃん。</p>
<p>毎度のことながら読んで分からない文言てのはまるで記憶に残らないもんだねぇ としみじみ。</p>
<p>まぁ、７ヵ月の休養の結果、なぜかちょびっとだけ分かるようになった、こい つを餌に再スタートを切ってみよう。いっくぽーーーーっん！！</p>
<h3 id="同じとは">同じとは？</h3>
<p>例えば仮に彼女がキュートな笑顔で</p>
<p>「りんごとバナナは同じだよね」</p>
<p>なーんて目頭がアツクなるほどイタイことをのたまったとしよう。</p>
<p>いや、イタイと思わずに「そうそう！俺もそー思うYo!」とかって逝ってしまう人もいるかもしれん。でもさ、イタイかどうかは同じって言葉の意味というか定義によるわけよね。</p>
<p>でも物凄く不思議ではあるんだが、それ以前に同じって言葉の定義ではなく、 同じという言葉の出現する文脈ってのは共通したものとして存在している。それは</p>
<p>「○○と××は同じか否か？」 「同じだ」もしくは「違うよ」</p>
<p>という、なんつーの？二つの対象をならべて、真偽を問うという体系のようなもの。</p>
<p>別の例を挙げてみる。</p>
<p>「▲▲君ってジャイアント馬場よりデッカイよね」</p>
<p>という、これまたビミョーな発言があったとしよう。これは身長を比較してい るのか、心の広さを比較しているのか、はたまたナニを比較しているのか分か らんが、それでもデカイか？という言葉が出現する文脈において共通するもの があるわけやね。</p>
<p>「○○と××ではどちらがデカイか」 「そりゃ○○よ」とか「××なんじゃん？」とか「一緒だよ」</p>
<p>などですな。 あるいは、もちっと高度な応用をきかして</p>
<p>「○○と××と△△と□□ではどれが一番でっかい？」 「△△かな」とか「☆☆はでかいぞ」とか「しらね」とか。</p>
<p>まぁ、とりあえず「同じ」の例でコードを組んだので、そっちで考えてみるこ とにしよう。</p>
<pre><code>class MyEq a where
    (===) :: a-&gt;a-&gt;Bool</code></pre>
<p>これはまさに「同じ」の定義ではなく「同じ」という言葉が使われる文脈を決 めているんじゃないかと思うわけよ。実際、</p>
<pre><code>a(○○)とa(××)は同じ？-&gt;Bool(同じだ/違うよ)</code></pre>
<p>って感じに見えるよね？ 少なくとも</p>
<p>「りんごと同じがバナナ？」</p>
<p>なーんて世界が真っ白になるほどブッ飛んだ発言は同じという概念の枠には無 いんだよね。先程の彼女のイタイ発言もここまではイタクないわけだが、それ はa-&gt;a-&gt;Boolには当てはまっているからでしょうね。 だから辛抱強い人だったら「その同じってどういう意味でいってんの？」と定 義をもとめるワケですな。 でもって、</p>
<pre><code>instance MyEq Integer where
    a === b = a == b</code></pre>
<p>これがIntegerについてMyEqという同じの概念を規定した時の定義だと思う。 多分ね。ここでIntegerについて語る時には同じってのはこういうことだ！っ てー感じの判断基準を与えておるようだ。</p>
<p>つまり「フルーツだから同じ？→YES」なのか「果物の種類として同じ→NO」 なのか、あるいは「このりんごとあのりんごは同じ？」の場合でも「色が違う」 「品種が違う」「産地が違う」「糖度が違う」「存在している位置座標が違う」 などなど、そういう定義がInteger上でされたりNumber上でされたり、まぁそ んな感じなんでしょう。</p>
<p>だから</p>
<pre><code>data Foo = Foo Integer String

instance MyEq Foo where
    Foo x _ === Foo y _ = x === y</code></pre>
<p>ってすれば、Fooってタグのついたデータ構造に対しても同じかどうかを議論 することが出来るんですな。 ここではFooには２つのスロット値というかメンバデータとでもいうものがあっ て、例えばこれが年齢と名前だとすると、年齢が同じなら同じとしようよって ことでしょう。 Foo 34 “cut-sea”もFoo 34 “羽生善治”も「同じ」なんですよ、誰がなんとい おうとさ。いや、同じなのです！ソコ！妙なツッコミいれないよーに。</p>
<p>Hugsで評価してみると、こんな感じ。</p>
<pre><code>Main&gt; Foo 1 "hoge" === Foo 1 "foo"
True</code></pre>
<p>うむ。似たようなのをも一個。</p>
<pre><code>data Fluit = Fluit String

instance MyEq Fluit where
    Fluit x === Fluit y = True</code></pre>
<p>これはFluitなタグさえついてりゃ同じは同じですね。</p>
<pre><code>Main&gt; Fluit "Apple" === Fluit "Banana"
True</code></pre>
<p>よし、少しずつ調子が出て来た。 どうせxとかyの部分を無視させるんだったら、これはどうよ？</p>
<pre><code>data Fluit = Fluit a   &lt;= ここをStringからaにしてみた

instance MyEq Fluit where
    Fluit x === Fluit y = True</code></pre>
<p>うりゃ！(C-cC-l)</p>
<pre><code>Main&gt; :load /home/cut-sea/script/haskell/class.lhs
Reading file "/home/cut-sea/script/haskell/class.lhs":
ERROR "/home/cut-sea/script/haskell/class.lhs":21 - Undefined type variable "a"
Prelude&gt; </code></pre>
<p>あうっ！！(久々に食らってちょっとカンドー)</p>
<blockquote>
<p>値は無視できても型は無視できないよ．</p>
<p>instance Eq Fruit where</p>
<pre><code>  (==) = const . const True</code></pre>
<p>でどう？</p>
</blockquote>
<p>って浸っててもショーガネーってことで、Treeとかの定義を再度見てみる。ははぁ。</p>
<pre><code>data Fluit a = Fluit a

instance MyEq Fluit where
    Fluit x === Fluit y = True</code></pre>
<p>えいや！</p>
<pre><code>Main&gt; :load /home/cut-sea/script/haskell/class.lhs
Reading file "/home/cut-sea/script/haskell/class.lhs":
ERROR "/home/cut-sea/script/haskell/class.lhs":23 - Illegal type in class constraint</code></pre>
<p>むむ？えーっとあてずっぽだけど、23行目ってのは手元では</p>
<pre><code>instance MyEq Fluit where</code></pre>
<p>この行だ。っちゅーワケだから、</p>
<pre><code>data Fluit a = Fluit a

instance MyEq (Fluit a) where
    Fluit x === Fluit y = True</code></pre>
<p>こうしてみる。いや全然根拠無いし分かっちゃいないが、これでMainプロンプ トがオメミエ。うーん。なんでじゃろ?(^^; まぁとりあえず使ってみるなり。</p>
<pre><code>Main&gt; Fluit "APPLE" === Fluit "BANANA"
True
Main&gt; Fluit 1 === Fluit 3
True</code></pre>
<p>当然次なる疑問は、</p>
<pre><code>data Foo = Foo Integer</code></pre>
<p>と</p>
<pre><code>data Foo Integer = Foo Integer</code></pre>
<p>とはどう違うんぞなもし？という点なんだが、そもそも下の定義は可能なんだ ろうか？型変数aで出来るのはわかってるんだが。 Hugsにきいてみよう。</p>
<pre><code>data Bar Integer = Bar Integer</code></pre>
<p>んでエバってみると…</p>
<pre><code>Main&gt; :load /home/cut-sea/script/haskell/class.lhs
Reading file "/home/cut-sea/script/haskell/class.lhs":
ERROR "/home/cut-sea/script/haskell/class.lhs":29 - Illegal left hand side in datatype definition
Prelude&gt; </code></pre>
<p>うーむ。なんか予感は当たったんだが、単にIllegal left hand side in datatype definitionだって。もちっと噛み砕いた説明くれーーー！！ まぁSyntax上正しくないってことだろうが、なぜ書けない？</p>
<p>んじゃaを出しておきながら使わないとどうなる？</p>
<pre><code>data Bar a = Bar Integer</code></pre>
<p>…いけますなぁ。んじゃあ全く違ったらどうよ。</p>
<pre><code>data Bar a = Bar b

Main&gt; :load /home/cut-sea/script/haskell/class.lhs
Reading file "/home/cut-sea/script/haskell/class.lhs":
ERROR "/home/cut-sea/script/haskell/class.lhs":26 - Undefined type variable "b"</code></pre>
<p>ふむ。 規則は分かる。左辺は今から多分定義しようとしている何者かなので、 (型) 変数がくるべき。右辺は定義済み、もしくは今定義しようとしている部分に無 いとダメ。 ありゃ？当り前なのか？</p>
<p>じゃあ単に</p>
<pre><code>data Foo = Foo Integer</code></pre>
<p>と</p>
<pre><code>data Foo a = Foo Integer</code></pre>
<p>の違いはFooを(Foo a)としただけのこと？後者の何が嬉しいかっていわれたら 多分これだと嬉しくない。</p>
<pre><code>data Foo a = Foo a</code></pre>
<p>ってするとさっき試した時みたいにa部分に色々取り得てウレシイってことかな。</p>
<p>左辺の型変数ってやつがどうも何者なのか分かりにくいのでも少しいじってみる。</p>
<pre><code>data Hoge a a = Hoge a a </code></pre>
<p>これはどうさ?</p>
<pre><code>Main&gt; :load /home/cut-sea/script/haskell/class.lhs
Reading file "/home/cut-sea/script/haskell/class.lhs":
ERROR "/home/cut-sea/script/haskell/class.lhs":26 - Repeated type variable "a" on left hand side</code></pre>
<p>うーんくりかえし出ちゃダメってか。当然これはイけるんだよね？</p>
<p>data Hoge a b = Hoge a a</p>
<p>うん。ちとマニュアルを読んでみるか。</p>
<blockquote>
<p>左辺の型変数については、関数定義の仮引数と同じように考えればいいのではないでしょうか。</p>
<p>たとえば、型 x -&gt; y -&gt; x の関数 hoge の定義</p>
<p>hoge a b = a</p>
<p>と、類 * -&gt; * -&gt; * の型 Hoge の定義</p>
<p>data Hoge a b = Hoge a a</p>
<p>を比較すれば、左辺の変数の意味がわかりやすいと思います。</p>
<p>同様に、型定義を関数定義と置き換えて考えれば、なぜエラーが起こるかもはっ きりすると思います。</p>
</blockquote>
<p>なんと！？そうかー</p>
<pre><code>data Hoge a b ...</code></pre>
<p>とあったときに、a/bってのは位置が問題なのではなく、Hogeという型では２ 種類の型変数を使うよってことだけが重要なのかな？つまり第一引数(?)の型 変数とか第二引数の型変数とかっていう位置を表すシンボル(の型) じゃなく て、単にHogeってのは二種類の型をつかうって定義されるものだよ、と。</p>
<p>そういや、データを構築するのは右辺の定義なんだから、引数の位置ってか何 番目の引数ってのは重要だろうけど、左辺はそもそも関係なさげだわなぁ。</p>
<p>ってことは、</p>
<pre><code>data Hoge = ...</code></pre>
<p>なHogeって型は他の型には一切依存しない、言い方を変えると、他の型の存在 を一切仮定せず定義される型なんだね。</p>
<p>んだらば一応確認しておこう。</p>
<pre><code>data Fuga = Fuga [String]

instance MyEq Fuga where
    Fuga s1 === Fuga s2 = length s1 == length s2</code></pre>
<p>あう。訂正…「他の型には一切依存しない」じゃなくて「他の変数な型には一 切依存しない」か。でもそもそも左辺には型変数しかないわけで、Integerみ たいな型が書けるわけじゃないもんねぇ。なんかもって回った書き方になるけ ど、うーん、拘るのはヤメっか。</p>
<pre><code>data FugaS a = FugaS [a]

instance MyEq (FugaS a) where
    FugaS s1 === FugaS s2 = length s1 == length s2</code></pre>
<p>でもって評価すると、もうバッチリ。いや、めちゃめちゃ簡単な例なんだけど さ、分かって書いてる感があるってのが進歩なわけよ。はい。</p>
<pre><code>Main&gt; Fuga [] === Fuga []
True
Main&gt; Fuga ["", "", ""] === Fuga ["abc", "xyz", "123"]
True
Main&gt; Fuga ["", "", ""] === Fuga ["abc", "xyz"]
False
Main&gt; FugaS [] === FugaS []
True
Main&gt; FugaS ["", "", ""] === FugaS ["abc", "xyz"]
False
Main&gt; FugaS [1, 2, 3] === FugaS [12, 23, 34]
True
Main&gt; FugaS ['a','b','c'] === FugaS "ABCDEF"
False</code></pre>
<p>やったね！！ ちょっとだけ開眼(した気になってる)。</p>
<p>じゃあ引続き、今度はtypeだかnewtypeだかを学びませう。</p>
<blockquote>
<p>既に理解されているとは思いますが、念のため追加で説明します。</p>
<p>まず、型定義の左辺に変数が許されない場合にどうなるかを考えます。そうす ると、Integer の木が必要な場合、String の木が必要な場合で、別々の定義 を書かなければなりません。</p>
<pre><code>data IntegerTree = IntegerLeaf Integer | IntegerBranch IntegerTree IntegerTree
data StringTree = StringLeaf String | StringBranch StringTree StringTree</code></pre>
<p>別の型の木を作るたびに定義し直すのは面倒なので、好きな型を渡せば、その 型の木を作ってくれるような関数を考えます。</p>
<pre><code>data Tree a = Leaf a | Branch (Tree a) (Tree a)</code></pre>
<p>そうすれば、いちいち使う型ごとに定義し直さなくても、Integer の木が欲し ければ (Tree Integer) を、 String の木が欲しければ (Tree String) を使 えば良くなります。</p>
<p>型定義の左辺の変数は、後々ユーザが好きな型を渡すための受け口の役割を果 たします。これは関数の仮引数の役割と同じですよね。</p>
</blockquote>
<p>まずtype！</p>
<pre><code>type String             = [Char]
type Person             = (Name,Address)
type Name               = String</code></pre>
<p>うははっ、もらい。これは簡単じゃね。単に別名として使えるようにしてんだ ろう。つまり、[Char]って書く代わりにStringって使えるだけだ。 Cでいうと ころのtypedefだろう。</p>
<p>ではそそくさとnewtypeへいっちゃおう。例の初心者に<a href="http://www.sampou.org/haskell/tutorial-j/moretypes.html">やさしくない入門</a>によれば、</p>
<p>表現が既存の型と同一だが，型システムの中では別の型として識別されるよう な型を定義</p>
<p>だそうだから、さっきのtypeとは別の型として識別される点で違うんだろう。</p>
<p>さっきから「だろう」ばっかしでちゃんと確認してないので、少しHugsに聞い て確認してみよう。直観的にはCLOSのclass-ofみたいなのがあればいいんだけ ど、なんかHaskellには無いような気が…。</p>
<pre><code>type Name = String
data Foo = Foo Name deriving Show</code></pre>
<p>んで動作確認はこれ。</p>
<pre><code>Main&gt; Foo "My Name"
Foo "My Name"</code></pre>
<p>おっけー。じゃあ間違ってみよう。(なんだこの表現は)</p>
<pre><code>Main&gt; Foo 123
ERROR - Unresolved overloading
*** Type       : Num [Char] =&gt; Foo
*** Expression : Foo 123</code></pre>
<p>どーよ？ん？ちゃんと[Char]だと言ってる。つまりあくまで推測だけど、Nameっ て読み込んだ時点で[Char]に置き換わってんじゃないかな。内部的にはもう区 別つかないんだろう。多分。 Stringってのも結局置き換わって[Char]になっ ちゃうわけだしさ。</p>
<p>そいでは次newtypeでやってみる。</p>
<pre><code>newtype Namex = MakeNamex String
data Bar = Bar Namex deriving Show</code></pre>
<p>んでエバって…</p>
<pre><code>Main&gt; :load /home/cut-sea/script/haskell/class.lhs
Reading file "/home/cut-sea/script/haskell/class.lhs":
ERROR "/home/cut-sea/script/haskell/class.lhs":42 - An instance of Show Namex is required to derive Show Bar</code></pre>
<p>あらら。だめじゃん。 deriveがダメとか言ってやがんのかな？</p>
<pre><code>newtype Namex = MakeNamex String
data Bar = Bar Namex</code></pre>
<p>これなら確かにMainプロンプトがでてくれる。ん？んん？…もしかしてこれ自 体が証拠か？？？？ つまりさっきのtypeの時にはNameがShowなStringそのものだから文句も言われ なかったと。</p>
<p>で、Namexは全く新しい型だから、まずBarをShowするには NamexをShowを deriveしてやらんとだめだよと。</p>
<pre><code>newtype Namex = MakeNamex String deriving Show
data Bar = Bar Namex deriving Show</code></pre>
<p>おおっ！！Main出現！！やたっ！！すばらしい。 では動作確認。</p>
<pre><code>Main&gt; Bar "My New Name"
ERROR - Type error in application
*** Expression     : Bar "My New Name"
*** Term           : "My New Name"
*** Type           : String
*** Does not match : Namex</code></pre>
<p>はうっ。。。 えーっとマニュアルマニュアル…。あ、そういうこと。。。</p>
<pre><code>Main&gt; MakeNamex "My New Name"
MakeNamex "My New Name"</code></pre>
<p>よし。</p>
<pre><code>Main&gt; Bar MakeNamex "My New Name"
ERROR - Type error in application
*** Expression     : Bar MakeNamex "My New Name"
*** Term           : Bar
*** Type           : Namex -&gt; Bar
*** Does not match : a -&gt; b -&gt; c</code></pre>
<p>あうっ。もしかしてこう？</p>
<pre><code>Main&gt; Bar (MakeNamex "My New Name")
Bar (MakeNamex "My New Name")</code></pre>
<p>おおーっ。なんだかnewtype使う意味がワカンネー。 ま、いーや。とりあえず、MakeNamexってのがNamexな新しい型のコンストラク タっぽいもんなわけね。いいです。そういうことで、今日のところは。ハイ。</p>
<p>あ、ゴメンゴメン。忘れるとこだった。さっきのエラーの、Typeを見てみると [Char] -&gt; Bar じゃないとこがnewtypeですな。</p>
<pre><code>*** Type           : Namex -&gt; Bar</code></pre>
<p>おそらくね〜。</p>
<h3 id="まだ不動点はムリ">まだ不動点はムリ</h3>
<p>えーっと後ろを振り返るとやっぱ型の不動点は心残りなんだが、どうも今見て も理解できん。</p>
<p>んで、何が自分で分かんないのか突き詰めるとこれだ。</p>
<pre><code>newtype Namex = MakeNamex String deriving Show
type Name = String
data Foo = Foo Name deriving Show
instance MyEq Fuga where
    Fuga s1 === Fuga s2 = length s1 == length s2</code></pre>
<p>みたいにNamexやNameやFooやMyEqとかってシンボルが出てくると、これらのシ ンボルについて定義してるっつーか宣言してるっつーか、そういうのが分かる んだが、</p>
<pre><code>newtype Fix f = In (f (Fix f))
        ~~~~~~
type List a = Fix (ListF a)
     ~~~~~~
data ListF a x = Nil | Cons a x
     ~~~~~~~~~~
instance Functor (ListF a) where
         ~~~~~~~~~~~~~~~~~
  fmap f Nil        = Nil
  fmap f (Cons a x) = Cons a (f x)</code></pre>
<p>とかって出てくると、これらは何について定義してるのか良く分かんないんす。 はい。ちょっと探したとこだとclassではそういうの見当たんなかったけどさ。</p>
<p>たとえばSchemeだと</p>
<pre><code>(define (f x y) (* x y))</code></pre>
<p>ってのが出て来ても、</p>
<pre><code>(define f (lambda (x y) (* x y)))</code></pre>
<p>と同じことだって言われると、なーんだーって分かる気がする。 (んじゃない かと思う。今となってはScheme?知らない人の気持ちがわからんけど) ま、まま、それと同じように、</p>
<pre><code>data ListF a x = Nil | Cons a x</code></pre>
<p>これは</p>
<pre><code>data ListF a = ???</code></pre>
<p>と同じだよーとか、</p>
<pre><code>instance Functor (ListF a) where</code></pre>
<p>これは</p>
<pre><code>instance Functor ListF where  ????</code></pre>
<p>と同じなんだよってのがあると分かるかもしれんとかナンクセをつけてみたりね。</p>
<blockquote>
<p>ListFを直接そのように定義する事は(多分)できないのですが、このような説 明はどうでしょうか。 (ただ、私の場合、「やさしいHaskell入門」をすべて読み終えた後でも、型の 不動点の話を理解するのに苦労したので、どうしても分からないようなら無視 して別の内容を学ぶ事をお勧めします。)</p>
<p>型を値の集合(リスト)と考えます。そうすると、整数型と文字型は以下のよう に表せます。 (要素を全部書くと煩雑なので一部だけにしてあります)</p>
<pre><code>int = [1, 2]
char = ['x', 'y']</code></pre>
<p>ここで、この型を扱う関数として、以下の2つのものを考えます。まず、それ ぞれの要素を一つずつとって、組み合わせた新しい型を生成するdprod。</p>
<pre><code>dprod a b = [(x, y) | x &lt;- a, y &lt;- b]</code></pre>
<p>intとcharに適用すると以下のようになります。</p>
<pre><code>*Main&gt; dprod int char
[(1,'x'),(1,'y'),(2,'x'),(2,'y')]</code></pre>
<p>もう一つは、それぞれの要素をすべて含んだ新しい型を生成するdsum。ただし、 もともとどちらの要素であったかをはっきりさせるために、片方の要素の前に Left、もう片方の要素の前にRightをつけます。</p>
<pre><code>dsum a b = [Left x | x &lt;- a] ++ [Right y | y &lt;- b]</code></pre>
<p>intとcharに適用すると以下のようになります。</p>
<pre><code>*Main&gt; dsum int char
[Left 1,Left 2,Right 'x',Right 'y']</code></pre>
<p>さて、この枠組みでListFがどうなるのかを考えてみましょう。</p>
<pre><code>data ListF a x = Nil | Cons a x</code></pre>
<p>これは、型ListF a xの要素はNilかCons a xのどちらかである、という宣言で す。どちらか、ということは、dsumが使えます。また、Nilは要素が1個の型と みなせるので[()]で表し、Cons a xは型aと型xの要素を一つずつとるので dprodで表せます。</p>
<pre><code>listF a x = [()] `dsum` dprod a x</code></pre>
<p>lambda式の方が理解しやすいのであれば以下をどうぞ。</p>
<pre><code>listF = \a x-&gt;[()] `dsum` dprod a x</code></pre>
<p>intとcharに適用すると以下のようになります。</p>
<pre><code>*Main&gt; listF int char
[Left (),Right (1,'x'),Right (1,'y'),Right (2,'x'),Right (2,'y')]</code></pre>
</blockquote>
<h3 id="あやしい集会">あやしい集会</h3>
<p>先日あやしい集会に行ってきました。 その怪しさといったら筆舌に尽くし難いわけで、一体どこに隠れていたのか、 明らかにまっとうな社会生活を送れてるとは思えない生命体が20人近く一同に 会するわけです。 以前キャッチーなお姉さんに捕まった時もヤバイとは思いましたが、そんなの 比じゃないです。お姉さんの場合は心は腐ってましたが見た目はキレイだった ので、結婚してくれるなら買ってもいいと言い張り、今すぐ役所に行こう、今 すぐ入籍してくれたら君を連帯保証人にして買いましょうと迫ったわけです。 残念ながら性格の不一致とでも申しましょうか、婚姻にはいたらなかったわけ ですが、これはこれでHaskellに比べれば案外ちょろいもんでした。(意味不明)</p>
<p>えーっと何の話だっけ、あ、そうそうその怪しい集会のおかげでちょっとだけ モナドが怖くなくなりました。まぁ、それもあるし、ここも長くなってきたし、 潜入ルポも兼ねて(兼ねてないです。念のため) <a href="Programming_WayToHaskeller_てくてく.html" class="uri" title="Go to wiki page">Programming_WayToHaskeller_てくてく</a>へ Go! (うーむ、さらにイー加減さに拍車がかかってきた。。。)</p>
<p>(<a href="http://www.sampou.org/cgi-bin/haskell.cgi?p=Programming:WayToHaskeller:%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%E2%A4%AD&amp;c=e&amp;l=jp">「よちよち歩き」を編集する</a>)|(<a href="http://www.sampou.org/cgi-bin/haskell.cgi?Programming:WayToHaskeller&amp;l=jp">Haskellerへの道</a>)</p>
<hr>
<h2 id="てくてく">てくてく</h2>
<p>(<a href="http://www.sampou.org/cgi-bin/haskell.cgi?p=Programming:WayToHaskeller:%EF%BF%BD%C6%A4%EF%BF%BD%EF%BF%BD%C6%A4%EF%BF%BD&amp;c=e&amp;l=jp">「てくてく」を編集する</a>)|(<a href="http://www.sampou.org/cgi-bin/haskell.cgi?Programming:WayToHaskeller&amp;l=jp">Haskellerへの道</a>)</p>
<h3 id="と---と">= と &lt;- と</h3>
<p>なんか分かったとは言えないけどモナドって、実はそんなにムツカシイもんで もないのかもとか思っちゃいました。そのキッカケが=と&lt;-です。ハイ。</p>
<p>モナドってのはどうやら何か秘密を隠しもってるヤツで、「秘密のある男性っ てステキ！」って感じのダンディーな方だったわけです。 通常関数型言語ではプログラムは式で構成されてて、そいつを評価すると値っ てやつを返してくれる訳ですね。 (通常って語るほど色々しってるわけじゃな いけどさ) で、実際大抵の場合大抵のプログラマにとって重要なのはこの値だっ たりするんですが、モナドの場合はアクションを取るものを返すようで、これ はこれで重要なんですが、実際に次なる(って言葉が曖昧だけど)処理にとって は大抵は役立たずだったりします。本当に欲しいのは隠し持ってる方の情報だっ たりするわけでんがな。</p>
<p>それを取り出すには x = getArgs とか x = getContents ではダメで、 x &lt;- getArgsとかx &lt;- getContentsなんですね。 当然次のようにして x = getArgsとか出来なくもないんだけど、</p>
<pre><code>test = let x = getArgs
         in [x]</code></pre>
<p>エバると、</p>
<pre><code>Main&gt; test
[&lt;&lt;IO action&gt;&gt;]
Main&gt; </code></pre>
<p>全然嬉しくないわけです。えぇ。でも、</p>
<pre><code>test2 x = do args &lt;- head x
              return args</code></pre>
<p>さらにこんな風にしてやれば、test2 testでもって内容を取り出せるっちゅー 寸法でんがな。 (あ、しまったreturnってことは…取り出せてねー) ま、まーだいたい意図は分るでしょ？ってことで、モナドに関しては、どうや らその区別がちゃんと分かっちゃうと案外可愛いものなのかもしれません。 つまり値を返してくるものとそいつが隠しもっているもの、そんでもって、そ れらの取り出し方ですな。</p>
<p>ただ、どうやら&lt;-によってどんな風にその秘密を取り出せるかはそのモナドの 種類によって違うって感じでしょうか。つまりリストにおいてcarっていうか headで取りだすのすら、恐らく一つの方法にすぎないのかもしれません。 (つ まり機構そのものとしては)多値でもって全要素を返すような、Scheme?の receiveみたいなものだとしてもおっけー！なのかもしんないワケっすよ。</p>
<pre><code> -- あくまでキモチとしてこんな感じデス
 -- haskell
do (x, y) &lt;- [1,2]
   ...
 -- scheme
receive (x y) ((lambda args (apply values args)) '(1 2))
   ...</code></pre>
<p>こんなイメージですね。じゃあ何でリスト(モナド)では&lt;-ってやった時に今の 仕様になってるのかっていうとワカリマヘンorz なんとなくモナド則とかいう屁理屈と関係あんじゃーねーの？って思ったんで すが、難しい議論は学生時代に足を洗ったのでパスです。</p>
<p>まーいずれにせよ、そう考えるとモナドってのは「なんでもモナド」(どっか で聞いたことあるな…)って言ってしまってもいいくらい、どこにでも出てき ていいんじゃねーの？とか思い上ってしまいそうです。</p>
<p>なんでもいいから何か新しい構造だとか型のようなもんを作ったら、それはリ スト同様に、値はその構造を返すし、その中身は&lt;-とかで取り出すのが必然の ようにすら思えてきます。 (ヤバイ洗脳がすすんでるかも…)</p>
<p>あ、そうそう。ちょっと思ったのは、こんな感じですよ。少し前に別の場所で 書いたScheme?のfoldnってやつです。</p>
<pre><code>(use srfi-1)
(use gauche.collection)
(define (foldn n proc . args)
  (let ((nils (take args n))
        (cols (map (cut coerce-to &lt;list&gt; &lt;&gt;) (drop args n))))
    (if (any null? cols)
        (apply values nils)
        (receive vals (apply proc (append (map car cols) nils))
          (apply foldn n proc (append vals (map cdr cols)))))))</code></pre>
<p>さて、ここで書いた時から気になってたのは、carやcdrが出て来てるトコです。 これはあまりにもリストに寄った作りで、実際&lt;collection&gt;なものに対応する ために coerce-toを使っているのですが、「これはよくないなー、よくない よー」と山本直樹のマンガに出てくるキャラばりに思ったわけですよ。はい。 そこで本当なら<a href="http://www.shiro.dreamhost.com/scheme/gauche/man/gauche-refj_71.html">イテレータ構築メソッド</a>とやらを使って、nextだかgetだと かいった、一段抽象的なメソッドを使って書くべきなんでしょう。</p>
<p>エーっと、また何を書こうとしてたのか忘れたぞ。なんだっけ？ あ、そーだ。つまり、これはcollectionだとかsequenceだとかってものに特化 してるんだけど、さらに一般化すると、中に何かを持っているものからそれな りの方法で中身を取り出すという、ただもうそれだけのようです。</p>
<p>正しくないんだけど、はっきしいって今の私にとっては、ほとんどScheme?の オブジェクトに対するrefとかslot-refとモナドにおける&lt;-ってたいして変わ んねーじゃんって感じなわけです。少なくとも位置付けとしてはそんなもんだ ろうってアバウトに思ってても使えそうな気にはなっちゃってるわけです。思 い上りまくりです。えぇ。</p>
<p>まぁ実際には、おおーそうなのかー！！とか思う程簡単じゃないわけで、モナ ドのバヤイはそれを使うコンテキスト(?)みたいなのとモナド則を満すような &gt;&gt;=とreturnの組合わせってのがナゾを呼ぶわけですな。 そこに入りだすとなんか地獄が手ぐすね引いて待ってそうなので近寄りません がね。まぁ「臆病なくらいでちょうどいいのよね」とかつぶやいたりしましょ う。</p>
<h3 id="さらに-との関係が分ってしまえば天下か">さらに&lt;-と&gt;&gt;=の関係が分ってしまえば天下か?</h3>
<p>でもってさらに衝撃の事実ですが、</p>
<pre><code>main = do cs &lt;- getArgs
          mapM_ putStrLn cs</code></pre>
<p>と</p>
<pre><code>main = getArgs &gt;&gt;= (\cs -&gt; mapM_ putStrLn cs)</code></pre>
<p>とは同じなんだそうです。多分以前もどっかで誰かに教えてもらったのかもし れませんが、はっきりいって頭に入ってないっす。そんなに色々覚えらんねー よーって(無礼にも)思ったに違いありません。が、今なら分りますね。 モナド的にはどうも&gt;&gt;=とreturnってプリミティブっぽい気がするんですが、 個人的にはっきり言って &lt;- のがずっとプリミティブって感じがするので、モ ナドって言わずに &lt;- これを ref とでも名付けて&gt;&gt;=とかは、シンタックスシュ ガーというかなんというか、まぁ欲を言えばうやむやにしてくんないかなーと か思ったりします。 思いませんか？そうですか、私だけですか…</p>
<p>ちなみに、mapM_ ってやつですが、正直mapとかmapMとかmapM_とか、なんでこ んなしちめんどくせーのか知りませんが、まぁ型が違うのでこういうもんなん でしょうね。 emacsのミニバッファに表示される型を見ながらイロイロ試すか、マニュアル を検索するかしてしのぎます。</p>
<p>あらためて見ておきましょう。</p>
<pre><code>main = do cs &lt;- getArgs
          mapM_ putStrLn cs</code></pre>
<p>こいつはgetArgsがIO [String]なので、アクションなんですが、[String]なヒ ミツを抱えてるワケですね。 でもって、&lt;-でそのヒミツをなんとか取り出してcsに束縛するんです。そう、 &lt;-はモサドみたいな機関で、モナドからモサドが国家機密を探り出すわけです。 (w (ただ、実際の動作はナゾです。そもそもこの時点で、ヒミツを全部取り出す 必要はないし、どういう順で取り出すのかもそのモナドの勝手じゃーんってこ とです。おそらくこれも必要になった時点で秘密がバクロされるという、ご都 合主義の2時間ドラマみたいな仕掛けになっているんでしょうね。 Preludeと いう名前といい、どうもHaskellを作った人は劇作家じゃないだろうかと勘繰っ たり) あとはmapM_で煮て焼いて食ってるだけっす。</p>
<pre><code>main = getArgs &gt;&gt;= (\cs -&gt; mapM_ putStrLn cs)</code></pre>
<p>こいつのバヤイも同じです。getArgsが抱えてるヒミツを&gt;&gt;=を通して右に送り つけてる感じでしょうか。右に渡ってるのは見えないけど[String]なデータだ と思えばよく、それをlambdaが処理してIO ()な形で始末してるんです。</p>
<p>私が&gt;&gt;=より&lt;-の方がプリミティブっぽいと感じたのは、多分データの受け渡 しが見えるからのような気がします。ハイレベルの言語って結局同じことをや るんだけど、暗黙裡にやってくれることが多いっていうか広いっていうか、まぁ いい感じに処理してくれちゃうわけで、見えない部分で活躍する裏方さんが大 勢いらっしゃるんです。 &gt;&gt;=もある意味そうなんですよね。今はlambdaを書い ているからcsが見えてますが、もし、</p>
<pre><code>printArgs = mapM_ putStrLn</code></pre>
<p>こんな風になってたら、</p>
<pre><code>main = getArgs &gt;&gt;= printArgs</code></pre>
<p>csが消滅しちゃうわけですね。そーすっと、csの存在が見えないのに動作の裏 側で暗躍することになるので、説明された時にイメージできないわけです。 (という言い訳です) 逆に&lt;-を使うとイヤでもcsの存在を書かなきゃならないので、これは表社会の 住人さんだからなんか人に優しい感じがするんですよね。(という言い訳です よ、しつこいけど)</p>
<h3 id="getcontentsのバヤイ">getContentsのバヤイ</h3>
<p>ほとんど同じなんだけど、getContentsを見ておきましょう。</p>
<pre><code>main = do cs &lt;- getContents
          putStr cs</code></pre>
<p>getContentsはIO Stringってことで、今度はヒミツはStringなものなので、 mapM_とかせずにそのままputStrに渡すことにしました。なんか全然簡単って 気がしてきましたね。</p>
<h3 id="さらにさらに-ってのはここにも登場">さらにさらに&lt;-ってのはここにも登場?</h3>
<p>でもって実は怪しい集会に潜入ルポって来た成果として、次のようなのも。</p>
<pre><code>[(x,y) | x&lt;-[1..100], y&lt;-[x..100],y==x*2]</code></pre>
<p>奥さんこれです。 リスト内包表記ってやつね。ここで出てくる&lt;-ってのはまさにモサドです。ハ イ。モナドじゃなくモサドの方ね。すごくないっすか？恐らく逆で、これは数 学の表記をもとに&lt;-な記号を採用して、その後一般化されたんじゃねーのかなー と思ったりするんですが、まさにリストもモナドなわけです。実際これ見たら、 やらずにはいられません。</p>
<pre><code>Main&gt; [1,2,3]&gt;&gt;=(\x-&gt;(x,x*x))
ERROR - Type error in application
*** Expression     : [1,2,3] &gt;&gt;= (\x -&gt; (x,x * x))
*** Term           : [1,2,3]
*** Type           : [b]
*** Does not match : (a,a)</code></pre>
<p>あら？あーあーあーそうか。</p>
<pre><code>Main&gt; [1,2,3]&gt;&gt;=(\x-&gt;[] (x,x*x))
ERROR - Type error in application
*** Expression     : [] (x,x * x)
*** Term           : []
*** Type           : [c]
*** Does not match : a -&gt; b</code></pre>
<p>え？えーっとリストにすればいーんだよね。も少し簡単なので確認。</p>
<pre><code>Main&gt; [1,2,3]&gt;&gt;=(\x-&gt;[] x)
ERROR - Type error in application
*** Expression     : [] x
*** Term           : []
*** Type           : [c]
*** Does not match : a -&gt; b</code></pre>
<p>あうっ！そもそも間違ってんのか。</p>
<pre><code>Main&gt; [1,2,3]&gt;&gt;=(\x-&gt;x:[x*x])
[1,1,2,4,3,9]</code></pre>
<p>おっけー！ちょっと意図が違うけど。</p>
<pre><code>Main&gt; [1,2,3]&gt;&gt;=(\x-&gt;[(x,x*x)])
[(1,1),(2,4),(3,9)]</code></pre>
<p>あ、これがやりたかったの。いーんでないすかね。</p>
<pre><code>Main&gt; [1,2,3]&gt;&gt;=(\x-&gt; return (x,x*x))
[(1,1),(2,4),(3,9)]</code></pre>
<p>勿論こんな風にreturnで[a]なリストモナドを返すのも正しい。ってか &gt;&gt;=と コンビで使うならこっちのが推奨なんでしょう、きっと。 ただ、[]を使うのは、いわば(上に示した)carやcdrを使ったfoldnの定義と同 じで、リストに特化した書き方になってる。一方でreturnを使う書き方はより 一般化された書き方になってるわけさ。</p>
<p>もう少し頑張ってみます。</p>
<pre><code>Main&gt; [1..100]&gt;&gt;=(\x-&gt; return [(x,y) | y&lt;-[x..100], y==x*2])
[[(1,2)],[(2,4)],[(3,6)],[(4,8)],...[],[],[],[]]</code></pre>
<p>あらら。おしい！所望の結果は</p>
<pre><code>Main&gt; [(x,y) | x&lt;-[1..100], y&lt;-[x..100],y==x*2]
[(1,2),(2,4),(3,6),(4,8),...,(47,94),(48,96),(49,98),(50,100)]</code></pre>
<p>なので、一個リストの構造が余計だなぁ。えーっと、あー分りましたよ！</p>
<pre><code>Main&gt; [1..100]&gt;&gt;=(\x-&gt; [(x,y) | y&lt;-[x..100], y==x*2])
[(1,2),(2,4),(3,6),(4,8),....,(47,94),(48,96),(49,98),(50,100)]</code></pre>
<p>キターーーーーーーー！ ぃよーーーっし、じゃあ続いてやっちゃうよ！</p>
<pre><code>Main&gt; [1..100]&gt;&gt;=(\x-&gt; [(x,y) | [x..100]&gt;&gt;=(\y-&gt; [y | y==x*2])])
ERROR - Undefined variable "y"</code></pre>
<p>あぅ！なんでダメなのさ？落ち付け落ち付け。</p>
<pre><code>Main&gt; [1..10]&gt;&gt;=(\x-&gt;[x])
[1,2,3,4,5,6,7,8,9,10]</code></pre>
<p>いけるよね。じゃあ絞ろう。</p>
<pre><code>Main&gt; [1..10]&gt;&gt;=(\x-&gt;[x| x==3])
[3]</code></pre>
<p>うーん。いけるな。ってことは、[x..100]が駄目なのかなぁ。</p>
<pre><code>Main&gt; let x=10 in [x..100]
[10,11,12,13,14,....,95,96,97,98,99,100]</code></pre>
<p>勿論大丈夫だよね。うーん。えーっと、あらら？そうか。よくよく見てみたら、 [x..100]&gt;&gt;=(\y-&gt;[y| y==x*2])ってしたら、それは単なるリストだからそれが yだってのは結びつかないのか。</p>
<pre><code>Main&gt; let x=5 in [y | [10..100], y==x*2]
ERROR - Undefined variable "y"</code></pre>
<p>みたいな感じになっちゃってんだな。そうか、そりゃダメですわ。 マジに副作用ないの？</p>
<p>この数日なんだかモナドについてまた考えてたんだけど、またちょっと目覚めたかも。</p>
<p>よく言われることなんだけど、Haskellって副作用がないって本当？とか 副作 用がなきゃプログラム書けないじゃんとかそーゆーやつです。 色んなところを調べると、モナドに閉じこめたとかモナドがそういう汚い世界 のことを一手に引き受けてくれてるとか書いてあるんだけど、相手からすると、 なーんだ結局あるんじゃん、副作用って言われちゃうわけですね。</p>
<pre><code>main = do cs &lt;- getContents
          putStr cs</code></pre>
<p>こちらにあるコードをGHCを使ってコンパイルします。</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="bad9cfce97c9dfdbfad4d1d3c9d3">[email&nbsp;protected]</a>&gt; ghci cat.hs -o cat</code></pre>
<p>そうするとcatっていう実行可能コードが出来ます。こいつを使ってみます。</p>
<pre><code><a href="email-protection.html" class="__cf_email__" data-cfemail="b2d1c7c69fc1d7d3f2dcd9dbc1db">[email&nbsp;protected]</a>&gt; ./cat
hoge
hoge
fuga
fuga
うひゃ
うひゃ^D
<a href="email-protection.html" class="__cf_email__" data-cfemail="8deef8f9a0fee8eccde3e6e4fee4">[email&nbsp;protected]</a>&gt; </code></pre>
<p>これを見ると、readする度に違う値を返してきてるじゃん。って思うわけです。 同じ式が評価する度に違う値を返してきてるってのは副作用があるってことじゃ ん？ BUT!!そりゃ早トチリってもんですね。よーくコードを見ると、どこにもread なんてないんです。勝手にreadしてるって妄想しちゃイヤーンです。</p>
<p>つまり、一行読んでその文字列を返すなんて関数は使われてないんですよ。 getContentsってのはreadじゃないってのがとっても重要。</p>
<p>getContentsは誤解を恐れずに言うならば、 私が入力する“hoge”、“fuga”そし て“うひゃ”っていう3行 (もしかしたらそれ以降にも入力されたかもしれない 行)全てを知ってて、 そいつを一種のリストのようなものに入れて返してきて いるんです。 そして、必要になったところで順番に中から取りだして表示しているに過ぎな いんです。 え？だって“うひゃ”ってのを読み込む前に“hoge”を表示してる(putStrしてる) じゃん！？ そりゃそうですYo!だって遅延評価ってそういうもんじゃん。それが許されな きゃ、[1..]なんて無限リストを全部構築しなきゃなんも計算できなくなりま す。 cat.hsでは、“hoge”を表示するときには“うりゃ”が本当に必要になるわ けではないから、べつにアクセスしてないだけなんですね。嘘だと思うなら、 [1..]をHugsのプロンプトに入れてみればいいでしょう。</p>
<pre><code>Main&gt; [1..]
[1,2,3,4,5,6,7,8,9,10,11.............................</code></pre>
<p>おっとっと、すぐ^Cしなきゃじゃんじゃんでちゃいます。ここでは無限大まで のリストを構築しなくても(つーかそんなんできないけど)、最初の方の表示に はなんの問題もないからちゃんと表示できてますよね。もー一個いっときましょ う。</p>
<pre><code>Main&gt; take 5 [1..]
[1,2,3,4,5]
Main&gt; </code></pre>
<p>この計算がちゃんと終了するのと同じ理由ですね。 そうなんだよね〜。リストもモナドだって衝撃を受けた時に気付くべきでした。</p>
<pre><code>listA = ["hoge", "fuga", "うひゃ"]</code></pre>
<p>っていうリストから順にデータを取りだした時に、「listAはアクセスする度 に、“hoge”とか“fuga”とか“うひゃ”とか毎回違う値を返してくるから副作用が ある」なんて言う人はおらんでしょう。それと同じことだったんですね。</p>
<p>ようやく結論ですが、副作用ってのを本当にうまく消してしまってるんですよ。 副作用はキレイサッパリ消失してしまったんです。押し付けられた一部の関数 が副作用を引き受けたんじゃなくて本当になくしたんです。にも関らず、副作 用と同じことを実現してるんです。</p>
<p>副作用みたいに毎回違う値が欲しいなら、その毎回変るであろう値ぜーんぶを 持つ一つの値(構造)をでっちあげて、そこから順番にデータを取り出すような 仕組み(モナディックなプログラミング)を作り上げるわけです。</p>
<p>まー考え方を変えただけって言われるかもしれませんが、上のようにリストに なぞらえて理解すると本当に消えちゃったでしょ？副作用。それでも言い換え ただけって思います？実際そういう仕組みを作ってコードもそーゆー感じに書 いてますってところが徹底してると思いますね。少なくとも私は自分で自分の 説明に納得しちゃたんでもういいです。はい。(^^)</p>
<p>最初はそんな副作用を使わずに入出力を表現するなんて無理だよーって思って ましたが、あなどれませんHaskellでもってモナド、そしてなにより本質的に それを可能にした遅延評価の世界です。 lazyだからこそ、そういう考え方が 成立するし、そういう意味付けと矛盾しない動作が実現できるんですね。</p>
<p>(<a href="http://www.sampou.org/cgi-bin/haskell.cgi?p=Programming:WayToHaskeller:%EF%BF%BD%C6%A4%EF%BF%BD%EF%BF%BD%C6%A4%EF%BF%BD&amp;c=e&amp;l=jp">「てくてく」を編集する</a>)|(<a href="http://www.sampou.org/cgi-bin/haskell.cgi?Programming:WayToHaskeller&amp;l=jp">Haskellerへの道</a>)</p>
<hr>
<h2 id="すきっぷ">すきっぷ</h2>
<p>(<a href="http://www.sampou.org/cgi-bin/haskell.cgi?p=Programming:WayToHaskeller:%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%C3%A4%EF%BF%BD&amp;c=e&amp;l=jp">「すきっぷ」を編集する</a>)|(<a href="http://www.sampou.org/cgi-bin/haskell.cgi?Programming:WayToHaskeller&amp;l=jp">Haskellerへの道</a>)</p>
<p>(<a href="http://www.sampou.org/cgi-bin/haskell.cgi?p=Programming:WayToHaskeller:%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%C3%A4%EF%BF%BD&amp;c=e&amp;l=jp">「すきっぷ」を編集する</a>)|(<a href="http://www.sampou.org/cgi-bin/haskell.cgi?Programming:WayToHaskeller&amp;l=jp">Haskellerへの道</a>)</p>
<hr>
<h2 id="ダンスダンスダンス">ダンスダンスダンス</h2>
<p>(<a href="http://www.sampou.org/cgi-bin/haskell.cgi?p=Programming:WayToHaskeller:%EF%BF%BD%EF%BF%BD%F3%A5%B9%A5%EF%BF%BD%F3%A5%B9%A5%EF%BF%BD%EF%BF%BD&amp;c=e&amp;l=jp">「ダンスダンスダンス」を編集する</a>)|(<a href="http://www.sampou.org/cgi-bin/haskell.cgi?Programming:WayToHaskeller&amp;l=jp">Haskellerへの道</a>)</p>
<p>(<a href="http://www.sampou.org/cgi-bin/haskell.cgi?p=Programming:WayToHaskeller:%EF%BF%BD%EF%BF%BD%F3%A5%B9%A5%EF%BF%BD%F3%A5%B9%A5%EF%BF%BD%EF%BF%BD&amp;c=e&amp;l=jp">「ダンスダンスダンス」を編集する</a>)|(<a href="http://www.sampou.org/cgi-bin/haskell.cgi?Programming:WayToHaskeller&amp;l=jp">Haskellerへの道</a>)</p>
<hr>
<p>Last modified : 2006/06/12 13:03:32 JST</p></div>
</div>
            <div id="footer">powered by <a href="https://github.com/jgm/gitit/tree/master/">gitit</a> × <a href="https://haskellonheroku.com/">Haskell on Heroku</a></div>
          </div>
        </div>
        <div id="sidebar" class="yui-b first">
          <div id="logo">
  <a href="_-1.html" alt="site logo" title="Go to top page"><img src="logo.png"></a>
</div>
                      <div class="sitenav">
  <fieldset>
    <legend>Site</legend>
    <ul>
      <li><a href="_-1.html">Front page</a></li>
      <li><a href="_index.html">All pages</a></li>
      <li><a href="_categories.html">Categories</a></li>
      <li><a href="https://wiki.haskell.jp/_random">Random page</a></li>
      <li><a href="https://wiki.haskell.jp/_activity">Recent activity</a></li>
              <li><a href="https://wiki.haskell.jp/_upload">Upload a file</a></li>
      
      
      <li><a href="Help.html">Help</a></li>
    </ul>
    <form action="https://wiki.haskell.jp/_search" method="get" id="searchform">
     <input type="text" name="patterns" id="patterns" value="">
     <input type="submit" name="search" id="search" value="Search">
    </form>
    <form action="https://wiki.haskell.jp/_go" method="post" id="goform">
      <input type="text" name="gotopage" id="gotopage" value="">
      <input type="submit" name="go" id="go" value="Go">
    </form>
  </fieldset>
</div>
          
                      <div class="pageTools">
  <fieldset>
    <legend>This page</legend>
    <ul>
      <li><a href="https://wiki.haskell.jp/_showraw/Old/sampou.org/Programming_WayToHaskeller">Raw page source</a></li>
      <li><a href="https://wiki.haskell.jp/Old/sampou.org/Programming_WayToHaskeller?printable">Printable version</a></li>
      <li><a href="https://wiki.haskell.jp/_delete/Old/sampou.org/Programming_WayToHaskeller">Delete this page</a></li>
      
    </ul>
    <form action="https://wiki.haskell.jp/Old/sampou.org/Programming_WayToHaskeller" method="post" id="exportbox"><select name="format"><option value="LaTeX" selected="selected">LaTeX</option><option value="ConTeXt">ConTeXt</option><option value="Texinfo">Texinfo</option><option value="reST">reST</option><option value="Markdown">Markdown</option><option value="CommonMark">CommonMark</option><option value="Plain text">Plain text</option><option value="MediaWiki">MediaWiki</option><option value="Org-mode">Org-mode</option><option value="ICML">ICML</option><option value="Textile">Textile</option><option value="AsciiDoc">AsciiDoc</option><option value="Man page">Man page</option><option value="DocBook">DocBook</option><option value="DZSlides">DZSlides</option><option value="Slidy">Slidy</option><option value="S5">S5</option><option value="EPUB">EPUB</option><option value="ODT">ODT</option><option value="DOCX">DOCX</option><option value="RTF">RTF</option></select>&nbsp;<input type="submit" name="export" id="export" value="Export"></form>
  </fieldset>
</div>
          
          
        </div>
    </div>
    <script data-cfasync="false" src="email-decode.min.js"></script><script src="jquery.min.js" type="text/javascript"></script><script src="jquery-ui.min.js" type="text/javascript"></script><script src="footnotes.js" type="text/javascript"></script><script src="MathJax.js" type="text/javascript"></script>
    
    <script type="text/javascript">
/* <![CDATA[ */
  $.get("/_user", {}, function(username, status) {
     $("#logged_in_user").text(username);
     if (username == "") {  // nobody logged in
        $("#logoutlink").hide();
        $("#loginlink").show();
     } else {
        $("#logoutlink").show();
        $("#loginlink").hide();
     };
   });
/* ]]> */
</script>
  
</body></html>